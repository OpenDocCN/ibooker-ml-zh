- en: Chapter 2\. Connect and Explore Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：连接和探索数据
- en: 'In [Chapter 1](ch01.html#connections_are_everything), we showed the potential
    of graph analytics and machine learning applied to human and business endeavors,
    and we proposed to present the details in three stages: the power of connected
    data, the power of graph analytics, and the power of graph machine learning. In
    this chapter, we will take a deep dive into the first stage: the power of connected
    data.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.html#connections_are_everything)中，我们展示了图分析和机器学习在人类和商业活动中的潜力，并且我们提出分三个阶段介绍细节：连接数据的力量，图分析的力量以及图机器学习的力量。在本章中，我们将深入探讨第一个阶段：连接数据的力量。
- en: Before we delve into the power of connected data, we need to lay some groundwork.
    We start by introducing the concepts and nomenclature of the graph data model.
    If you are already familiar with graphs, you may want to skim this section to
    check that we’re on the same page with regard to terminology. Besides graphs themselves,
    we’ll cover the important concepts of a graph schema and traversing a graph. Traversal
    is how we search for data and connections in a graph.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨连接数据的强大之前，我们需要先打下一些基础。我们从介绍图数据模型的概念和术语开始。如果你已经熟悉图，你可能想略过这一部分，确保我们在术语上达成一致。除了图本身，我们还将涵盖图模式和图遍历的重要概念。遍历是我们在图中搜索数据和连接的方式。
- en: And along the way, we talk about the differences between graph and relational
    databases and how we can ask questions and solve problems with graph analytics
    that would not be feasible in a relational database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们还将讨论图与关系数据库之间的区别，以及如何使用图分析提出问题和解决问题，在关系数据库中是不可行的。
- en: From that foundational understanding of what a graph is, we move on to present
    examples of the *power* of a graph by illustrating six ways that graph data provides
    you with more insight and more analytical capability than tabular data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从对图的基础理解开始，我们进一步展示图的*力量*，通过展示图数据提供比表格数据更多洞察力和分析能力的六种方式。
- en: 'After completing this chapter, you should be able to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您应该能够：
- en: Use the standard terminology for describing graphs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用描述图的标准术语
- en: Know the difference between a graph schema and a graph instance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解图模式和图实例之间的区别
- en: Create a basic graph model or schema from scratch or from a relational database
    model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头或从关系数据库模型创建基本图模型或模式
- en: Apply the “traversal” metaphor for searching and exploring graph data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用“遍历”这个隐喻来搜索和探索图数据
- en: Understand six ways that graph data empowers your knowledge and analytics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解图数据赋予您知识和分析能力的六种方式
- en: State the entity resolution problem and show how graphs resolve this problem
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阐述实体解析问题，并展示图如何解决这个问题
- en: Graph Structure
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图结构
- en: In [Chapter 1](ch01.html#connections_are_everything), we introduced you to the
    basic idea of a graph. In this section, we are going to go deeper. First we will
    establish the terminology that we will be using for the rest of this book. Then
    we will talk more about the idea of a graph schema, which is the key to having
    a plan and awareness of your data’s structure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.html#connections_are_everything)中，我们向您介绍了图的基本概念。在本节中，我们将更深入地讨论。首先，我们将确立本书其余部分将使用的术语。然后，我们将更多地讨论图模式的概念，这是制定数据结构计划和意识的关键。
- en: Graph Terminology
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图论术语
- en: Suppose you’re organizing data about movies, actors, and directors. Maybe you
    work for Netflix or one of the other streaming services, or maybe you’re just
    a fan.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在组织关于电影、演员和导演的数据。也许您在Netflix或其他流媒体服务公司工作，或者您只是一位影迷。
- en: 'Let’s start with one movie, *Star Wars: A New Hope*, its three main actors,
    and its director. If you were building this in a relational database, you could
    record this information in a single table, but the table would grow quickly and
    rapidly become unwieldy. How would we even record details about a movie, the fact
    that 50 actors appeared in it, and the details of each of those actor’s careers,
    all in one table?'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个电影开始，*星球大战：新希望*，它的三位主要演员以及它的导演。如果你在关系数据库中构建这个，你可以在单个表中记录这些信息，但是表会迅速增长并变得难以管理。我们甚至如何记录一部电影的细节，50名演员出演以及每位演员职业生涯的细节，都放在一个表中呢？
- en: Best practice for the design of relational databases would suggest putting actors,
    movies, and directors each into a separate table, but that would mean also adding
    in cross-reference tables to handle the many-to-many relationships between actors
    and movies and between movies and directors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计关系数据库的最佳实践中，建议将演员、电影和导演分别放入单独的表中，但这也意味着要添加交叉引用表来处理演员与电影之间以及电影与导演之间的多对多关系。
- en: So in total, you’d need five tables just to represent this example in a relational
    database, as in [Figure 2-1](#diagram_of_relational_tables_for_a_simp).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总共需要五个表来在关系数据库中表示这个例子，就像[图2-1](#diagram_of_relational_tables_for_a_simp)中所示。
- en: Separating different types of things into different tables is the right answer
    for organizing the data, but to see how one record relates to another, we have
    to rejoin the data. A query asking which actors worked with which directors would
    involve building a temporary table in memory called a join table that includes
    all possible combinations of rows across all the tables you’ve called, which satisfy
    the conditions of the query. Join tables are expensive in terms of memory and
    processor time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将不同类型的内容分别存储在不同的表中是组织数据的正确答案，但是要查看一条记录如何与另一条记录相关联，我们必须重新连接数据。一个查询，比如询问哪些演员与哪些导演合作，将涉及在内存中构建一个临时表，称为连接表，其中包括您调用的所有表的所有可能组合的行，这些行满足查询的条件。连接表在内存和处理器时间方面都是昂贵的。
- en: '![Diagram of relational tables for a simple movie database](assets/gpam_0201.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单电影数据库的关系表的图示](assets/gpam_0201.png)'
- en: Figure 2-1\. Diagram of relational tables for a simple movie database
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-1\. 一个简单电影数据库的关系表的图示
- en: As we can see from [Figure 2-2](#temporary_table_created_from_relational), there
    is a lot of redundant data in this table join. For very large or complex databases,
    you would want to think of ways to structure the data and your queries to optimize
    the join tables.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从[图2-2](#temporary_table_created_from_relational)中看到的那样，在这个连接表中有很多冗余数据。对于非常大或复杂的数据库，您希望考虑优化连接表的方式来组织数据和查询。
- en: '![Temporary table created from relational database query showing how three
    actors are linked to George Lucas via the movie Star Wars](assets/gpam_0202.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![从关系数据库查询创建的临时表，显示三位演员如何通过电影星球大战与乔治·卢卡斯相关联](assets/gpam_0202.png)'
- en: Figure 2-2\. Temporary table created from relational database query showing
    how three actors are linked to George Lucas via the movie Star Wars
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-2\. 从关系数据库查询创建的临时表，显示三位演员如何通过电影星球大战与乔治·卢卡斯相关联
- en: 'However, if we compare that to the graph approach, as shown in [Figure 2-3](#graph_showing_our_basic_information_abo),
    one thing becomes immediately clear: the difference between a table and graph
    is that a graph can directly show how one data element is related to another.
    That is, the relationships between the data points are built into the database
    and don’t have to be constructed at runtime. So one of the key differences between
    a graph and relational database is that in a graph database, the relationships
    between data points are *explicit*.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将其与图表方法进行比较，正如[图2-3](#graph_showing_our_basic_information_abo)所示，一个事情立即变得清楚：表格和图表的区别在于，图表可以直接显示一个数据元素如何与另一个相关联。也就是说，数据点之间的关系已经构建到数据库中，不需要在运行时构建。因此，图表和关系数据库之间的一个关键区别是，在图数据库中，数据点之间的关系是*显式*的。
- en: '![Graph showing our basic information about Star Wars](assets/gpam_0203.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![显示关于星球大战的基本信息的图表](assets/gpam_0203.png)'
- en: Figure 2-3\. Graph showing our basic information about Star Wars
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3\. 显示关于星球大战的基本信息的图表
- en: 'Each actor, movie, and director is called a *node* or a *vertex* (plural: *vertices*).
    Vertices represent things, physical or abstract. In our example, the graph has
    five vertices. The connections between vertices are called *edges*, which describe
    the relationships between the vertices. Edges are also considered data elements.
    This graph has four edges: three for actors showing how they are related to a
    movie (`acted_in`), and one for a director showing their relationship to a movie
    (`directed_by`). In its simplest form, a *graph* is a collection of vertices and
    edges. We will use the general term *object* to refer to either a vertex or an
    edge.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个演员、电影和导演被称为*节点*或*顶点*（复数：*vertices*）。顶点代表事物，无论是物理的还是抽象的。在我们的例子中，图有五个顶点。顶点之间的连接称为*边*，描述了顶点之间的关系。边也被视为数据元素。这个图有四条边：三条用于演员展示他们如何与电影相关（`acted_in`），以及一条用于导演展示他们与电影的关系（`directed_by`）。在其最简单的形式中，*图*是顶点和边的集合。我们将使用通用术语*对象*来指代顶点或边。
- en: 'With this graph, we can answer a basic question: what actors have worked with
    the director George Lucas? Starting from George Lucas, we look at the movies he
    directed, which include *Star Wars*, and then we look at the actors in that movie,
    which include Mark Hamill, Carrie Fisher, and Harrison Ford.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个图，我们可以回答一个基本问题：哪些演员与导演乔治·卢卡斯一起工作过？从乔治·卢卡斯开始，我们查看他执导的电影，包括*星球大战*，然后我们查看该电影中的演员，包括马克·哈米尔、凯丽·费雪和哈里森·福特。
- en: It can be useful or even necessary to distinguish the direction of an edge.
    In a graph database, an edge can be *directed* or *undirected*. A *directed edge*
    has a specific directionality, going from a source vertex to a target vertex.
    We draw directed edges as arrows.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 区分边的方向可能是有用的，甚至是必要的。在图数据库中，边可以是*有向*或*无向*的。*有向边*具有特定的方向性，从源顶点到目标顶点。我们将有向边画成箭头。
- en: By adding a directed edge, we can also show hierarchy, that is, *The Empire
    Strikes Back* was the sequel to *Star Wars* ([Figure 2-4](#multimovie_graph_with_a_directed_edgedo)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加有向边，我们还可以显示层次结构，即*帝国反击战*是*星球大战*的续集（[图 2-4](#multimovie_graph_with_a_directed_edgedo)）。
- en: '![Multimovie graph with a directed edge. This shows how we begin to build up
    the database with additional movies and production personnel. Note the directed
    edge, is_sequel_of, which provides the context to show that Empire was the sequel
    to Star Wars and not vice versa.](assets/gpam_0204.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![带有有向边的多电影图。这展示了我们如何通过添加额外的电影和制作人员逐步构建数据库。请注意有向边，is_sequel_of，它提供了背景，显示帝国是星球大战的续集而不是反过来。](assets/gpam_0204.png)'
- en: Figure 2-4\. Multimovie graph with a directed edge. This shows how we begin
    to build up the database with additional movies and production personnel. Note
    the directed edge, `is_sequel_of`, which provides the context to show that Empire
    was the sequel to Star Wars and not vice versa.
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-4\. 带有有向边的多电影图。这展示了我们如何通过添加额外的电影和制作人员逐步构建数据库。请注意有向边`is_sequel_of`，它提供了背景，显示帝国是星球大战的续集而不是反过来。
- en: To do more useful work with a graph, however, we will want to add more details
    about each vertex or edge, such as an actor’s birth date or a movie’s genre.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要对图进行更多有用的工作，我们需要为每个顶点或边添加更多细节，比如演员的出生日期或电影的流派。
- en: This book describes property graphs. A *property graph* is a graph where each
    vertex and each edge can have properties that provide the details about individual
    elements. If we look again at relational databases, properties are like the columns
    in a table. Properties are what make graphs truly useful. They add richness and
    context to data, which enables us to develop more nuanced queries to extract just
    the data that we need. [Figure 2-5](#graph_with_properties) shows the *Star Wars*
    graph with some added features.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本书描述了属性图。*属性图*是一种图，其中每个顶点和每条边都可以具有提供有关个别元素详细信息的属性。如果我们再次看关系数据库，属性就像表中的列。属性使得图变得真正有用。它们为数据添加了丰富性和上下文，这使我们能够开发更加细致的查询，提取我们所需的数据。[图 2-5](#graph_with_properties)展示了带有一些额外功能的*星球大战*图。
- en: '![Graph with properties](assets/gpam_0205.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![带有属性的图](assets/gpam_0205.png)'
- en: Figure 2-5\. Graph with properties
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. 带有属性的图
- en: Graphs offer us another choice for modeling properties. Instead of treating
    genre as a property of movies, we could make each genre a separate vertex. Why
    do this? When the property is categorical, then we expect lots of other vertices
    to have the same property value (e.g., there are lots of sci-fi movies). All the
    sci-fi movies will link to the `Sci-fi` vertex, making it incredibly easy to search
    them or to collect statistics about them, such as “what was the top-grossing sci-fi
    movie?” All the non-sci-fi movies have already been filtered out for you. Graph
    structure can not only model your core data but can also act as a search index.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图形为我们建模属性提供了另一种选择。与其将电影类型作为电影的属性处理，我们可以将每种类型单独建模为一个独立的顶点。为什么这么做呢？当属性是分类的时候，我们预计会有许多其他顶点具有相同的属性值（例如，有许多科幻电影）。所有的科幻电影都将链接到`Sci-fi`顶点，这样就非常容易搜索它们或收集关于它们的统计信息，比如“最卖座的科幻电影是什么？”所有非科幻电影已经被过滤掉了。图结构不仅可以模拟您的核心数据，还可以充当搜索索引。
- en: Other reasons why we might want to model a property as a vertex is to improve
    the normalization or the data richness. *Normalization* is an approach to decomposing
    tables to eliminate redundancy and update complexities. Additionally, decomposing
    into more vertex types means we have more things that can have properties.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将属性建模为顶点的另一个原因是为了改善规范化或数据的丰富性。*规范化*是一种分解表以消除冗余和更新复杂性的方法。此外，将其分解为更多的顶点类型意味着我们有更多可以拥有属性的东西。
- en: 'In our movie database example, we might want to create a new type of vertex
    called **`Character`** so we can show who played what role. [Figure 2-6](#movie_graph_with_actor_and_character_ty)
    shows our *Star Wars* graph with the addition of **`Character`** vertices. The
    interesting thing about Darth Vader, of course, is that he was played by two people:
    David Prowse (in costume) and James Earl Jones (voice). Fortunately, our database
    can represent this reality with a minimum of modification.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电影数据库示例中，我们可能希望创建一个名为**`Character`**的新类型的顶点，以便展示谁扮演了什么角色。[图 2-6](#movie_graph_with_actor_and_character_ty)展示了我们的*星球大战*图，增加了**`Character`**顶点。当然，有趣的是达斯·维达由两个人扮演：戴维·普罗斯（穿着装备）和詹姆斯·厄尔·琼斯（配音）。幸运的是，我们的数据库可以通过最小的修改来表示这个现实。
- en: '![Movie graph with Actor and Character types. The flexibility of this schema
    enables us to easily show two actors portraying one character.](assets/gpam_0206.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![带有演员和角色类型的电影图。此模式的灵活性使我们能够轻松展示两位演员扮演同一角色。](assets/gpam_0206.png)'
- en: Figure 2-6\. Movie graph with **`Actor`** and **`Character`** types. The flexibility
    of this schema enables us to easily show two actors portraying one character.
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-6\. 带有**`Actor`**和**`Character`**类型的电影图。此模式的灵活性使我们能够轻松展示两位演员扮演同一角色。
- en: What else can we do with this graph? Well, it’s flexible enough to allow us
    to add just about every person who was involved in the production of this movie—from
    the director and actors to make-up artists, special effects artists, key grip,
    and even best boy. Everyone who contributed to a movie could be linked using an
    edge called `worked_on` and an edge property called `role`, which could include
    `director`, `actor`, `voice actor`, `camera operator`, `key grip`, and so on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个图做什么？嗯，它足够灵活，可以让我们添加几乎每个参与电影制作的人员——从导演和演员到化妆师、特效艺术家、主摄像师，甚至最佳助理。每个为电影做出贡献的人都可以用一个称为`worked_on`的边和一个称为`role`的边属性连接起来，其中可能包括`director`、`actor`、`voice
    actor`、`camera operator`、`key grip`等等。
- en: If we then built up our database to include thousands of movies and everyone
    who had worked on them, we could use graph algorithms to answer questions like
    “Which actors do certain directors like to work with most?” With a graph database,
    you can answer less obvious questions like “Who are the specialists in science
    fiction special effects?” or “Which lighting technicians do certain directors
    like to work with most?” Interesting questions for companies that sell graphics
    software or lighting equipment.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们扩展我们的数据库，包括成千上万部电影和所有参与其制作的人员，我们可以使用图算法回答像“某些导演最喜欢与哪些演员合作？”这样的问题。通过图数据库，您可以回答像“谁是科幻特效的专家？”或“某些导演最喜欢与哪些照明技术人员合作？”这样不那么明显的问题。对于销售图形软件或照明设备的公司来说，这些都是有趣的问题。
- en: With a graph database, you can connect to multiple data sources, extract just
    the data you need as vertices, and run queries against the combined dataset. If
    you had access to a database of lighting equipment used on various movie projects,
    you could connect that to your movie database and use a graph query to ask which
    lighting technicians have experience with what equipment.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过图数据库，您可以连接多个数据源，提取所需的顶点数据，并针对组合数据集运行查询。如果您可以访问用于各种电影项目的照明设备数据库，您可以将其连接到您的电影数据库，并使用图查询来询问哪些照明技术人员具有何种设备的经验。
- en: '[Table 2-1](#glossary_of_essential_graph_terminology) summarizes the essential
    graph terminology we have introduced.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-1](#glossary_of_essential_graph_terminology) 总结了我们介绍的关键图术语。'
- en: Table 2-1\. Glossary of essential graph terminology
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1\. 关键图术语表
- en: '| Term | Definition |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 术语 | 定义 |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Graph | A collection of vertices, edges, and properties used to represent
    connected data and support semantic queries. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 图 | 用于表示连接数据并支持语义查询的顶点、边和属性的集合。 |'
- en: '| Vertex^([a](ch02.html#ch01fn2)) | A graph object used to represent an object
    or thing. Plural: vertices. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 顶点^([a](ch02.html#ch01fn2)) | 用于表示对象或物体的图对象。复数形式：顶点。 |'
- en: '| Edge | A graph object that links two vertices, often used to represent a
    relationship between two objects or things. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 边 | 连接两个顶点的图对象，通常用于表示两个对象或物体之间的关系。 |'
- en: '| Property | A variable associated with a vertex or edge, often used to describe
    it. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 与顶点或边相关联的变量，通常用于描述它。 |'
- en: '| Schema | A database plan comprising vertex and edge types and associated
    properties that will define the structure of the data. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 包括顶点和边类型及相关属性的数据库计划，将定义数据的结构。 |'
- en: '| Directed edge / Undirected edge | A directed edge represents a relationship
    with a clear semantic direction, from a source vertex to a destination vertex.
    An undirected edge represents a relationship in which no direction is implied.
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 有向边 / 无向边 | 有向边表示一个具有明确语义方向的关系，从源顶点到目标顶点。无向边表示一个没有方向暗示的关系。 |'
- en: '| ^([a](ch02.html#ch01fn2-marker)) Another commonly used alternative name is
    *node*. It is a matter of personal preference. It’s been proposed that the upcoming
    ISO standard query language for property graphs accept either VERTEX or NODE.
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch02.html#ch01fn2-marker)) 另一个常用的替代名称是*节点*。这是个人偏好的问题。已经提出，下一代ISO标准的属性图查询语言将接受VERTEX或NODE的任一术语。
    |'
- en: Graph Schemas
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图模式
- en: In the previous section, we intentionally started with a very simple graph and
    then added complexity, by adding not only more vertices, edges, and properties
    but also new *types* of vertices and edges. To model and manage a graph well,
    especially in a business setting, it’s essential to plan out your data types and
    properties.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们有意从一个非常简单的图开始，并通过添加更多的顶点、边和属性以及新的*顶点*和*边*类型来增加复杂性。要有效地对图进行建模和管理，特别是在商业环境中，规划数据类型和属性是至关重要的。
- en: We call this plan a graph *schema*, or graph *data model*, analogous to the
    schema or entity-relationship model for a relational database. It defines the
    types of vertices and edges that our graph will contain as well as the properties
    associated with these objects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这个计划为图*模式*，或图*数据模型*，类似于关系数据库的模式或实体-关系模型。它定义了我们的图将包含的顶点和边的类型，以及与这些对象相关联的属性。
- en: You could make a graph without a schema by just adding arbitrary vertices and
    edges, but you’d quickly find it difficult to work with and difficult to make
    sense of. Also, if you wanted to search the data for all the movies, for example,
    it would be extremely helpful to know that they are all in fact referred to as
    “movie” and not “film” or “motion picture”!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过仅添加任意顶点和边来创建一个没有模式的图，但很快你会发现它很难处理，也很难理解。另外，例如，如果你想搜索数据中的所有电影，知道它们实际上都被称为“电影”，而不是“电影”或“电影”，将非常有帮助！
- en: It’s also helpful to settle on a standard set of properties for each object
    type. If we know all movie vertices have the same core set of properties, such
    as title, genre, and release date, then we can easily and confidently perform
    analysis on those properties.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 确定每种对象类型的标准属性集也是有帮助的。如果我们知道所有电影顶点都具有相同的核心属性，如标题、类型和发布日期，那么我们可以轻松自信地对这些属性进行分析。
- en: '[Figure 2-7](#graph_schema_for_movie_database) shows a possible schema for
    a movie graph database. It systematically handles several of the data complexities
    that arose as we talked about adding more and more movies to the database.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-7](#graph_schema_for_movie_database) 展示了电影图数据库的可能模式。它系统地处理了随着数据库中电影增多而产生的几种数据复杂性。'
- en: '![Graph schema for movie database](assets/gpam_0207.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![电影数据库的图模式](assets/gpam_0207.png)'
- en: Figure 2-7\. Graph schema for movie database
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-7\. 电影数据库的图模式
- en: 'Let’s run through the features of the schema:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看模式的特点：
- en: A **`Person`** vertex type represents a real-world person, such as `George Lucas`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Person`** 顶点类型表示现实世界中的人物，如 `George Lucas`。'
- en: 'The **`Worked_on`** edge type connects a **`Person`** to a **`Movie`**. It
    has a property to describe the person’s role: `director`, `producer`, `actor`,
    `gaffer`, etc. By having the role as a property, we can support as many roles
    as we want with only one vertex type for persons and one edge type for working
    on a film. If a person had multiple roles, then the graph can have multiple edges.^([1](ch02.html#ch01fn3))
    Schemas only show one of each type of object.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Worked_on`** 边类型连接一个 **`Person`** 到一个 **`Movie`**。它有一个属性来描述人的角色：`director`、`producer`、`actor`、`gaffer`
    等。通过将角色作为属性，我们可以支持任意数量的角色，只需一个人员顶点类型和一个工作在电影上的边类型。如果一个人有多个角色，那么图可以有多个边。^([1](ch02.html#ch01fn3))
    模式只显示每种类型的一个对象。'
- en: The **`Character`** vertex type is separate from the **`Person`** vertex type.
    One **`Person`** could portray more than one **`Character`** (Tyler Perry in the
    *Madea* films), or more than one **`Person`** could portray one **`Character`**
    (David Prowse, James Earl Jones, and Sebastian Shaw as Darth Vader in *The Return
    of the Jedi*).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Character`** 顶点类型与 **`Person`** 顶点类型分开。一个 **`Person`** 可能扮演多个 **`Character`**（例如
    Tyler Perry 在 *Madea* 系列电影中），或者多个 **`Person`** 可能扮演一个 **`Character`**（例如 David
    Prowse、James Earl Jones 和 Sebastian Shaw 在 *The Return of the Jedi* 中扮演 Darth
    Vader）。'
- en: The **`Movie`** vertex type is straightforward.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Movie`** 顶点类型非常直观。'
- en: '**`Is_sequel_of`** is a directed edge type, telling us that the source **`Movie`**
    is the sequel of the destination **`Movie`**.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Is_sequel_of`** 是一个有向边类型，告诉我们源头 **`Movie`** 是目标 **`Movie`** 的续集。'
- en: As noted before, we chose to model the **`Genre`** of a movie as a vertex type
    instead of as a property, to make it easier to filter and analyze movies by genre.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，我们选择将电影的 **`Genre`** 建模为一个顶点类型，而不是作为属性，以便更容易通过流派对电影进行筛选和分析。
- en: The key to understanding schemas is that having a consistent set of object types
    makes your data easier to interpret.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 理解模式的关键在于拥有一致的对象类型集合，使得数据更易于解释。
- en: Traversing a Graph
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历图
- en: 'Traversing a graph is the fundamental metaphor for how a graph is searched
    and how the data is gathered and analyzed. Imagine the graph as a set of interconnecting
    stepping stone paths, where each stepping-stone represents a vertex. There are
    one or more agents who are accessing the graph. To read or write a vertex, an
    agent must be standing on its stepping stone. From there, the agent may step or
    traverse across an edge to a neighboring stone/vertex. From its new location,
    the agent can then take another step. Remember: if two vertices are directly connected,
    it means there is a relationship between them, so traversing is following the
    chain of relationships.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历图是搜索图和收集分析数据的基本隐喻。想象图像为一组互相连接的踏脚石路径，其中每个踏脚石代表一个顶点。有一个或多个代理人在访问图。要读取或写入一个顶点，代理人必须站在其踏脚石上。从那里，代理人可以跨越边缘到达相邻的石头/顶点。从其新位置，代理人可以再次迈出一步。记住：如果两个顶点直接连接，这意味着它们之间有关系，因此遍历是跟随关系链。
- en: Hops and Distance
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳跃和距离
- en: Traversing one edge is also called making a *hop*. An analogy to traversing
    a graph is moving on a game board, like the one shown in [Figure 2-8](#traversing_a_graph_is_like_moving_on_a).
    A graph is an exotic game board, and you traverse the graph as you would move
    across the game board.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历一个边也称为进行一次*跳跃*。遍历图的类比是移动游戏板上的移动，就像 [图 2-8](#traversing_a_graph_is_like_moving_on_a)
    中所示的那样。图是一个奇特的游戏板，你遍历图就像你在游戏板上移动一样。
- en: '![Traversing a graph is like moving on a game board](assets/gpam_0208.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![遍历图就像在游戏板上移动](assets/gpam_0208.png)'
- en: Figure 2-8\. Traversing a graph is like moving on a game board
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-8\. 遍历图就像在游戏板上移动
- en: In many board games, when it is your turn, you roll a die to determine how many
    steps or hops to take. In other games, you may traverse the board until you reach
    a space of a certain type. This is exactly like traversing a graph in search of
    a particular vertex type.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多棋盘游戏中，轮到你时，你要掷骰子来确定要走多少步或跳数。在其他游戏中，你可能要穿越棋盘，直到到达某种类型的空间。这与搜索特定顶点类型的图形遍历完全相同。
- en: Graph hops and distance come up in other real-world situations. You may have
    heard of “six degrees of separation.” This refers to the belief that everyone
    in the United States is connected to everyone else through at most six hops of
    relationship. Or, if you use the LinkedIn business network app, you have probably
    seen that when you look at a person’s profile, LinkedIn will tell you if they
    are connected to you directly (one hop), through two hops, or through three hops.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图跳跃和距离在其他现实世界的情况中也会出现。你可能听说过“六度分隔”的说法。这指的是相信每个美国人都通过至多六次关系连接到其他每个人。或者，如果你使用LinkedIn商业社交应用程序，你可能已经看到，当你查看一个人的个人资料时，LinkedIn会告诉你他们是否直接与你连接（一跳），通过两跳或三跳。
- en: 'Traversing a graph is also how searches are conducted in graph databases. There
    are two basic approaches: either visit every neighbor vertex before continuing
    to the next level (breadth-first search) or follow a single chain of connections
    to the end before trying alternate paths (depth-first search). We’ll go further
    into detail about these search types in [Chapter 6](ch06.html#analyzing_connections_for_deeper_insigh).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在图数据库中进行搜索也是如何进行搜索的。有两种基本方法：要么在继续到下一级邻居顶点之前访问每个邻居顶点（广度优先搜索），要么在尝试备选路径之前，沿着单条连接链到达尽头（深度优先搜索）。我们将在[第6章](ch06.html#analyzing_connections_for_deeper_insigh)中详细介绍这些搜索类型。
- en: Breadth and Depth
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广度和深度
- en: There are two basic approaches to systematically traversing a graph to conduct
    a search. Breadth-first search (BFS) means visit each of your direct neighbors
    before continuing the search to the next level of neighbors, the next level, and
    so on. Graph databases with parallel processing can accelerate BFS by having multiple
    traversals take place at the same time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种基本方法可以系统地遍历图形以进行搜索。广度优先搜索（BFS）意味着在继续到下一级邻居之前，访问您的每个直接邻居，下一级邻居，依此类推。具有并行处理能力的图数据库可以通过同时进行多个遍历来加速BFS。
- en: Depth-first search (DFS) means follow a single chain of connections as far as
    you can before backtracking to try other paths. Both BFS and DFS will result in
    eventually visiting every vertex, unless you stop because you have found what
    you sought.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索（DFS）意味着在回溯尝试其他路径之前，沿着单条连接链尽可能远地进行。无论是BFS还是DFS，最终都将访问每个顶点，除非因为找到了所需的内容而停止。
- en: Graph Modeling
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图模型
- en: Now you know what graphs and graph schemas are. But how do you come up with
    a good graph model?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了图和图模式是什么。但是如何设计出一个好的图模型呢？
- en: 'Start by asking yourself these questions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要问自己这些问题：
- en: What are the key objects or entities that I care about?
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我关心的主要对象或实体是什么？
- en: What are the key relationships that I care about?
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我关心的关键关系是什么？
- en: What are the key properties of entities that I want to filter out?
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想要过滤掉的实体的主要属性是什么？
- en: Schema Options and Trade-Offs
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式选项与权衡
- en: As we have seen, good graph schema design represents data and relationships
    in a natural way that allows us to traverse vertices and edges as if they were
    real-world objects. As with any collection of real-world things, there are many
    ways we could organize our collection to optimize searching and extracting what
    we need.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，良好的图模式设计以自然的方式表示数据和关系，使我们能够遍历顶点和边，就像它们是真实世界的对象一样。与任何一组真实世界的东西一样，我们可以以许多方式来组织我们的集合，以优化搜索和提取所需的内容。
- en: In designing a graph database, two considerations that will influence the design
    are the format of our input data and our query use cases. And as we will see in
    this section, a key trade-off is whether we want to optimize our schema to use
    less memory or make queries run faster.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计图数据库时，影响设计的两个考虑因素是我们输入数据的格式和我们的查询用例。正如我们将在本节中看到的那样，一个关键的权衡是我们是想要优化模式以节省内存，还是使查询运行更快。
- en: Vertex, edge, or property?
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顶点、边还是属性？
- en: If you are converting tabular data into a graph, the natural thing seems to
    be to convert each table to a vertex type and each table column to a vertex property.
    In fact, a column could map to a vertex, an edge, a property of a vertex, or a
    property of an edge.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将表格数据转换为图形，自然的做法似乎是将每个表转换为顶点类型，将每个表列转换为顶点属性。实际上，一列可以映射到顶点、边缘、顶点的属性或边缘的属性。
- en: Entities and abstract concepts generally map to vertices, and you could think
    of them as nound, such as *movie* or *actor* from our earlier example. Relationships
    generally map to edges, and you can think of them as verbs, such as *directs*
    or *acts*. Descriptors are analogous to adjectives and adverbs and can map to
    vertex or edge properties, depending on the context and your query use case.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实体和抽象概念通常映射到顶点，您可以将它们视为名词，例如前面示例中的*movie*或*actor*。关系通常映射到边缘，您可以将它们视为动词，例如*directs*或*acts*。描述符类似于形容词和副词，根据上下文和查询用例，可以映射到顶点或边缘属性。
- en: At first glance, it would appear that storing object attributes as close to
    the object as possible—that is, as properties—would deliver the most optimal solution.
    However, consider a use case in which you need to optimize your search for product
    color. Color is a quality that would usually be expected to be found as a property
    of a vertex, but then searching for blue objects would necessitate looking at
    every vertex.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，将对象属性尽可能靠近对象存储（即作为属性）似乎会提供最优的解决方案。然而，考虑一个需要优化产品颜色搜索的用例。颜色通常是作为顶点属性找到的质量，但是搜索蓝色对象将需要查看每个顶点。
- en: In a graph, you can create a search index by defining a vertex type called **`color`**
    and linking the **`color`** vertex and the **`product`** vertex via an undirected
    edge. Then to find all `blue` objects, you simply start from the **`color`** vertex
    `blue` and find all linked **`product`** vertices. This speeds up query performance,
    with the trade-off being greater complexity and higher memory usage.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，您可以通过定义一个称为**`color`**的顶点类型并通过无向边缘将**`color`**顶点和**`product`**顶点连接起来来创建搜索索引。然后，要查找所有`blue`对象，您只需从**`color`**顶点`blue`开始，并找到所有链接的**`product`**顶点。这可以加快查询性能，但折衷是增加了复杂性和内存使用。
- en: Edge direction
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边缘方向性
- en: Earlier we introduced the concept of directionality in edges and noted that
    you can, in your design schema, define an edge type as directed or undirected.
    In this section, we’ll discuss the benefits and trade-offs of each type. We’ll
    also discuss a hybrid option available in the TigerGraph database.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 较早时我们介绍了边缘方向性的概念，并指出您可以在设计模式中将边缘类型定义为有向或无向。在本节中，我们将讨论每种类型的优缺点。我们还将讨论TigerGraph数据库中的混合选项。
- en: This is so useful you might think you could use it all the time, but with all
    things computational, there are benefits and trade-offs in your choice of edge
    type.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如此有用，以至于您可能认为您可以一直使用它，但在计算的所有事物中，您在边缘类型选择时都会有优缺点。
- en: Undirected edge
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 无向边缘
- en: Links any two vertices of defined type with no directionality implied. The benefit
    is they are easy to work with when creating links and easy to traverse in either
    direction. For example, if users and email addresses are both vertex types, you
    can use an undirected edge to find someone’s email but also find all the users
    who use that same email address—something you can’t do with a directed edge.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 连接任意两个定义类型的顶点，没有方向性暗示。它们易于在创建链接时使用，并且在任何方向上遍历也很容易。例如，如果用户和电子邮件地址都是顶点类型，您可以使用无向边缘找到某人的电子邮件，但也可以找到使用相同电子邮件地址的所有用户——这是使用有向边缘无法实现的。
- en: The trade-off with an undirected edge is it does not give you contextual information
    such as hierarchy. If you have an enterprise graph and want to find the parent
    company, for example, you can’t do this with undirected edges because there is
    no hierarchy. In this case, you would need to use a directed edge.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 无向边缘的折衷之处在于它不提供层次结构等上下文信息。例如，如果您有一个企业图，并且想找到母公司，您无法使用无向边缘，因为没有层次结构。在这种情况下，您需要使用有向边缘。
- en: Directed edge
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有向边缘
- en: Represents a relationship with a clear semantic direction, from a source vertex
    to a destination vertex. The benefit to a directed edge is it gives you more contextual
    information. It is likely to be more efficient for the database to store and handle
    than an undirected edge. The trade-off, however, is you can’t trace backward should
    you need to.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表示具有明确语义方向的关系，从源顶点到目标顶点。有向边的好处是它提供更多的上下文信息，很可能比无向边更高效地存储和处理。然而，需要权衡的是，如果需要，您无法向后追溯。
- en: Directed edge paired with a reverse directed edge
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与逆向有向边配对
- en: 'You can have the benefits of directional semantics *and* traversing in either
    direction if you define two directed edge types, one for each direction. For example,
    to implement a family tree, you could define a **`child_of`** edge type to traverse
    down the tree and a **`parent_of`** edge type to traverse up the tree. The trade-off,
    though, is you have to maintain two edge types: every time you insert or modify
    one edge, you need to insert or modify its partner. The TigerGraph database makes
    this easier by allowing you to define the two types together and to write data
    ingestion jobs that handle the two together.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您定义两种有向边类型，分别表示两个方向，您可以同时享有方向语义的优点以及双向遍历的便利。例如，要实现一个家谱，您可以定义一个**`child_of`**边类型来向下遍历树，以及一个**`parent_of`**边类型来向上遍历树。然而，需要权衡的是，您需要维护两种边类型：每次插入或修改一个边时，您都需要插入或修改其配对边。TigerGraph数据库通过允许您一起定义这两种类型，并编写处理这两种类型数据摄入作业来简化这一过程。
- en: As you can see, your choice of edge type will be influenced by the types of
    queries you need to run balanced against operational overheads such as memory,
    speed, and coding.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您选择的边类型将受到您需要运行的查询类型以及操作开销（如内存、速度和编码）的影响平衡。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If the source vertex and destination vertex types are different, such as **`Person`**
    and **`Product`**, you can usually settle for an undirected edge and let the vertex
    types provide the directional context. It’s when the two vertex types are the
    same and you care about direction that you must use a directed edge.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源顶点和目标顶点类型不同，例如**`Person`**和**`Product`**，通常可以选择无向边，并让顶点类型提供方向上下文。只有当两个顶点类型相同且您关心方向时，您必须使用有向边。
- en: Granularity of edge type
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边类型的粒度
- en: How many different edge types do you need, and how can you optimize your use
    of edge types? In theory, you could have one edge type—undirected—that linked
    every type of vertex in your schema. The benefit would be simplicity—only one
    edge type to remember!—but the trade-offs would be the number of edge properties
    you would need for context and slower query performance.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要多少不同的边类型，并且如何优化您对边类型的使用？理论上，您可以只有一种边类型——无向边类型，它连接您模式中的每种顶点类型。其好处是简单性——只需要记住一种边类型！然而，需要权衡的是，您需要边属性的数量以获取上下文，并且查询性能可能会变慢。
- en: At the other extreme, you could have a different edge type for each type of
    relationship. For instance, in a social network, you could have separate edge
    types for **`coworker`**, **`friend`**, **`parent_of`**, **`child_of`**, and so
    on. This would be very efficient to traverse if you were looking for just one
    type of relationship, such as professional networks. The trade-off is the need
    to define new edge types to represent new types of relationships and a loss of
    abstraction—that is, an increase in complexity—in your code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个极端，您可以为每种关系类型定义不同的边类型。例如，在社交网络中，您可以为**`coworker`**、**`friend`**、**`parent_of`**、**`child_of`**等关系分别定义不同的边类型。如果您只想查找一种关系类型，比如专业网络，这种遍历方式非常高效。然而，需要权衡的是，您需要定义新的边类型来表示新的关系类型，并且代码的抽象性会降低——也就是说，代码复杂性会增加。
- en: Modeling interaction events
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建模交互事件
- en: In many applications, we want to track interactions between entities, such as
    a financial transaction where one financial account transfers funds to another
    account. You might think of representing the transaction (transferring funds)
    as an edge between two **`Account`** vertices. If you have multiple occurrences,
    will you have multiple edges? While it seems easy to conceive of this ([Figure 2-9](#multiple_events_represented_as_multiple)),
    in the realms of both mathematical theory and real-world databases, this is not
    so straightforward.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用程序中，我们希望跟踪实体之间的交互，例如一个财务交易，其中一个财务账户向另一个账户转移资金。您可能会考虑将交易（资金转移）表示为两个**`Account`**顶点之间的边。如果发生多次，会有多个边吗？虽然这看起来很容易构想（[图 2-9](#multiple_events_represented_as_multiple)），但在数学理论和现实世界的数据库领域中，并非如此简单。
- en: '![Multiple events represented as multiple edges](assets/gpam_0209.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![多个事件表示为多条边](assets/gpam_0209.png)'
- en: Figure 2-9\. Multiple events represented as multiple edges
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-9\. 多个事件表示为多条边
- en: In mathematics, having multiple edges between a given pair of vertices goes
    beyond the definition of ordinary graphs into multi-edges and multigraphs. Due
    to this complexity, not all graph databases support this, or if they do, they
    don’t have a convenient way to refer to a specific edge in the group. Another
    way to handle this is to model each interaction event as a vertex and use edges
    to connect the event to the participants ([Figure 2-10](#two_alternate_ways_to_model_multiple_ev)a).
    Modeling an event as a vertex provides the greatest flexibility for linking it
    to other vertices and for designing analytics. A third way is to create a single
    edge between the two entities and aggregate all the transactions into an edge
    property ([Figure 2-10](#two_alternate_ways_to_model_multiple_ev)b).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，对于给定顶点对之间有多条边的情况，超越了普通图的定义，进入了多边和多重图的范畴。由于这种复杂性，并非所有的图数据库都支持这种情况，即使支持，也没有一个方便的方法来引用组中的特定边。另一种处理方法是将每个交互事件建模为一个顶点，并使用边将事件与参与者连接起来（[图 2-10](#two_alternate_ways_to_model_multiple_ev)a）。将事件建模为顶点提供了最大的灵活性，可以将其链接到其他顶点并设计分析。第三种方法是在两个实体之间创建单条边，并将所有交易聚合到边属性中（[图 2-10](#two_alternate_ways_to_model_multiple_ev)b）。
- en: '![Two alternate ways to model multiple events: (a) events as vertices, and
    (b) a single event edge with a property that contains a list of occurrences](assets/gpam_0210.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![多个事件的两种替代建模方法：(a) 事件作为顶点，和 (b) 带有包含事件发生列表的单条事件边](assets/gpam_0210.png)'
- en: 'Figure 2-10\. Two alternate ways to model multiple events: (a) events as vertices,
    and (b) a single event edge with a property that contains a list of occurrences'
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-10\. 多个事件的两种替代建模方法：(a) 事件作为顶点，和 (b) 带有包含事件发生列表的单条事件边
- en: '[Table 2-2](#comparing_options_for_modeling_multiple) summarizes the pros and
    cons of each approach. The simplest model is not always your best choice, because
    application requirements and database performance issues may be more important.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-2](#comparing_options_for_modeling_multiple) 总结了每种方法的利弊。最简单的模型并不总是最佳选择，因为应用要求和数据库性能问题可能更加重要。'
- en: Table 2-2\. Comparing options for modeling multiple occurrences of an interaction
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2\. 比较多次交互建模选项
- en: '| Model | Benefit | Trade-off |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 模型 | 利益 | 权衡 |'
- en: '| --- | --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Multiple edges | Simple model | Database support is not universal |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 多条边 | 简单模型 | 数据库支持并非普遍 |'
- en: '| Vertex linked to related vertices | Filtering on vertex properties Ease of
    analytics including community and similarity of events'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '| 与相关顶点链接的顶点 | 基于顶点属性的过滤 分析社区和事件相似度的易用性'
- en: Advanced search tree integration | Uses more memory Takes more steps to traverse
    |
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 高级搜索树集成 | 使用更多内存 需要更多步骤来遍历 |
- en: '| Single edge with property recording details of occurrences | Less memory
    usage Fewer steps to traverse between users | Searching on transactions is less
    efficient Slower update/insert of the property |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 带有记录事件详细信息的单条边属性 | 使用更少的内存 减少用户之间遍历的步骤 | 交易搜索效率较低 更新/插入属性较慢 |'
- en: Adjusting your design schema based on use case
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据用例调整设计模式
- en: 'Suppose you are creating a graph database to track events in an IT network.
    We’ll assume you would need these vertex types: **`event`**, **`server`**, **`IP`**,
    **`event type`**, **`user`**, and **`device`**. But what relationships would you
    want to analyze, and what edges would you need? The design would depend on what
    you wanted to focus on, and your schema could be event centered or user centered.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在创建一个用于跟踪IT网络事件的图数据库。我们假设您需要以下顶点类型：**`event`**、**`server`**、**`IP`**、**`event
    type`**、**`user`**和**`device`**。但是您想要分析什么关系，需要什么边呢？设计将取决于您希望关注的内容，您的模式可以以事件为中心或以用户为中心。
- en: For the event-centered schema ([Figure 2-11](#two_options_for_arranging_the_same_vert)a),
    the key benefit is that all related data is just one hop away from the **`event`**
    vertex. This makes it straightforward to find communities of events, find servers
    that processed the most events of a given type, and find the servers that were
    visited by any given IP. The trade-off is that from a user perspective, the user
    is two hops away from a **`device`** or **`IP`** vertex.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以事件为中心的模式（[图 2-11](#two_options_for_arranging_the_same_vert)a），其关键优势在于所有相关数据距离**`event`**顶点只有一个跳数。这使得查找事件社区、找到处理特定类型事件最多的服务器以及查找被任何给定IP访问的服务器变得简单。然而，从用户的角度来看，用户距离**`device`**或**`IP`**顶点有两个跳数的权衡。
- en: '![Two options for arranging the same vertex types: (a) event-centered, and
    (b) user-centered](assets/gpam_0211.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![安排相同顶点类型的两种选项：（a）以事件为中心，（b）以用户为中心](assets/gpam_0211.png)'
- en: 'Figure 2-11\. Two options for arranging the same vertex types: (a) event centered
    and (b) user centered'
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-11\. 安排相同顶点类型的两种选项：（a）以事件为中心，（b）以用户为中心
- en: We can fix this by making our schema user centered at the expense of separating
    events from IPs and servers by two hops, and separating event types from devices,
    servers, and IPs by three hops ([Figure 2-11](#two_options_for_arranging_the_same_vert)b).
    However, these disadvantages might be worth the trade-off of being able to do
    useful user-centered analysis such as finding all users who share the same device/IP/server
    as a given user or profiling blocked users to try to predict who else should be
    blocked.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使我们的模式以用户为中心来解决这个问题，但这样会使事件与IP和服务器之间的距离增加到两个跳数，并且事件类型与设备、服务器和IP之间的距离增加到三个跳数（[图 2-11](#two_options_for_arranging_the_same_vert)b）。然而，这些缺点可能值得权衡，因为可以进行有用的以用户为中心的分析，例如查找与给定用户共享相同设备/IP/服务器的所有用户或者对被阻止的用户进行分析，试图预测谁应该被进一步阻止。
- en: Transforming Tables in a Graph
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将表转换为图形
- en: You won’t always create graph databases from scratch. Often, you’ll be taking
    data that is already stored in tables and then moving or copying the data into
    a graph. But how should you reorganize the data into a graph?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您并不总是从头开始创建图数据库。通常，您会获取已经存储在表中的数据，然后将数据移动或复制到图中。但是，您应该如何将数据重新组织成图形呢？
- en: Migrating data from a relational database into a graph database is a matter
    of mapping the tables and columns onto a graph database schema. To map data from
    a relational database to a graph database, we create a one-to-one correspondence
    between columns and graph objects. [Table 2-3](#example_of_mapping_tables_in_a_relation)
    outlines a simple example of mapping data from a relational database to a graph
    database for bank transaction data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据从关系数据库迁移到图数据库是将表和列映射到图数据库架构的过程。为了将数据从关系数据库映射到图数据库，我们在列和图对象之间创建一一对应关系。[表 2-3](#example_of_mapping_tables_in_a_relation)展示了将银行交易数据从关系数据库映射到图数据库的简单示例。
- en: Table 2-3\. Example of mapping tables in a relational database to vertices,
    edges, and properties in a graph database
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-3\. 将关系数据库中的映射表映射到图数据库中的顶点、边和属性的示例
- en: '| Source: Relational database | Destination: Graph database |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 源：关系数据库 | 目标：图数据库 |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Table: `Customers`—multiple columns including `customer_id`, `first_name`,
    `last_name`, `DOB` | Vertex type: **`Customer`**—with corresponding properties
    of `cust⁠omer_id`, `first_name`, `last_name`, `DOB` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 表：`Customers`—包括 `customer_id`, `first_name`, `last_name`, `DOB` 等多列 | 顶点类型：**`Customer`**—对应的属性为
    `cust⁠omer_id`, `first_name`, `last_name`, `DOB` |'
- en: '| Table: `Banks`—columns `bank_id`, `bank_name`, `routing_code`, `address`
    | Vertex type: **`Bank`**—properties `bank_name`, `routing_code`, `address` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 表：`Banks`—列 `bank_id`, `bank_name`, `routing_code`, `address` | 顶点类型：**`Bank`**—属性
    `bank_name`, `routing_code`, `address` |'
- en: '| Table: `Accounts`—columns `bank_id`, `cus⁠tomer_id` | Vertex type: **`Account`**—properties
    `bank_id`, `customer_id` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 表：`Accounts`—列 `bank_id`, `cus⁠tomer_id` | 顶点类型：**`Account`**—属性 `bank_id`,
    `customer_id` |'
- en: '| Table: `Transactions`—columns `source_account`, `destination_account`, `amount`
    | Vertex type: **`Transaction`**—properties `source_account`, `destination_account`,
    `amount` OR'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '| 表：`Transactions`—列`source_account`、`destination_account`、`amount` | 顶点类型：**`Transaction`**—属性`source_account`、`destination_account`、`amount`
    或'
- en: 'Directed edge: **`Transaction`**—properties `source_account`, `destination_account`,
    `amount` |'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有向边：**`Transaction`**—属性`source_account`、`destination_account`、`amount` |
- en: The graph schema would be as shown in [Figure 2-12](#graph_schema_for_a_simple_banking_datab).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图模式如 [图 2-12](#graph_schema_for_a_simple_banking_datab) 所示。
- en: '![Graph schema for a simple banking database with transactions as separate
    vertices](assets/gpam_0212.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的银行数据库的图模式，交易作为单独的顶点](assets/gpam_0212.png)'
- en: Figure 2-12\. Graph schema for a simple banking database with transactions as
    separate vertices
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-12\. 一个简单的银行数据库的图模式，交易作为单独的顶点
- en: One of the key decisions in creating your data schema is deciding which columns
    need to be mapped to their own vertices. For instance, people are generally key
    to understanding any real-life situation—whether they be customers, employees,
    or others—so they would generally map to their own vertices.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数据模式时的一个关键决策是决定哪些列需要映射到它们自己的顶点。例如，人们通常是理解任何现实情况的关键因素——无论他们是客户、员工还是其他人——因此它们通常会映射到它们自己的顶点。
- en: In theory, every column in a relational database could become a vertex in your
    schema, but this is unnecessary and would quickly become unwieldy. In the same
    way that you have to think about structuring a relational database, optimizing
    a graph database is about understanding the real-world structure of your data
    and how you intend to use it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，关系数据库中的每一列都可以成为模式中的一个顶点，但这是不必要的，并且很快变得难以管理。与构建关系数据库结构类似，优化图数据库涉及理解数据的真实结构及其使用意图。
- en: In a graph database, the key columns from your relational database become vertices
    and the contextual or supporting data becomes properties of those vertices. Edges
    generally map to foreign keys and cross-reference tables.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在图数据库中，关系数据库的关键列变成顶点，而上下文或支持数据成为这些顶点的属性。边通常映射到外键和交叉引用表中。
- en: Some graph databases have tools that facilitate the importing of tables and
    mapping of foreign keys to vertex and edge IDs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一些图数据库具有工具，可以便于导入表和将外键映射到顶点和边的 ID。
- en: As with a relational database, a well-structured graph database eliminates redundant
    or repetitive data. This not only ensures efficient use of computing resources
    but, perhaps more importantly, ensures the consistency of your data by ensuring
    that it doesn’t exist in different forms in different locations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与关系数据库一样，结构良好的图数据库消除了冗余或重复的数据。这不仅确保了计算资源的有效使用，而且更重要的是，通过确保数据在不同位置不以不同形式存在，确保了数据的一致性。
- en: Optimizing mapping choices
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化映射选择
- en: Simple mapping of columns to vertices and vertex properties works, but it may
    not take advantage of the richness of connections available in a graph, and in
    reality it is often necessary to adjust mapping choices based on differing search
    use cases.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地将列映射到顶点和顶点属性可能有效，但可能无法充分利用图中可用的连接丰富性，实际上通常需要根据不同的搜索用例调整映射选择。
- en: For instance, in a graph database for a contacts database, mobile number and
    email address are properties of an individual person and are generally represented
    as properties of that vertex.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在联系人数据库的图数据库中，手机号码和电子邮件地址是个人的属性，通常作为该顶点的属性表示。
- en: However, if you were trying to use a banking application to detect fraud, you
    might want to distinguish email addresses and telephone numbers as separate vertices
    because they are useful in linking people and financial transactions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您试图使用银行应用程序来检测欺诈，您可能希望将电子邮件地址和电话号码视为单独的顶点，因为它们对于链接人员和金融交易非常有用。
- en: It is not uncommon for information from multiple tables to map to one vertex
    or edge type. This is especially common when the data is coming from multiple
    sources, each of which provides a different perspective on the same real-world
    entities. Likewise, one table can map to more than one vertex and edge type.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当来自多个表的信息映射到一个顶点或边类型时，这并不少见。当数据来自多个源时，每个源提供了同一现实世界实体的不同视角时，这种情况尤其常见。同样，一个表可以映射到多个顶点和边类型。
- en: Model Evolution
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型演变
- en: 'Most likely, your data is going to evolve over time, and you will need to adjust
    the schema to take account of new business structures and external factors. That’s
    why schemas are designed to be flexible: to allow the system to be adapted over
    time without having to start from scratch.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您的数据会随着时间的推移而发展，您将需要调整模式以考虑新的业务结构和外部因素。这就是为什么模式设计为灵活的：允许系统随时间适应，而无需从头开始。
- en: If we look at the banking sector, for instance, financial institutions are constantly
    moving into new markets, either through geographical expansion or by introducing
    new types of products.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们看看银行业，金融机构不断进入新市场，无论是通过地理扩展还是引入新类型的产品。
- en: As a simple example, let’s assume we have a bank that’s always operated in a
    single country. The country of residence for all its customers is therefore implicit.
    However, moving into a second country would require updating the database to include
    country data. One could either add a country property to every vertex type for
    which it was relevant or create a new vertex type called **`country`** and create
    vertices for each country in which the bank operates.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 举个简单的例子，假设我们有一家一直在单一国家运营的银行。因此，其所有客户的居住国家是隐含的。然而，进入第二个国家将需要更新数据库以包括国家数据。可以为每个相关的顶点类型添加国家属性，或者创建一个名为**`country`**的新顶点类型，并为银行在每个国家的运营地创建顶点。
- en: With a flexible schema, the schema can be updated by adding the new vertex type
    and then linking customer vertices to the new country vertex.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用灵活的模式，可以通过添加新的顶点类型然后将顾客顶点链接到新的国家顶点来更新模式。
- en: Although this is a simple example, it shows how modeling data can be an evolutionary
    process. You can start with an initial model, perhaps one that closely resembles
    a prior relational database model. After you use your graph database for a while,
    you may learn that some model changes would serve your needs better. Two common
    changes are converting a vertex property into an independent vertex type and adding
    additional edge types.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这只是一个简单的例子，但它展示了建模数据可以是一个进化过程。您可以从一个初始模型开始，也许它与之前的关系数据库模型非常相似。在使用图形数据库一段时间后，您可能会发现一些模型更改可以更好地满足您的需求。两个常见的更改是将顶点属性转换为独立的顶点类型，以及添加额外的边类型。
- en: Adapting a graph to evolving data can be simple. Adding a property, a vertex
    type, or an edge type is easy. Connecting two different datasets is easy, as long
    as we know how they relate. We can add edges to connect related entities, and
    we can even merge entities from two sources that represent the same real-world
    entity.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 适应不断变化的数据可以很简单。添加属性、顶点类型或边类型很容易。连接两个不同的数据集也很容易，只要我们知道它们之间的关系。我们可以添加边缘来连接相关实体，甚至可以合并来自代表同一现实世界实体的两个来源的实体。
- en: Graph Power
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图力量
- en: We’ve now seen how to build a graph, but the most important question that needs
    to be answered is *why* build a graph? What are the advantages? What can a graph
    do for you that other data structures don’t do as well? We call graph technology’s
    collected capabilities and advantages *graph power*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何构建图形，但需要回答的最重要的问题是*为什么*构建图形？有什么优势？图形可以为您做到其他数据结构无法做到的事情是什么？我们称之为图形技术的集合能力和优势为*图形力量*。
- en: 'What follows are the key facets of graph power. We humbly admit that this is
    neither the complete nor the best possible list. We suspect that others have presented
    lists that are more complete and more precise in a mathematical sense. Our goal,
    however, is not to present theory but to make a very human connection: to take
    the ideas that resonate with us and to share them with you, so that you will understand
    and experience graph power on your own.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是图力量的关键方面。我们谦逊地承认，这既不是完整的，也不是可能的最佳清单。我们怀疑其他人提出了更完整、数学上更精确的清单。然而，我们的目标不是提出理论，而是建立人类之间的联系：将
    resonance 的想法分享给您，让您能够理解和体验图形力量。
- en: Connecting the Dots
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接点
- en: '*A graph forms an actionable body of knowledge.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图形构成了可操作的知识体系*。'
- en: As we’ve seen, connecting the dots is graph power at its most fundamental level.
    Whether it’s linking actors and directors to movies or financial transactions
    to suspected fraudsters, a graph lets you describe the relationship between one
    entity and another across multiple hops.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，连接点是图形力量在其最基本的层面上。无论是将演员和导演与电影联系起来，还是将金融交易与涉嫌欺诈者联系起来，图形都能让您描述一个实体与另一个实体之间的关系跨越多个跳跃。
- en: The power of graph comes from being able to describe a network of connections,
    detect patterns, and extract intelligence from those patterns. While individual
    vertices may not contain the intelligence we are looking for, taken together,
    they may enable us to discover patterns in the relationships between multiple
    vertices that reveal new information.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图的力量来自于能够描述连接网络、检测模式并从这些模式中提取智能。虽然单个顶点可能不包含我们正在寻找的智能，但它们一起可能使我们能够发现在多个顶点之间关系的模式，从而揭示新信息。
- en: With this knowledge we can begin to infer and predict from the data, like a
    detective joining the dots in a murder investigation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，我们可以开始从数据中推断和预测，就像侦探在调查谋杀案时连接线索一样。
- en: In every detective story, the investigator gathers a set of facts, possibilities,
    hints, and suspicions. But these isolated bits and pieces are not the answer.
    The detective’s magic is to stitch these pieces together into a hidden truth.
    They might use the pattern of known or suspected connections to predict relationships
    they had not been given.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个侦探故事中，调查员收集了一系列事实、可能性、线索和怀疑。但这些孤立的碎片并非答案。侦探的魔力在于将这些碎片缝合成隐藏的真相。他们可能利用已知或可疑的连接模式来预测他们未被告知的关系。
- en: When the detective has solved the mystery, they can show a sequence or network
    of connections that connect the suspect to the crime, along with the means, opportunity,
    and motive. They can likewise show that a sufficiently robust sequence of connections
    does not exist for any other suspect.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当侦探解决了谜团，他们可以展示一系列或网络的连接，将嫌疑人与犯罪联系起来，包括手段、机会和动机。他们也可以表明，对于任何其他嫌疑人，不存在足够强大的连接序列。
- en: Did those detectives know they were doing graph analytics? Probably not, but
    we all do it every day in different aspects of our lives, whether that’s work,
    family, or our network of friends. We are constantly connecting the dots to understand
    connections between people and people, people and things, people and ideas, and
    so on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 那些侦探知道他们在进行图分析吗？可能不知道，但我们每天都在不同方面的工作、家庭或朋友网络中做这种工作。我们不断地连接各种线索，以理解人与人、人与物、人与思想等之间的联系。
- en: The power of graph as a data paradigm is that it closely parallels this process,
    making the use of graph more intuitive.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图作为一种数据范式的力量在于，它密切地模拟了这一过程，使得图的使用更加直观。
- en: The 360 View
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 360度视角
- en: '*A 360 graph view eliminates blind spots.*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*360度图形视图消除了盲点。*'
- en: Organizations of all sizes bemoan their data silos. Each department expects
    the other to yield up its data on demand while at the same time failing to appreciate
    its own inability to be open on the same basis. The problem is that business processes
    and the systems that we have to support them actively work against this open sharing
    of data.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 各种规模的组织都在抱怨它们的数据孤岛。每个部门都希望另一个在需要时提供其数据，同时却未意识到自身无法在同样的基础上开放。问题在于，商业流程及其支持的系统积极阻碍了数据的开放共享。
- en: For instance, two departments may use two different data management systems.
    Although both may store their data in a relational database, the data schema for
    each is so alien to the other that there is little hope of linking the two to
    enable sharing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，两个部门可能使用两种不同的数据管理系统。尽管两者都可能将数据存储在关系型数据库中，但每个系统的数据架构对另一个系统来说却是如此陌生，以至于几乎没有希望将它们链接起来以实现共享。
- en: The problem may not be obvious if you look at it at the micro scale. If, for
    instance, you are compiling a record for customer X, an analyst with knowledge
    of the two systems in which customer data is stored will be able to easily extract
    the data from both, manually merge or reconcile the two records, and present a
    customer report. The problem comes when you want to replicate this a hundred thousand
    or a million times over.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从微观的角度来看待问题，问题可能并不明显。例如，如果你正在为客户X编制记录，那么了解存储客户数据的两个系统的分析师将能够轻松地从两个系统中提取数据，手动合并或协调两条记录，并呈现客户报告。但是，当你需要重复这个过程十万次或百万次时，问题就来了。
- en: And it’s only by sharing the data in a holistic, integrated way that a business
    would be able to remove the blinders that prevent it from seeing the whole picture.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 只有通过全面、整合的方式共享数据，企业才能消除阻碍其全面了解的局限性。
- en: The term *Customer 360* describes a data architecture in which customer data
    from multiple sources and domains is brought together into a single dataset so
    that you have a comprehensive and holistic view of each customer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: “客户 360”这个术语描述了一种数据架构，将来自多个来源和领域的客户数据汇集到一个数据集中，从而使您能够全面和全面地了解每位客户。
- en: 'Working with a relational database, the most obvious solution would be to merge
    these two departmental databases into one. Many businesses have tried grand data
    integration projects, but they usually end in tears because while merging data
    yields considerable benefits, there are also considerable trade-offs to be made
    that result in the loss of contextual nuance and functionality. Let’s face it:
    there’s usually a reason why the creators of a certain software package chose
    to construct their data schema in that particular way, and attempting to force
    it to conform to the schema of another system, or a new hybrid schema, will break
    at least one of the systems.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关系数据库，最明显的解决方案是将这两个部门数据库合并为一个。许多企业尝试过大规模的数据整合项目，但通常以失败告终，因为虽然合并数据带来了显著的好处，但也需要进行权衡，这导致丢失上下文细微差别和功能性。让我们面对现实：通常有一个原因，为什么某个软件包的创建者选择以特定方式构建其数据模式，并试图迫使其符合另一个系统的模式或新的混合模式，将至少破坏其中一个系统。
- en: Graph allows you to connect databases in a natural, intuitive way without disturbing
    the original tables. Start by granting the graph application access to each database
    and then create a graph schema that links the data points from each database in
    a logical way. The graph database maps the relationships between the data points
    and does the analytical heavy lifting, leaving the source databases to carry on
    with what they were doing before.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图形允许您以自然直观的方式连接数据库，而不会干扰原始表。首先授予图形应用程序访问每个数据库的权限，然后创建一个图形模式，以逻辑方式链接每个数据库中的数据点。图形数据库映射数据点之间的关系并进行分析性的重活，使源数据库可以继续完成它们之前的工作。
- en: If you want to see your full surroundings, you need a view that looks out across
    every angle—all 360 degrees. If you want to understand your full business or operational
    circumstances, you need data relationships across all the data you know is out
    there.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到你的全部环境，你需要一个可以俯瞰每个角度的视野——即 360 度。如果你想理解你的整体业务或操作环境，你需要跨越所有你知道的数据之间的数据关系。
- en: This is something we will look at in more depth in [Chapter 3](ch03.html#see_your_customers_and_business_better),
    where we will demonstrate a use case involving Customer Journey.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在[第三章](ch03.html#see_your_customers_and_business_better)更深入地研究的内容，我们将展示一个涉及客户旅程的用例。
- en: We have seen in the previous two points how to set up the data, and now in the
    next four points, we will look at how to extract meaningful intelligence from
    it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两点中，我们已经看到如何设置数据，现在在接下来的四点中，我们将探讨如何从中提取有意义的智能。
- en: Looking Deep for More Insight
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入探索更多洞察力
- en: '*Searching deep in a graph reveals vast amounts of connected information.*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形中深入搜索可以揭示大量连接信息。
- en: The “six degrees of separation” experiment conducted in the 1960s by Stanley
    Milgram demonstrated that just by following personal connections (and knowing
    that the target person is in Boston), randomly selected persons in Omaha, Nebraska,
    could reach the mystery person through no more than six person-to-person connections.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 20 世纪 60 年代，斯坦利·米尔格拉姆进行的“六度分离”实验表明，仅通过追踪个人联系（并知道目标人物在波士顿），在内布拉斯加州奥马哈随机选择的人可以通过不超过六个人际关系连接到神秘的目标人物。
- en: Since then, more rigorous experiments have shown that many graphs are so-called
    small-world graphs, meaning that a source vertex can reach millions and even billions
    of other vertices in a very small number of hops.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 自那时以来，更严格的实验表明，许多图形都是所谓的小世界图形，意味着源顶点可以在非常少的跳数内到达数百万甚至数十亿其他顶点。
- en: This vast reach in only a few hops occurs not only in social graphs but also
    in knowledge graphs. The ability to access this much information, and to understand
    how those facts relate to one another, is surely a superpower.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在社交图形中不仅如此，在知识图形中也能够在很少的跳数内访问如此多的信息。访问这么多信息的能力，并理解这些事实之间的关系，无疑是一种超能力。
- en: 'Suppose you have a graph that has two types of vertices: persons and areas
    of expertise, like the one in [Figure 2-13](#a_graph_showing_who_knows_who_and_what).
    The graph shows *who* you know well and *what* you know well. Each person’s direct
    connections represent what is in their own head.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个图，其中包含两种类型的顶点：人物和专业领域，就像 [图 2-13](#a_graph_showing_who_knows_who_and_what)
    中的那样。该图展示了你认识谁以及你擅长什么。每个人的直接连接代表了他们头脑中的内容。
- en: '![A graph showing who knows whom and their areas of expertise](assets/gpam_0213.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![展示谁认识谁及其专业领域的图表](assets/gpam_0213.png)'
- en: Figure 2-13\. A graph showing who knows whom and their areas of expertise
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-13\. 展示了谁认识谁及其专业领域的图表
- en: From this we can readily see that A is an expert in two topics, astronomy and
    anthropology, but by traversing one additional hop to ask B and C what they know,
    A has access to four more specialties.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们很容易看出 A 是两个专家，天文学和人类学，但通过询问 B 和 C 知道什么，再走一步，A 就可以接触到四个更多的专业。
- en: Now, suppose each person has 10 areas of expertise and 100 personal connections.
    Consider how many people and how many areas of expertise are reached by your friends’
    friends. There are 100 × 100 = 10,000 personal connections, each with 10 areas
    of expertise. Chances are the number of unique persons is not 10,000—you and your
    friends know some of the same people. Nevertheless, with each hop in a graph,
    you are exposed to an exponentially larger quantity of information. Looking for
    the answer to a question? Want to do analytics? Want to understand the big picture?
    Ask around, and you’ll find someone who knows someone who knows.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设每个人都有 10 个专业领域和 100 个人际关系。考虑一下你的朋友的朋友能联系到多少人和多少专业领域。有 100 × 100 = 10,000
    个人际关系，每个关系涉及 10 个专业领域。有可能独特的人数并不是 10,000 —— 你和你的朋友可能认识一些相同的人。尽管如此，在图中的每一步中，你都会接触到指数级增长的信息量。寻找答案？想进行分析？想要理解全局？四处打听一下，你会找到认识认识的人。
- en: We talk about “looking deeper” all the time, but in graph it means something
    particular. It is a structured way of searching for information and understanding
    how those facts are related. Looking deeper includes breadth-based search to consider
    what is accessible to you from your current position. It then traverses to some
    of those neighboring vertices to gain depth and see what is accessible from those
    new positions. Whether it’s for a fraud investigation or to optimize decision
    making, looking deeper within a graph uncovers facts and connections that would
    otherwise be unknown.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常谈论“更深入地看”，但在图表中，这意味着一种特定的方式来搜索信息，并理解这些事实如何相关。更深入地看包括基于广度的搜索，考虑从当前位置可访问的内容。然后遍历到一些邻近顶点以获取深度，并查看从这些新位置可访问的内容。无论是进行欺诈调查还是优化决策，深入图表中查找可以揭示出否则未知的事实和关联。
- en: As we saw in [“Connecting the Dots”](#connecting_the_dots), one relationship
    on its own may be unremarkable, and there may be little if any information in
    a given vertex to reveal bad intentions, but thousands or even millions of vertices
    and edges considered in aggregate can begin to reveal new insights, which in turn
    leads to actionable intelligence.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [“连接点”](#connecting_the_dots) 中所看到的，单独一个关系可能并不引人注目，并且可能没有任何信息显示一个给定顶点中的坏意图，但是成千上万的顶点和边被综合考虑时，可以开始揭示新的见解，进而导致可操作的智能。
- en: Seeing and Finding Patterns
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察和发现模式
- en: '*Graphs present a new perspective, revealing hidden data patterns that are
    easy to interpret.*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*图表现出一个新的视角，揭示了易于解释的隐藏数据模式。*'
- en: As we have seen, a graph is a set of vertices and edges, but within the set
    of vertices and relationships, we can begin to detect patterns.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，图是一组顶点和边，但在顶点和关系的集合内部，我们可以开始检测到模式。
- en: A *graph pattern* is a small, connected set of vertices and edges that can be
    used as a template for searching for groups of vertices and edges that have a
    similar configuration.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*图模式*是一小组连接的顶点和边，可以作为搜索具有类似配置的顶点和边组的模板。
- en: 'The most basic graph pattern is the data triplet: vertex → edge → vertex. The
    data triplet is sometimes thought of as a semantic relationship because it is
    related to the grammar of language and can be read as “subject → verb → object.”
    An example is Bob → owns → boat.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的图模式是数据三元组：顶点 → 边 → 顶点。数据三元组有时被认为是语义关系，因为它与语言的语法相关，并可以读作“主语 → 谓语 → 宾语”。例如，Bob
    → 拥有 → 船。
- en: 'We can also use graph patterns to describe higher-level objects or relationships
    that we have in mind. For instance, depending on the schema, a person could be
    linked to a number of vertices containing personal data such as address, telephone,
    and email. Although they are separate vertices, they are all related to that one
    person. Another example is a wash sale, which is the combination of two securities
    trades: selling a security at a loss, and then purchasing the same or a substantially
    similar security within 30 days.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用图形模式描述我们心中的高级对象或关系。例如，根据模式，一个人可以与包含地址、电话和电子邮件等个人数据的多个顶点相关联。虽然它们是单独的顶点，但它们都与那个人相关。另一个例子是洗售，这是两个证券交易的组合：以亏损出售证券，然后在30天内购买相同或基本相似的证券。
- en: 'Patterns come in different shapes. The simplest pattern, which we have looked
    at already, is the linear relationship between two vertices across a series of
    hops. The other common pattern is the star shape: many edges and vertices radiating
    from a central vertex.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图案有不同的形状。我们已经看过的最简单的图案是两个顶点之间的线性关系跨越一系列跳跃。另一个常见的模式是星形：许多边和顶点从一个中心顶点辐射出去。
- en: A pattern can be Y-shaped, a pattern you would see when two vertices come together
    on a third vertex, which is then related to a fourth vertex. We can also have
    circular or recursive patterns and many more.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图案可以是Y形的，当两个顶点汇合在第三个顶点上时，就会出现这种模式，这个第三个顶点与第四个顶点相关。我们还可以有圆形或递归模式等等。
- en: In contrast to relational databases, graph data is easy to visualize, and graph
    data patterns are easy to interpret.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与关系数据库相比，图形数据易于可视化，图形数据模式易于解释。
- en: A well-designed graph gives names to the vertex and edge types that reflect
    their meaning. When done right, you can almost look at a connected sequence of
    vertices and edges and read the names like a sentence. For example, consider [Figure 2-14](#people_who_bought_product_a_also_bought),
    which shows Items purchased by Persons.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的图形为顶点和边类型命名，反映它们的含义。如果正确完成，您几乎可以查看一系列连接的顶点和边，并像读句子一样阅读这些名称。例如，请参考[图 2-14](#people_who_bought_product_a_also_bought)，显示了购买人员的物品。
- en: '![Persons who bought Item 1 and other products they bought](assets/gpam_0214.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![购买物品1及其他商品的人](assets/gpam_0214.png)'
- en: Figure 2-14\. Persons who bought Item 1 and other products they bought
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-14\. 购买物品1及其它商品的人
- en: Starting from the left, we see that Person A (you) bought Item 1\. Moving to
    the right, we then see another group of persons, B, C, and D, who also bought
    Item 1\. Finally, we see some more items that were purchased by these persons.
    So we can say, “You bought Item 1\. Other persons who bought Item 1 also bought
    Items 2, 3, 4, and 5.” Sound familiar?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从左边开始，我们看到A（您）购买了物品1。向右移动，我们看到另一组人，B、C和D，他们也购买了物品1。最后，我们看到这些人购买了更多物品。因此，我们可以说：“您购买了物品1。其他购买物品1的人也购买了物品2、3、4和5。”听起来熟悉吗？
- en: A closer analysis reveals that Item 4 was the most popular item, purchased by
    all three shoppers in your co-purchaser group. Item 3 was next most popular (purchased
    by two), and Items 2 and 5 were the least popular. With this information, we can
    refine our recommendations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步分析表明，物品4是最受欢迎的物品，三位购买者中的所有人都购买了该物品。物品3紧随其后（被两人购买），物品2和5最不受欢迎。有了这些信息，我们可以优化我们的推荐。
- en: Many retailers use graph analytics for their recommendation analytics, and they
    often go deeper yet, classifying purchases by other customer properties such as
    gender, age, location, and time of year. We could even make recommendations based
    on time of day if we saw that customers were, for instance, more likely to purchase
    luxury items in the evening and make more pragmatic purchases in the morning.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 许多零售商使用图形分析进行推荐分析，通常还会更深入，根据其他客户属性（如性别、年龄、地点和时间）对购买进行分类。如果我们发现客户晚上更有可能购买奢侈品，早上更倾向于购买实用品，我们甚至可以根据每天的时间来做出推荐。
- en: If we also analyze the sequence of purchases, we can work out some highly personal
    information about customers. One large retailer was famously able to tell which
    customers were pregnant and when they were due simply by focusing on the purchases
    of 25 products. The retailer was then able to send the customer targeted promotional
    offers to coincide with the birth of their child.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还分析购买顺序，我们可以得出关于客户的一些高度个人化的信息。一家大型零售商曾经通过关注25种产品的购买情况来准确判断哪些客户怀孕及预产期。然后，该零售商能够在客户孩子出生时发送定向的促销优惠。
- en: Matching and Merging
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配和合并
- en: '*Graph is the most intuitive and efficient data structure for matching and
    merging records.*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*图形是最直观和高效的匹配和合并记录的数据结构。*'
- en: As we discussed earlier, organizations want to have a 360-degree view of their
    data, but a big obstacle to this is data ambiguity. An example of data ambiguity
    is having multiple versions of customer data, and the challenges of deduplicating
    data are well known to many organizations.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，组织希望全方位了解他们的数据，但这背后的一个大障碍是数据的不明确性。数据不明确性的一个例子是有多个版本的客户数据，去重数据的挑战对许多组织而言是众所周知的。
- en: Duplication is sometimes caused by the proliferation of enterprise systems,
    which split your customer view across many databases. For instance, if you have
    customer records in a number of databases—such as Salesforce, which is a customer
    service database, an order-processing system, and an accounting package—the view
    of that customer is divided across those systems.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 重复有时是企业系统的繁殖导致的，这些系统将您的客户视图分散到许多数据库中。例如，如果您在几个数据库中拥有客户记录——例如Salesforce（客户服务数据库）、订单处理系统和会计软件包——客户的视图将分散在这些系统中。
- en: To create a joined-up view of your customers, you need to query each database
    and join together the records for each customer.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建客户的联合视图，您需要查询每个数据库并将每个客户的记录连接在一起。
- en: However, it’s not always that easy because customers can end up being registered
    in your databases under different reference IDs. Names can be spelled differently.
    Personal information (name, phone number, email address, etc.) can change. How
    do you match together the correct records?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并不总是那么简单，因为客户可能在您的数据库中使用不同的参考ID进行注册。姓名可能拼写不同。个人信息（姓名、电话号码、电子邮件地址等）可能会更改。如何匹配正确的记录呢？
- en: Entity resolution matches records based on properties that are assumed to be
    unique to the entities that are being represented. In the case of person records,
    these might be email addresses and telephone numbers, but they could also be aggregates
    of properties. For instance, we can take name, date of birth, and place of birth
    together as a unique identifier because what are the chances of those three things
    being the same for any two people in the world?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 实体解析根据被假定为唯一的实体属性来匹配记录。在个人记录的情况下，这些属性可能是电子邮件地址和电话号码，但也可以是属性的聚合。例如，我们可以将姓名、出生日期和出生地作为唯一标识符，因为全世界任何两个人拥有相同这三样东西的几率有多大呢？
- en: Entity resolution is challenging across relational databases because in order
    to compare entities, you need to be comparing like with like. If you are working
    with a single table, you can say that similar values in similar columns indicate
    a match, allowing you to resolve two entities into one, but across multiple tables,
    the columns may not match. You may also have to construct elaborate table joins
    to include cross-referenced data in the analysis.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中进行实体解析是具有挑战性的，因为为了比较实体，您需要比较相似的内容。如果您只处理一个表，您可以说相似的列中的相似值表示匹配，从而将两个实体解析为一个实体，但在多个表中，列可能不匹配。您可能还需要构建复杂的表连接以在分析中包含交叉参考的数据。
- en: By comparison, entity resolution in a graph is easy. Similar entities share
    similar neighborhoods, which allows us to resolve them using similarity algorithms
    such as cosine similarity and Jaccard similarity.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在图中进行实体解析则较为容易。相似的实体共享相似的邻域，这使得我们能够使用诸如余弦相似度和Jaccard相似度等相似性算法来解析它们。
- en: 'In entity resolution, we actually do two things:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在实体解析中，我们实际上做了两件事：
- en: Compute match likelihood scores for pairs of entities by measuring the degree
    of similarity of their properties and neighborhoods.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过测量其属性和邻域的相似度来计算实体对的匹配可能性分数。
- en: Merge the entities that have high enough match likelihood scores.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并具有足够高匹配可能性分数的实体。
- en: 'When it comes to merging records, we have a few options:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到合并记录时，我们有几个选项：
- en: Copy the data from record B to record A, redirect the edges that pointed to
    B so they point to A, and delete B.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将记录 B 的数据复制到记录 A，重定向原本指向 B 的边使其指向 A，并删除 B。
- en: Create a special link called `same_as` between records A and B.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在记录 A 和 B 之间创建一个名为 `same_as` 的特殊链接。
- en: Create a new record called C, copy the data from A and B, redirect the links
    from A and B so they link to C, and finally create `same_as` edges pointing from
    vertex C to vertices A and B.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 C 的新记录，将数据从 A 和 B 复制过来，重定向从 A 和 B 指向 C 的链接，最后创建 `same_as` 边从顶点 C 指向顶点
    A 和 B。
- en: Which is better? The second is quicker to execute because there is only one
    step involved—adding an edge—but a graph query can execute the first and third
    options just as well. In terms of outcomes, which option is better depends on
    your search use case. For instance, do you prioritize richness of data or search
    efficiency? It might also depend on the degree of matching and merging you expect
    to do in your database.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个更好？第二种更快执行，因为只涉及一步操作——添加一条边——但图查询同样可以执行第一种和第三种选项。就结果而言，哪种选项更好取决于您的搜索用例。例如，您是更看重数据的丰富性还是搜索效率？它还可能取决于您在数据库中期望进行的匹配和合并程度。
- en: We will demonstrate and discuss entity resolution with a walkthrough example
    in  [Chapter 11](ch11.html#entity_resolution_revisited).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 11 章](ch11.html#entity_resolution_revisited) 中通过一个实例演示和讨论实体解析。
- en: Weighing and Predicting
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加权和预测
- en: '*Graphs with weighted relationships let us easily model and analyze complex
    cost structures.*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*具有加权关系的图让我们能够轻松地建模和分析复杂的成本结构。*'
- en: As we’ve shown, graphs are a powerful tool for analyzing relationships, but
    one thing to consider is that relationships don’t have to be binary, on or off,
    black or white. Edges, representing the relationships between vertices, can be
    weighted to indicate the strength of the relationship, such as distance, cost,
    or probability.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所展示的，图是分析关系的强大工具，但需要考虑的一点是关系不一定是二进制的、开或关、黑或白。边代表顶点之间的关系，可以加权表示关系的强度，例如距离、成本或概率。
- en: If we weight the edges, path analysis then becomes a matter of not just tracing
    the links between nodes but also doing computational work such as aggregating
    their values.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对边进行加权，路径分析就不仅仅是追踪节点之间的链接，还需要进行计算工作，例如聚合它们的值。
- en: However, weighted edges make graph analysis more complex in other ways, too.
    In addition to the computational work, finding shortest paths in a graph with
    weighted edges is algorithmically harder than in an unweighted graph. Even after
    you’ve found one weighted path to a vertex, you cannot be certain that it is the
    shortest path. There might be a longer path you haven’t tried yet that has lower
    total weight.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，加权边也使得图分析变得更加复杂。除了计算工作之外，在具有加权边的图中找到最短路径算法上也比在无权图中更为困难。即使你已经找到了一条到达某个顶点的加权路径，你也无法确定它是否是最短路径。可能存在另一条你尚未尝试的更长路径，但其总权重较低。
- en: Then again, edge weighting does not always make for a significant increase in
    work. In the PageRank algorithm, which computes the influence of each vertex on
    all other vertices, edge weighting makes little difference except that the influence
    that a vertex receives from a referring neighbor is multiplied by the edge weight,
    which adds a minimal computational overhead to the algorithm.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，边的加权并不总是会导致工作量显著增加。在 PageRank 算法中，该算法计算每个顶点对所有其他顶点的影响时，边的加权几乎没有影响，只是从引用邻居接收的影响被边的权重乘以，这对算法增加了最小的计算开销。
- en: There are many problems that can be solved with edge weighting. Anything to
    do with maps, for instance, lends itself to edge weighting. You can have multiple
    weights per edge. Considering the map example, these could include constant weights
    such as distance and speed limits and variable weights such as current travel
    times to take account of traffic conditions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多问题可以通过边的加权来解决。例如，与地图相关的任何事物都适合边的加权。每条边可以有多个权重。考虑地图示例，这些权重可以包括常数权重，如距离和速度限制，以及变量权重，如当前旅行时间，以考虑交通状况。
- en: We could use a graph of airline routes and prices to work out the optimal journey
    for a passenger based not only on their itinerary but also their budget constraints.
    Are they looking for the fastest journey regardless of price, or are they willing
    to accept a longer journey, perhaps with more stops, in exchange for a lower price?
    In both cases, you might use the same algorithm—shortest path—but prioritize different
    edge weights.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用航线和价格的图表来计算乘客的最佳行程，不仅基于他们的行程安排，还考虑他们的预算限制。他们是要找最快的行程，不管价格，还是愿意接受更长的行程，可能有更多停留，以换取更低的价格？在这两种情况下，你可能会使用相同的算法——最短路径——但会优先考虑不同的边权重。
- en: With access to the right data, we could even work out the probability of having
    a successful journey. For instance, what is the probability of our flight departing
    and arriving on time? For a single hop, we might accept an 80% chance that the
    flight wouldn’t be more than an hour late, but for a two-hop trip, where the chance
    for the second hop not being late was 85%, the combined risk of being delayed
    would be 68%.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有了正确的数据访问权限，我们甚至可以计算成功旅程的概率。例如，我们的航班准时起飞和到达的概率是多少？对于单程跳跃，我们可能接受航班晚点不超过一个小时的80%的机会，但对于两程跳跃，第二程不晚点的概率为85%，延误的组合风险为68%。
- en: Likewise, we could look at a supply chain model and ask, what are the chances
    of a severe delay in the production of our finished product? If we assume that
    there are six steps and the reliability of each step is 99%, then the combined
    reliability is about 94%. In other words, there is a 6% chance that something
    will go wrong. We can model that across hundreds of interconnecting processes
    and use a shortest path algorithm to find the “safest” route that satisfies a
    range of conditions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以看一下供应链模型，并问一下，我们完成产品的生产会不会严重延误？如果我们假设有六个步骤，每个步骤的可靠性为99%，那么组合可靠性约为94%。换句话说，有6%的机会出现问题。我们可以对数百个互连过程建模，并使用最短路径算法找到满足一系列条件的“最安全”路线。
- en: Chapter Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: In this chapter, we have looked at graph structure and how we can use a graph
    database to represent data as a series of data nodes and links. In graphs, we
    call these vertices and edges, and they enable us to not only represent data in
    an intuitive way—and query it more efficiently—but also use powerful graph functions
    and algorithms to traverse the data and extract meaningful intelligence.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了图结构以及如何使用图数据库将数据表示为一系列数据节点和链接。在图中，我们称这些为顶点和边，它们不仅能够以直观的方式表示数据——并更有效地查询数据——还可以使用强大的图函数和算法遍历数据并提取有意义的智能信息。
- en: Property graphs are graphs in which every vertex and edge—which we collectively
    refer to as objects—can hold properties that describe that object. One property
    of an edge is direction, and we discussed the benefits and trade-offs of different
    directed edge types in indicating hierarchy and sequence.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 属性图是一种图形，其中每个顶点和边（我们统称为对象）都可以持有描述该对象的属性。边的一个属性是方向，我们讨论了在指示层次结构和顺序时不同有向边类型的优缺点。
- en: 'We looked at what is meant by traversing a graph as well as “hops” and “distance.”
    There are two approaches to traversing a graph: breadth-first search and depth-first
    search, each with its own benefits and trade-offs.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了什么是遍历图以及“跳跃”和“距离”的含义。遍历图有两种方法：广度优先搜索和深度优先搜索，每种方法都有其自身的优点和权衡。
- en: We looked at the importance of using a graph schema to define the structure
    of the database, how a consistent set of object types makes your data easier to
    interpret, and how it can closely relate to the real world.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了使用图模式定义数据库结构的重要性，一致的对象类型集使您的数据更易于解释，并且它能够与现实世界紧密相关。
- en: Careful consideration was given to different approaches to the design, in particular
    the search use case and how mapping the columns of a relational database to a
    graph database can impact query time and the complexity of your coding.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计过程中，特别是在搜索用例和将关系数据库的列映射到图数据库时，仔细考虑了不同的方法，这会影响查询时间和编码的复杂性。
- en: A key step in implementing a graph database is mapping columns in a relational
    database to a graph, because a common use case for graph is building relationships
    between disparate databases. One of the decisions you have to make is which columns
    to map to their own objects and which to include as properties of other objects.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 实施图数据库的关键步骤之一是将关系数据库中的列映射到图中，因为图的一个常见用例是在不同数据库之间建立关系。您需要做出的决策之一是将哪些列映射到它们自己的对象，以及哪些包含为其他对象的属性。
- en: We looked at the evolution of databases over time and why a flexible schema
    is essential to ensuring your database remains up to date.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们审视了数据库的演变，以及为什么灵活的模式对确保数据库保持最新状态至关重要。
- en: In the design of a database schema, whether that be for a relational or graph
    database, there are benefits and trade-offs to be made, and we looked at a few
    of those, including the choice of whether to map a column to an object or make
    it the property of an object. We also considered the choice of edge directionality
    and the granularity of edge types.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计数据库模式时，无论是关系型数据库还是图数据库，都需要权衡利弊，我们探讨了其中一些，包括是否将列映射为对象或将其作为对象的属性的选择。我们还考虑了边的方向性选择和边类型的粒度。
- en: There are also trade-offs to be made in recording multiple events between the
    same two entities and tracking events in an IT network.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 记录同一两个实体之间的多个事件和跟踪IT网络中的事件也需要权衡取舍。
- en: 'Finally, we looked at what we mean by graph power, including the essential
    question, why use graph in the first place? We looked at some general use cases,
    including:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了“图力量”的含义，包括首先为什么使用图？我们看了一些常见的用例，包括：
- en: 'Connecting the Dots: how a graph forms an actionable body of knowledge'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接各种知识点：图如何形成可操作的知识体系
- en: 'The 360 View: how a 360 graph view eliminates blind spots'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 360度视角：如何通过360度图视图消除盲点
- en: 'Looking Deep for More Insight: how deep graph search reveals vast amounts of
    connected information'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入寻找更多见解：深度图搜索如何揭示大量连接信息
- en: 'Seeing and Finding Patterns: how graphs present a new perspective, revealing
    hidden data patterns that are easy to interpret'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察和发现模式：图如何呈现新的视角，揭示易于解释的隐藏数据模式
- en: 'Matching and Merging: why graph is the most intuitive and efficient data structure
    for matching and merging records'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配和合并：为什么图是匹配和合并记录的最直观和高效的数据结构
- en: 'Weighing and Predicting: how graphs with weighted relationships let us easily
    model and analyze complex cost structures'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权衡和预测：带有加权关系的图如何轻松建模和分析复杂的成本结构
- en: ^([1](ch02.html#ch01fn3-marker)) Some graph databases would handle multiple
    roles by having a single `Worked_on` edge whose role property accepts a list of
    roles.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#ch01fn3-marker)) 一些图数据库通过一个名为`Worked_on`的单一边来处理多个角色，其角色属性接受角色列表。
