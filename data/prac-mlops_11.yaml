- en: Chapter 11\. Building MLOps Command Line Tools and Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 构建MLOps命令行工具和微服务
- en: By Alfredo Deza
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Alfredo Deza
- en: The Japanese bombed Pearl Harbor on December 7, 1941 and it at once became impossible
    to buy tires, clearly needed for the long trip to California. My father scoured
    the country for old tires for the Ford and for the small house trailer that we
    had used for several shorter family trips. We left Cincinnati in February 1942
    with 22 tires strapped to the roofs of the trailer and the car and before we got
    to California we used them all.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1941年12月7日，日本轰炸了珍珠港，立即导致购买轮胎变得不可能，显然需要长途驾驶去加利福尼亚州。我父亲在全国四处寻找旧轮胎给福特车和我们小型房车使用，我们曾多次用它进行短途家庭旅行。1942年2月，我们离开辛辛那提，车顶和房车顶上绑着22个轮胎，在抵达加利福尼亚之前，我们都用光了这些轮胎。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dr. Joseph Bogen
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Joseph Bogen博士
- en: 'Building command line tools is how I got started with Python years ago, and
    I believe it is a perfect intersection between software development and machine
    learning. I remember all those years ago when I struggled to learn new Python
    concepts that felt very foreign to me as a Systems Administrator: functions, classes,
    logging, and testing. As a Systems Administrator, I was mostly exposed to shell
    scripting with Bash writing top-to-bottom instructions to get something done.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，我开始使用Python时是通过构建命令行工具，我认为这是软件开发和机器学习的完美交集。我记得多年前，我作为系统管理员努力学习新的Python概念时感到非常陌生：函数、类、日志记录和测试。作为系统管理员，我主要接触到使用Bash编写从上到下的指令来完成任务。
- en: 'There are several difficulties with trying to tackle problems with shell scripting.
    Handling errors with straightforward reporting, logging, and debugging are all
    features that don’t take much effort in other languages like Python. Several other
    languages offer similar features like Go and Rust and should hint why using something
    other than a command language like Bash is a good idea. I tend to recommend using
    a shell scripting language when a few lines can get the task done. For example,
    this shell function copies my public SSH key into a remote machine into the authorized
    keys, allowing my account to access that remote server without requiring a password:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用shell脚本尝试解决问题存在几个困难。处理错误并进行直接报告、记录和调试，这些特性在像Python这样的其他语言中并不需要花费太多精力。其他几种语言如Go和Rust也提供了类似的功能，这就暗示了为什么使用非命令语言如Bash是个好主意。我倾向于推荐在几行代码就能完成任务时使用shell脚本语言。例如，这个shell函数会将我的公共SSH密钥复制到远程机器的授权密钥中，从而允许我的账号无需密码即可访问该远程服务器：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The sample Bash function will probably not work well in your enviroment. If
    you want to try it out, the paths and configuration files will have to match.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例Bash函数可能在你的环境中表现不佳。如果你想尝试，路径和配置文件需要匹配。
- en: Doing the same with a language like Python wouldn’t make much sense because
    it would take many more lines of code and probably a few extra dependencies installed.
    This function is simple, only does one thing, and is very portable. My recommendation
    is to look beyond a shell scripting language when the solution is more than a
    dozen lines or so.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python等语言做同样的事情可能没有多大意义，因为它可能需要更多的代码行和可能还要安装一些额外的依赖。这个函数很简单，只做一件事，而且非常易于移植。我建议，当解决方案超过十几行时，不要仅限于使用shell脚本语言。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you find yourself creating small snippets of shell commands often, it is
    good to create a repository to collect them. [The repository](https://oreil.ly/NQTfW)
    for my aliases, functions, and configurations should show you a good way to start
    if you need a reference.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常创建小的shell命令片段，建议创建一个存储库来收集它们。[这个存储库](https://oreil.ly/NQTfW)的别名、函数和配置应该能为你提供一个很好的参考起点。
- en: The way I learned Python was by automating tedious, repetitive tasks with command
    line tools, from creating client websites using templates to adding and removing
    users from the corporate servers. My recommendation to get engaged in learning
    is to find an interesting problem with a direct benefit for yourself. This way
    of learning is entirely different from how we were taught in school, and it doesn’t
    necessarily apply to any situation, but it is a good fit for this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我学习Python的方法是通过使用命令行工具自动化繁琐重复的任务，从创建客户网站使用模板到在公司服务器上添加和删除用户。我建议你投入学习的方法是找到一个有直接利益的有趣问题。这种学习方式与我们在学校学习的方式完全不同，它并不一定适用于任何情况，但非常适合本章内容。
- en: Depending on how you create command line tools, they can be straightforward
    to install. As the example of a shell command that should work in any Unix environment
    with ease, there is a similarity with containers and microservices. Because the
    container bundles the dependencies together, it will work in any system with a
    proper runtime enabled. We’ve already gone through some of the components of microservices
    in [“Containers”](ch03.xhtml#Section-containers), describing some critical differences
    from monolithic applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您创建命令行工具的方式，它们可以很容易地安装。例如，一个应该在任何Unix环境中轻松运行的shell命令的示例，它与容器和微服务具有相似性。因为容器将依赖项捆绑在一起，所以在启用适当运行时的任何系统中都可以正常工作。我们已经介绍了一些“容器”中的微服务组件，描述了与单片应用程序的一些关键区别。
- en: But there is more to microservices than containers, and almost all cloud providers
    offer a *serverless* solution. Serverless allows a developer to concentrate on
    writing small applications without worrying about the underlying operating system,
    its dependencies, or the runtime. Although the offering may appear overly simplistic,
    you can leverage the solution to create whole HTTP APIs or a pipeline-like workflow.
    You can tie all of these components and technologies back to the command line
    and some ML features from cloud providers. The mix-and-match aspect of these technologies
    means that an engineer can craft creative solutions to tricky problems with very
    little code. Whenever you can automate tasks and enhance productivity, you are
    applying solid operational skills to help you get models into production robustly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是微服务不仅限于容器，几乎所有云提供商都提供了*无服务器*解决方案。无服务器允许开发者专注于编写小型应用程序，而不必担心底层操作系统、其依赖项或运行时。尽管这种提供可能显得过于简单，但你可以利用这个解决方案来创建完整的HTTP
    API或类似管道的工作流。你可以将所有这些组件和技术与命令行以及云提供商的某些ML特性联系起来。这些技术的混合搭配意味着工程师可以用很少的代码为棘手的问题创造出创新的解决方案。每当你能自动化任务并增强生产力时，你都在应用扎实的运营技能来帮助你稳健地将模型投入到生产中。
- en: Python Packaging
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python打包
- en: Many useful Python command line tools start as a single script file, and then
    they tend to grow to more complex scenarios with other files and perhaps dependencies.
    It isn’t until the script needs extra libraries that it is no longer feasible
    to keep the script without packaging. Python packaging is not very good. It pains
    me to say that after well over a decade of Python experience, but packaging is
    still an aspect of the language ecosystem full of tricky (unresolved) problems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 许多有用的Python命令行工具最初都是一个单独的脚本文件，然后随着时间推移，它们往往会发展成更复杂的场景，涉及其他文件和可能的依赖项。直到脚本需要额外的库才不再将脚本保持不打包成为不可行的情况。Python的打包并不是很好。这让我痛苦地说，经过十多年的Python经验之后，但是打包仍然是语言生态系统中充满棘手（未解决）问题的一个方面。
- en: If you are tinkering and trying out some automation *with no external dependencies*,
    then a single Python script is fine without packaging. If, on the other hand,
    your script requires some other dependencies and perhaps consists of more than
    one file, then you undoubtedly should consider packaging. Another useful feature
    of a properly packaged Python application is that it can be published to [the
    Python Package Index](https://pypi.org) so that others can install it with tools
    like *pip* (the Package Installer for Python).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在尝试一些自动化且*没有外部依赖*的操作，那么一个单独的Python脚本就可以了，无需打包。然而，如果你的脚本需要其他依赖项并且可能由多个文件组成，那么无疑应该考虑打包。一个正确打包的Python应用程序的另一个有用特性是它可以发布到[Python软件包索引](https://pypi.org)，这样其他人就可以使用像*pip*（Python的软件包安装器）这样的工具安装它。
- en: 'A few years ago, it was problematic to install Python packages on a system:
    it was impossible to remove them. This sounds unbelievable these days, but it
    was one of the many reasons why “virtual environments” took off. With virtual
    environments, fixing dependencies was as easy as removing a directory—while keeping
    the system packages intact. These days, uninstalling Python packages is easier
    (and possible!), but dependency resolution is still lacking robustness. Virtual
    environments are then the suggested way to work on Python projects, so environments
    are fully isolated, and you can resolve dependency problems by creating a new
    environment.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，在系统上安装 Python 包是一个问题：它们是无法移除的。这在今天听起来难以置信，但这是“虚拟环境”火起来的许多原因之一。有了虚拟环境，修复依赖关系就像删除一个目录一样容易——同时保持系统包的完整性。如今，卸载
    Python 包更加容易（并且可能！），但依赖关系解决仍然缺乏鲁棒性。因此，虚拟环境被建议作为工作在 Python 项目上的方式，因此环境是完全隔离的，你可以通过创建一个新环境来解决依赖问题。
- en: 'It shouldn’t be surprising to see recommendations throughout this book (and
    elsewhere in the Python ecosystem) to use the *virtualenv* module. Since Python
    3, the common way to create and activate a virtual environment is with the *Python*
    executable directly:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书（以及 Python 生态系统的其他地方）推荐使用*virtualenv*模块，这并不奇怪。自从 Python 3 开始，创建和激活虚拟环境的常用方法是直接使用*Python*可执行文件：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To verify that the virtual environment is activated, the Python executable
    should now be different from that of the system Python:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证虚拟环境是否已激活，Python 可执行文件现在应与系统 Python 不同：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I recommend using proper Python packaging techniques so that you are well prepared
    when it is needed. As soon as your command line tool needs a dependency, it will
    be ready to be declared as a requirement. Your tool’s consumers will resolve these
    dependencies as well, making it easier for others to work with your creation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用适当的 Python 打包技术，这样当需要时你就做好了充分的准备。一旦你的命令行工具需要一个依赖，它就已经准备好被声明为一个要求。你的工具的使用者也将解决这些依赖关系，使得其他人更容易使用你的创作。
- en: The Requirements File
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Requirements 文件
- en: 'As you will see in the next sections of this chapter, there are two popular
    ways of defining dependencies. One of them is using a *requirements.txt* file.
    Installer tools can use this file like *pip* to get dependencies installed from
    a package index. In this file, the dependencies are declared on a separate line,
    and optionally, with some versions constraint. In this example, the Click framework
    doesn’t have a constraint, and therefore the installer (`pip`) will use the latest
    version. The Pytest framework is *pinned* to a specific version, so `pip` will
    always try to find that specific version at install time:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在本章后面的部分看到的，定义依赖关系的两种流行方式之一是使用*requirements.txt*文件。安装程序工具可以使用这个文件像*pip*一样从包索引安装依赖项。在这个文件中，依赖关系在单独的行上声明，并且可选地带有一些版本约束。在这个例子中，Click
    框架没有约束，因此安装程序（`pip`）将使用最新版本。Pytest 框架被*固定*到一个特定版本，所以`pip`将始终尝试在安装时找到该特定版本：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To install dependencies from a *requirements.txt* file, you need to use `pip`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要从*requirements.txt*文件安装依赖项，你需要使用`pip`：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although there is no strict naming rule, you can commonly find dependencies
    in a plain-text file named *requirements.txt*. Project maintainers can define
    multiple text files with requirements as well. That is more common when development
    dependencies are different than when shipping to production, for example. As you
    will see in the next section, there is also a *setup.py* file that can install
    dependencies. This is a rather unfortunate side-effect of the state of packaging
    and dependency management in Python. Both files can achieve the goal of installing
    dependencies for a Python project, but only *setup.py* can package a Python project
    for distribution. Because a *setup.py* file is executed at install time by Python,
    it allows doing anything aside from installation tasks. I don’t recommend extending
    *setup.py* to do anything other than packaging tasks to prevent issues when distributing
    an application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有严格的命名规则，但你通常可以在名为*requirements.txt*的纯文本文件中找到依赖项。项目维护者也可以定义多个包含依赖项的文本文件。例如，当开发依赖项与生产中的依赖项不同时，这种情况更为普遍。正如你将在下一节看到的那样，还有一个可以安装依赖项的*setup.py*文件。这是Python打包和依赖管理状态的一个不幸副作用。这两个文件都可以实现为Python项目安装依赖项的目标，但只有*setup.py*可以打包Python项目以进行分发。由于*setup.py*文件在Python安装时执行，它允许除安装任务以外的任何操作。我不建议扩展*setup.py*以执行除打包任务以外的任何操作，以避免在分发应用程序时出现问题。
- en: 'Some projects prefer to define their dependencies in a *requirements.txt* file
    and then reuse that file’s contents into the *setup.py* file. You can achieve
    this by reading the *requirements.txt* and using the `dependencies` variable:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目更喜欢在*requirements.txt*文件中定义它们的依赖项，然后重复使用该文件的内容到*setup.py*文件中。你可以通过读取*requirements.txt*并使用`dependencies`变量来实现这一点：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Distinguishing between these packaging files and knowing their background is
    useful to prevent confusion and misuse. You should now feel more comfortable discerning
    if a project is meant for distribution (*setup.py*) or a service or project that
    doesn’t require installation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 区分这些打包文件并了解它们的背景对于防止混淆和误用是有用的。现在，你应该更容易分辨出一个项目是用于分发（*setup.py*）还是一个不需要安装的服务或项目。
- en: Command Line Tools
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行工具
- en: One of the Python language features is the ability to quickly create applications
    with almost anything that you can imagine already included, from sending HTTP
    requests to processing files and text, all the way to ordering streams of data.
    The ecosystem of libraries available is vast. It doesn’t seem surprising that
    the scientific community has embraced Python as one of the top languages to tackle
    workloads that include machine learning.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言的一个特性是能够快速创建几乎包括任何你可以想象的应用程序，从发送HTTP请求到处理文件和文本，再到对数据流进行排序。可用的库生态系统非常庞大。科学界已将Python视为解决包括机器学习在内的工作负载的顶级语言之一，这似乎并不令人意外。
- en: An excellent way of approaching command line tool development is to identify
    a particular situation that needs solving. Next time you encounter a somewhat
    repetitive task, try to build a command line tool to automate the steps to produce
    the result. Automation is another core principle of DevOps that you should apply
    whenever possible (and as much as it makes sense) to tasks throughout ML. Although
    you can create a single Python file and use it as a command line tool, the examples
    in this section will use proper packaging techniques that will allow you to define
    required dependencies and get the tool installed with Python installers like `pip`.
    In the first example tool, I’ll show these Python patterns in detail to grasp
    the ideas behind command line tools that you can apply to the rest of this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 开发命令行工具的一个优秀方法是识别需要解决的特定情况。下次遇到稍微重复的任务时，试着构建一个命令行工具来自动化生成结果的步骤。自动化是DevOps的另一个核心原则，你应该尽可能（并且在合理的情况下）将其应用于ML中的任务。虽然你可以创建一个单独的Python文件并将其用作命令行工具，但本节的示例将使用适当的打包技术，使你能够定义所需的依赖关系，并使用像`pip`这样的Python安装程序安装工具。在第一个示例工具中，我将详细展示这些Python模式，以便理解可以应用于本章其余部分的命令行工具背后的思想。
- en: Creating a Dataset Linter
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据集检查器
- en: While creating this book, I decided to put together a dataset of wine ratings
    and descriptions. I couldn’t find anything similar, so I started gathering information
    for the dataset. Once the dataset had a healthy number of entries, the next step
    was to visualize the information and determine how robust the data was. As usual
    with the initial data state, this dataset presented several anomalies that took
    some effort to identify correctly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建本书时，我决定组合一个葡萄酒评分和描述的数据集。我找不到类似的数据，所以开始收集这个数据集的信息。一旦数据集有了足够多的条目，下一步就是可视化信息并确定数据的健壮性。与初始数据状态一样，这个数据集呈现了几个需要正确识别的异常情况。
- en: 'One problem was that after loading the data as a Pandas data frame, it was
    clear that one of the columns was unusable: almost all were `NaN` (also referred
    to as null entries). Another issue, which might be the worst of them all, was
    that I loaded the dataset into Azure ML Studio to perform some AutoML tasks that
    started yielding some surprising results. Although the dataset had six columns,
    Azure was reporting about forty.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是，在将数据加载为 Pandas 数据帧之后，很明显其中一列是无法使用的：几乎所有条目都是 `NaN`（也称为空条目）。另一个可能是最糟糕的问题是，我将数据集加载到
    Azure ML Studio 中执行一些自动 ML 任务时，结果开始出现一些令人惊讶的结果。尽管数据集有六列，但 Azure 报告大约有四十列。
- en: 'Lastly, *pandas* added unnamed columns when saving the processed data locally,
    and I wasn’t aware of this. The dataset is available to demonstrate the problems.
    Load the CSV (comma separated value) file as a *pandas* data frame first:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*pandas* 在保存处理后的数据时添加了未命名的列，而我并不知情。该数据集可用于演示问题。首先将 CSV（逗号分隔值）文件加载为 *pandas*
    数据框：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The table output from pandas looks great but hints that one column may be empty:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*pandas* 的表格输出看起来很棒，但暗示着可能有一列是空的：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When describing the dataset, one of the issues is now clear; the *grape* column
    doesn’t have any items in it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述数据集时，其中一个问题显而易见：*grape* 列中没有任何项目：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Drop the problematic column, and save the dataset onto a new CSV file, so that
    you can manipulate the data without having to download the contents every time:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 删除有问题的列，并将数据集保存到新的 CSV 文件中，这样您就可以在无需每次下载内容的情况下操作数据：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Rereading the file demonstrates the extra column added by *pandas*. To reproduce
    the issue, reread the local CSV file, save it as a new file, and look at the first
    line of the newly created file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重新读取文件显示了 *pandas* 添加的额外列。为了重现这个问题，重新读取本地的 CSV 文件，将其另存为新文件，然后查看新创建文件的第一行：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Look at the first line of the *wine2.csv* file to spot the new column:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 *wine2.csv* 文件的第一行以发现新列：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Azure problem was more involved, and it was tough to detect: Azure ML was
    interpreting new lines and carriage returns in one of the columns as new columns.
    To find these special characters, I had to configure my editor to show them (usually,
    they aren’t visible). In this example, the carriage return shows as `^M`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 的问题更为复杂，而且很难检测：Azure ML 将其中一个列中的换行符和回车符解释为新列。要找到这些特殊字符，我不得不配置我的编辑器以显示它们（通常情况下它们是看不见的）。在这个例子中，回车符显示为
    `^M`：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After dropping the column with no items in it, removing the unnamed columns,
    and getting rid of carriage returns, the data was now in a much healthier state.
    Now that I’ve done my due diligence cleaning up, I want to automate catching these
    problems. I’ll probably forget the deal with the extra columns in Azure or a column
    with useless values in it a year from now. Let’s create a command line tool to
    ingest a CSV file and produce some warnings.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除没有项目的列、删除未命名列并消除回车符后，数据现在处于更健康的状态。现在我已经尽到了清理的责任，我希望能自动捕捉这些问题。也许一年后我会忘记处理
    Azure 中的额外列或者一个带有无用值的列。让我们创建一个命令行工具来导入 CSV 文件并生成一些警告。
- en: 'Create a new directory called *csv-linter* and add a *setup.py* file that looks
    like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 *csv-linter* 的新目录，并添加一个像这样的 *setup.py* 文件：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This file allows Python installers to capture all the details of the Python
    package like dependencies and, in this case, the availability of a new command
    line tool called *csv-linter*. Most of the fields in the `setup` call are straightforward,
    but it is worth noting the details of the `entry_points` value. This is a feature
    of the *setuptools* library, which allows defining a function within a Python
    file to map back to a command line tool name. In this case, I’m naming the command
    line tool *csv-linter*, and I’m mapping it to a function (`main`) that I’ll create
    next inside a file called *csv_linter.py*. Although I’ve picked *csv-linter* to
    be the tool’s name, it can be named anything at all. Under the hood, the *setuptools*
    library will create the executable with whatever is declared here. There is no
    restriction to name it the same as the Python file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件允许 Python 安装程序捕获 Python 包的所有详细信息，如依赖关系以及在本例中名为*csv-linter*的新命令行工具的可用性。`setup`
    调用中的大多数字段都很简单，但值得注意的是 `entry_points` 的细节。这是 *setuptools* 库的一个特性，允许在 Python 文件中定义一个函数，将其映射回命令行工具名称。在这种情况下，我命名了命令行工具为*csv-linter*，并将其映射到稍后我将在名为
    *csv_linter.py* 的文件中创建的一个名为 `main` 的函数。虽然我选择了*csv-linter*作为工具的名称，但它可以用任何名称命名。在幕后，*setuptools*
    库将使用此处声明的任何内容创建可执行文件。命名与 Python 文件相同并无限制。
- en: 'Open a new file named *csv_linter.py* and add a single function that uses the
    Click framework:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个名为 *csv_linter.py* 的新文件，并添加一个使用 Click 框架的单个函数：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Even when examples don’t explicitly mention using Python’s virtual environments,
    it is always a good idea to create one. Having virtual environments is a robust
    way of isolating dependencies and potential problems with other libraries installed
    in a system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 即使示例中没有明确提到使用 Python 的虚拟环境，创建一个总是一个好主意。拥有虚拟环境是隔离依赖项和可能与系统中安装的其他库存在问题的强大方式。
- en: 'These two files are nearly all you need to create a command line tool that
    (for now) doesn’t do anything other than providing an executable available in
    your shell path. Next, create a virtual environment and activate it to install
    the newly created tool:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件几乎是创建一个命令行工具所需的全部内容（目前）仅提供在 shell 路径中可用的可执行文件。接下来，创建一个虚拟环境并激活它以安装新创建的工具：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The *setup.py* script has many different ways to get invoked, but you will
    primarily be using either the `install` argument or the `develop` one I used in
    the example. Using `develop` allows you to make changes to the script’s source
    code and get those automatically available in the script, whereas `install` would
    create a separate (or standalone) script with no ties back to the source code.
    When developing command line tools, I recommend using `develop` to test changes
    as you make progress quickly. After calling the *setup.py* script, test out the
    newly available tool by passing the `--help` flag:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*setup.py* 脚本有许多不同的方式可以调用，但您主要将使用我在示例中使用的 `install` 参数或 `develop` 参数之一。使用 `develop`
    允许您对脚本源代码进行更改，并使这些更改自动在脚本中可用，而 `install` 则会创建一个独立的（或独立的）脚本，与源代码没有关联。在开发命令行工具时，我建议使用
    `develop` 快速测试进展中的更改。调用 *setup.py* 脚本后，通过传递 `--help` 标志来测试新可用的工具：'
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Getting a help menu without having to write one is great, and it is a feature
    that a few other command line tool frameworks offer. Now that the tool is available
    as a script in the terminal, it is time to add useful features. To keep things
    simple, this script will accept a CSV file as a single argument. The Click framework
    has a built-in helper to accept files as arguments that ensure that the file exists
    and produces a helpful error otherwise. Update the *csv_linter.py* file to use
    the helper:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在不必编写帮助菜单的情况下获得一个是非常棒的功能，而这是其他几个命令行工具框架提供的特性。现在，该工具作为终端中的脚本可用，是时候添加一些有用的功能了。为了保持简单，此脚本将接受一个
    CSV 文件作为单个参数。Click 框架具有内置的帮助程序，用于接受文件作为参数，确保文件存在，否则会产生有用的错误。更新 *csv_linter.py*
    文件以使用此帮助程序：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Although the script isn’t doing anything with the file yet, the help menu has
    been updated to reflect the option:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然脚本尚未使用文件做任何事情，但帮助菜单已更新以反映选项：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Still, not doing something useful. Check what happens if you pass a CSV file
    that doesn’t exist:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然，没有做什么有用的事情。检查如果传递一个不存在的 CSV 文件会发生什么：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Take the tool a step further by using the `filename` argument that is getting
    passed into the `main()` function with Pandas to describe the dataset:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用传递给 `main()` 函数的 `filename` 参数进一步使用 Pandas 描述数据集的工具：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The script uses Pandas, and another Click helper called *echo*, which allows
    us to print output back to the terminal easily. Use the *wine.csv* file previously
    saved when processing the dataset as input:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本使用了Pandas，以及另一个名为*echo*的Click助手，它允许我们轻松地将输出打印回终端。使用在处理数据集时保存的*wine.csv*文件作为输入：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Still, this isn’t *too helpful*, even though it is now easily describing any
    CSV file using Pandas. The problem we need to solve here is to alert us about
    three potential issues:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这并不是*太有帮助*，即使现在可以轻松地使用Pandas描述任何CSV文件。我们需要解决的问题是警告我们三个潜在问题：
- en: Detect zero-count columns
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测零计数列
- en: Warn when `Unnamed` columns exist
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当存在`Unnamed`列时发出警告
- en: Check if there are carriage returns in a field
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查字段中是否有换行符
- en: 'Let’s start with detecting zero-count columns. Pandas allows us to iterate
    over its columns, and has a `count()` method that we can leverage for this purpose:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检测零计数列开始。Pandas允许我们迭代其列，并有一个我们可以利用的`count()`方法来实现这个目的：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Adapt the loop into a function separate from `main()` in the *csv_linter.py*
    file so that it is isolated and keeps things readable:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将循环调整为一个单独的函数，与*csv_linter.py*文件中的`main()`函数隔离开，以保持代码的可读性：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `zero_count_columns()` function takes as input the data frame from Pandas,
    captures all the columns with a zero-count, and returns them at the end. It is
    isolated and not coordinating the output with the `main()` function yet. Since
    it is returning a list of column names, loop over the contents of the result in
    the `main()` function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`zero_count_columns()`函数接受来自Pandas的数据框作为输入，捕获所有零计数的列，并在最后返回它们。它是隔离的，并且尚未与`main()`函数协调输出。因为它返回列名的列表，所以在`main()`函数中遍历结果的内容：'
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the script against the same CSV file (note that I removed the `.describe()`
    call):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对相同的CSV文件运行脚本（请注意，我已经删除了`.describe()`调用）：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At 19 lines, this script would’ve saved me a lot of time already if I had used
    it before sending the data into an ML platform. Next, create another function
    that loops over the columns to check for `Unnamed` ones:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在19行时，如果在将数据发送到ML平台之前使用了这个脚本，它已经为我节省了大量时间。接下来，创建另一个函数，循环遍历列以检查`Unnamed`列：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this case, the function checks if the `"Unnamed"` string is present in the
    name but is not returning the names (since we assume they are all similar or even
    the same), but rather, it returns the total count. With that information, expand
    the `main()` function to include the count:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，该函数检查名称中是否存在字符串`"Unnamed"`，但不返回名称（因为我们假设它们都是相似的甚至相同的），而是返回总计数。有了这些信息，扩展`main()`函数以包含计数：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the tool once again against the same CSV file to check the results:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行工具，针对相同的CSV文件检查结果：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, and perhaps the trickiest one to detect, is finding carriage returns
    within a large text field. This operation can be expensive, depending on the size
    of the dataset. Although there are more performant ways to accomplish the iteration,
    the next example will try to use the most straightforward approach. Create another
    function that does the work over the Pandas data frame:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也许最难检测的是在大文本字段内查找换行符。这个操作可能会很昂贵，具体取决于数据集的大小。虽然有更高效的方法来完成迭代，但下一个示例将尝试使用最直接的方法。创建另一个函数，在Pandas数据框上执行这项工作：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The loop prevents a `TypeError` from being raised. If the function does a string
    check against a different type, like an integer, then a `TypeError` would get
    produced. Since the operation can be costly, the function breaks out of the loop
    at the first sign of a carriage return. Finally, the loop returns the index, column,
    and the whole field for reporting by the `main()` function. Now update the script
    to include the reporting of carriage returns:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环防止了`TypeError`的产生。如果函数对不同类型（如整数）进行字符串检查，那么将会引发`TypeError`。由于该操作可能代价高昂，函数在第一个换行符的迹象出现时跳出循环。最后，循环返回索引、列和整个字段，以供`main()`函数报告。现在更新脚本，包括对换行符的报告：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Testing this last check is tricky because the dataset doesn’t have carriage
    returns anymore. [The repository for this chapter](https://oreil.ly/aaevY) includes
    an example CSV with carriage returns in it. Download that file locally and point
    the *csv-linter* tool to that file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这个最后一个检查是棘手的，因为数据集不再有换行符了。[本章的存储库](https://oreil.ly/aaevY)包含一个带有换行符的示例CSV文件。将该文件下载到本地，并将*csv-linter*工具指向该文件：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To prevent having an extremely long field printed in the output, the warning
    message is only showing the first 50 characters. This command line tool is leveraging
    the Click framework for the command line tool functionality and Pandas for the
    CSV inspection. Although it is doing only three checks and is not very performant,
    it would’ve been invaluable for me to prevent having issues using the dataset.
    There are multiple other ways to ensure a dataset is in acceptable shape, but
    this is an excellent example of how to automate (and prevent) problems that you
    encounter. Automation is the foundation of DevOps, and command line tools are
    an excellent way to start the automation path.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止在输出中打印出一个极长的字段，警告消息只显示前50个字符。这个命令行工具利用了Click框架进行命令行工具功能和Pandas进行CSV检查。尽管它只进行了三次检查且性能不是很好，但它对我来说防止使用数据集时出现问题是非常宝贵的。确保数据集处于可接受状态还有多种其他方法，但这是一个很好的示例，展示了如何自动化（和预防）您遇到的问题。自动化是DevOps的基础，命令行工具是开始自动化路径的一个很好的方式。
- en: Modularizing a Command Line Tool
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将命令行工具模块化
- en: The previous command line tool showed how to use Python’s internal libraries
    to create a script from a single Python file. But it is entirely possible to use
    a directory with multiple files that make up a single command line tool. This
    approach is preferable when the content of a single script starts getting hard
    to read. There is no hard limit on what should make you split a long file into
    multiple ones; I recommend grouping code that shares common responsibilities and
    separating them, especially when there is a need for code reuse. There might not
    be a use case for code reuse in some situations, but splitting some pieces could
    still make sense to improve readability and maintenance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令行工具展示了如何使用Python的内部库从单个Python文件创建脚本。但是完全可以使用包含多个文件的目录来创建一个命令行工具。当单个脚本的内容开始变得难以阅读时，这种方法更为可取。在什么情况下应该将一个长文件分割为多个文件没有明确的硬性限制；我建议在代码共享通用职责的情况下进行分组和分离，尤其是在需要代码重用时。在某些情况下，可能没有代码重用的用例，但是分割一些代码片段仍然有助于提高可读性和维护性。
- en: 'Let’s reuse the example of the *csv-linter* tool to adapt the single-file script
    into multiple files in a directory. The first step is creating a directory with
    an *__init__.py* file and move the *csv_linter.py* file into it. Using an *__init__.py*
    file tells Python to treat that directory as a module. The structure should now
    look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复使用 *csv-linter* 工具的示例，将单文件脚本调整为目录中的多个文件。第一步是创建一个带有 *__init__.py* 文件的目录，并将
    *csv_linter.py* 文件移动到其中。使用 *__init__.py* 文件告诉Python将该目录视为一个模块。现在的结构应该如下所示：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'At this point, there is no need to repeat the name of the tool in the Python
    file, so rename it to something more modular and less tied to the name of the
    tool. I usually suggest using *main.py*, so rename the file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在Python文件中不再需要重复工具的名称，因此将其重命名为更模块化且不那么与工具名称相关的内容是没有必要的。我通常建议使用 *main.py*，因此请将文件重命名为：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Try using the `csv_linter` command once again. The tool should be in a broken
    state because the files got moved around:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试使用 `csv_linter` 命令。由于文件被移动了，工具现在应该处于一个破碎的状态：
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is because the *setup.py* file is pointing to a module that doesn’t exist
    anymore. Update that file so that it finds the `main()` function inside of the
    *main.py* file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 *setup.py* 文件指向一个不再存在的模块。更新该文件，使其在 *main.py* 文件中找到 `main()` 函数：
- en: '[PRE35]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The change may be difficult to spot, but the entry point to `csv-linter` is
    now `csv_linter.main:main`. This change means that *setuptools* should look for
    a *csv_linter* package with a *main* module with a `main()` function in it. The
    syntax is a bit tricky to remember (I always have to look it up), but grasping
    the change details helps visualize how things are tied together. The installation
    process still has all the old references, so you must run *setup.py* again to
    make it all work:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更改可能很难发现，但是 `csv-linter` 的入口现在是 `csv_linter.main:main`。这个变化意味着 *setuptools*
    应该查找一个包含 `main()` 函数的 *main* 模块的 *csv_linter* 包。语法有点棘手（我总是不得不查一下），但掌握变化的细节有助于可视化事物是如何联系在一起的。安装过程仍然保留了所有旧的引用，因此您必须再次运行
    *setup.py* 才能使其正常运行：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that the *csv-linter* tool is in working order again let’s split up the
    *main.py* module into two files, one for the checks and the other one just for
    the command line tool work. Create a new file called *checks.py* and move the
    functions that do the checks from *main.py* into this new file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在*csv-linter*工具已经恢复正常，让我们将*main.py*模块拆分为两个文件，一个用于检查，另一个仅用于命令行工具工作。创建一个名为*checks.py*的新文件，并将从*main.py*移动到此新文件的检查函数：
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And now update *main.py* to import the checking functions from the *checks.py*
    file. The newly updated main module should now look like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更新*main.py*，从*checks.py*文件中导入检查函数。新更新的主模块现在应该像这样：
- en: '[PRE38]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Modularizing is a great way to keep things short and readable. When a tool separates
    concerns in this way, it is easier to maintain and reason about. There have been
    many times when I’ve had to work with legacy scripts that were *thousands* of
    lines long for no good reason. Now that the script is in good shape, we can go
    into microservices and take some of these concepts further.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化是保持代码简短和可读性的好方法。当工具以这种方式分离关注点时，更容易进行维护和推理。有许多次我不得不处理那些没有任何好理由长达*数千*行的旧脚本。现在脚本状态良好后，我们可以进一步探索微服务并深入了解这些概念。
- en: Microservices
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: As I mentioned at the beginning of this chapter, microservices are a new type
    of application paradigm, entirely opposed to old-style monolithic applications.
    For ML operations, in particular, it is critical to isolate responsibilities as
    much as possible from the process of getting models into production. Isolating
    components can then pave the way for reusability elsewhere, not only tied to a
    particular process for a single model.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章开头提到的，微服务是一种与旧式单体应用完全对立的新型应用范式。特别是对于ML操作，尽可能地从将模型投入生产的过程中隔离责任非常关键。隔离组件可以为在其他地方的可重用性铺平道路，不仅限于单一模型的特定流程。
- en: 'I tend to think about microservices and reusable components as pieces of a
    Jenga puzzle. A monolithic application would be an extremely tall Jenga tower
    with many pieces working together to make it stand, but with one major flaw: don’t
    try to touch anything that will bring the whole thing down. On the other hand,
    if the pieces are put together as robustly as possible (as at the beginning of
    the puzzle game), then removing pieces and repurposing them to a different spot
    is straightforward.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于将微服务和可重用组件视为俄罗斯方块拼图的一部分。一个单体应用就像是一个非常高的俄罗斯方块塔，许多部件一起工作以使其稳固，但存在一个主要缺陷：不要试图触及可能导致整体崩溃的任何东西。另一方面，如果这些部件被尽可能牢固地组合在一起（就像拼图游戏的开始），那么移除部件并将其重新用于不同位置就会变得简单。
- en: It is common for software engineers to quickly create utilities that are tightly
    coupled to the task at hand. For example, some logic that removes some values
    from a string, which you can then use to persist it in a database. Once the few
    lines of code have proven their worth, it is useful to think about reusability
    for other code base components. I tend to have a utility module in my projects,
    where common utilities go so that other pieces of the application that need the
    same facilities can import and reuse them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师通常会快速创建与手头任务紧密耦合的实用工具。例如，一些逻辑从字符串中删除某些值，然后可以将其持久化到数据库中。一旦少数行代码证明其价值，思考如何为其他代码基础组件实现重用就变得非常有用。我倾向于在我的项目中有一个实用模块，其中包含常见的实用程序，以便应用程序中需要相同设施的其他部分可以导入和重用它们。
- en: 'Like containerization, microservices allow concentrating more on the solution
    itself (the code) than the environment (e.g., operating system). One excellent
    solution for creating microservices is using serverless technologies. Serverless
    products from cloud providers take many different names (lambda and cloud functions,
    for example). Still, they all refer to the same thing: create a single file with
    some code and deploy instantly to the cloud—no need to worry about the underlying
    operating system or its dependencies. Just select a runtime from a drop-down menu,
    like Python 3.8, and click a button. Most cloud providers, in fact, allow you
    to create the function directly in the browser. This type of development and provisioning
    is fairly revolutionary, and it has been enabling interesting application patterns
    that were very complicated to achieve before.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器化类似，微服务允许更多地集中精力解决问题本身（代码），而不是环境（例如操作系统）。创建微服务的一个优秀解决方案是使用无服务器技术。云提供商的无服务器产品有许多不同的名称（例如
    lambda 和云函数），但它们都指的是同一件事情：创建一个带有一些代码的单个文件，并立即部署到云上——不需要担心底层操作系统或其依赖关系。只需从下拉菜单中选择一个运行时，比如
    Python 3.8，并点击一个按钮。事实上，大多数云提供商允许您直接在浏览器中创建函数。这种类型的开发和供应方式是相当革命性的，并且它已经使得之前非常复杂的应用程序模式变得可行。
- en: 'Another critical aspect of serverless is that you can access most of the cloud
    provider’s offerings without much effort. For ML, this is crucial: do you need
    to perform some computer vision operations? A serverless deployment can do this
    in less than a dozen lines of code. This way of leveraging ML operations in the
    cloud gets you speed, robustness, and reproducibility: all significant components
    of DevOps principles. Most companies will not need to create their own model for
    computer vision from scratch. The phrase “standing on the shoulders of giants”
    is a perfect fit to grasp the possibilities. Years ago, I worked in a digital
    media agency with a team of a dozen IT personnel who had decided to run their
    email servers in-house. Running email servers (correctly) takes a tremendous amount
    of knowledge and ongoing effort. Email is a *challenging problem to solve*. I
    can tell you that email would continuously stop working—in fact, it was almost
    a monthly occurrence.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器的另一个关键方面是，您可以轻松访问大多数云提供商的提供。对于 ML 来说，这是至关重要的：您需要执行一些计算机视觉操作吗？无服务器部署可以在不到十几行代码的情况下完成。这种在云中利用
    ML 操作的方式为您提供了速度、稳健性和可重现性：这些都是 DevOps 原则的重要组成部分。大多数公司不需要从头开始创建自己的计算机视觉模型。短语“站在巨人的肩膀上”完美地描述了这些可能性。多年前，我曾在一个数字媒体机构工作过，与一个拥有十几名
    IT 人员的团队一起决定自行运行他们的电子邮件服务器。运行电子邮件服务器（正确地）需要大量的知识和持续的努力。电子邮件是一个*具有挑战性的问题*。我可以告诉你，邮件经常会停止工作——事实上，这几乎是每月一次的事件。
- en: Finally, let’s look at how many options there are to build ML-based microservices
    on cloud providers. They typically range from more IaaS (infrastructure as a service)
    to more PaaS (platforms as a service). For example, in [Figure 11-1](#Figure-11-0-1),
    Kubernetes is a lower-level and complex technology that deploys microservices.
    In other scenarios, like AWS App Runner, covered earlier in the book, you can
    point your GitHub repo at the service and click a few buttons to get a fully deployed
    continuous delivery platform. Somewhere in the middle are cloud functions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看在云提供商上构建基于 ML 的微服务有多少选择。它们通常从更多的 IaaS（基础设施即服务）到更多的 PaaS（平台即服务）范围不等。例如，在[图
    11-1](#Figure-11-0-1)中，Kubernetes 是一个部署微服务的较低级和复杂技术。在其他场景中，像本书前面介绍的 AWS App Runner，您可以将您的
    GitHub 存储库指向该服务，并点击几个按钮即可获得完全部署的持续交付平台。在中间某处是云函数。
- en: '![pmlo 1101](Images/pmlo_1101.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![pmlo 1101](Images/pmlo_1101.png)'
- en: Figure 11-1\. Cloud ML microservices
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-1\. 云 ML 微服务
- en: What is your company’s core competency? If it isn’t state-of-the-art computer
    vision models, then don’t create these yourself. Likewise, work smart, not hard,
    and build on top of high-level systems like AWS App Runner or Google Cloud Run.
    Finally, resist the urge to reinvent the wheel and leverage cloud microservices.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您公司的核心竞争力是什么？如果不是最先进的计算机视觉模型，那就不要自己创建。同样，要聪明工作，而不是努力工作，并建立在像 AWS App Runner
    或 Google Cloud Run 这样的高级系统之上。最后，抵制重复发明轮子的冲动，利用云微服务。
- en: Creating a Serverless Function
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建无服务器函数
- en: Most cloud providers expose their ML services in their serverless environments.
    Computer vision, Natural Language Processing, and recommendation services are
    just a few. In this section, you will use a translation API to leverage one of
    the world’s most potent language-processing offerings.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数云提供商在其无服务器环境中公开其 ML 服务。计算机视觉、自然语言处理和推荐服务只是其中的几个。在本节中，您将使用翻译 API 利用全球最强大的语言处理服务之一。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For this serverless application, I will use [Google Cloud Platform](https://oreil.ly/IO8oP)
    (GCP). If you haven’t signed up for it before, you might get some free credits
    to try the example in this section, although with the current limits, you should
    still be able to deploy the cloud function without incurring any costs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个无服务器应用程序，我将使用[谷歌云平台](https://oreil.ly/IO8oP)（GCP）。如果您之前没有注册过它，您可能会获得一些免费的信用额度来尝试本节的示例，尽管根据当前的限制，您仍然可以部署云函数而不会产生任何费用。
- en: Once logged into GCP, select Cloud Functions from the left sidebar under the
    Compute section as shown in [Figure 11-2](#Figure-11-1).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 登录 GCP 后，从左侧边栏的“计算”部分下选择“云函数”，如[图 11-2](#Figure-11-1)所示。
- en: '![pmlo 1102](Images/pmlo_1102.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![pmlo 1102](Images/pmlo_1102.png)'
- en: Figure 11-2\. Cloud functions sidebar
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-2\. 云函数侧边栏
- en: If you haven’t created a function before, a greeting message should show you
    a link to create one. If you already have deployed a function, a Create Function
    button should be available otherwise. Creating and deploying a function from the
    UI involves just a few steps. [Figure 11-3](#Figure-11-2) is the form you should
    expect to fill out.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前没有创建过函数，会显示一个欢迎消息，指引您创建一个链接。如果您已经部署了一个函数，否则将可用一个“创建函数”按钮。通过 UI 创建和部署函数仅涉及几个步骤。[图
    11-3](#Figure-11-2) 是您可以期待填写的表单。
- en: '![pmlo 1103](Images/pmlo_1103.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![pmlo 1103](Images/pmlo_1103.png)'
- en: Figure 11-3\. Create a cloud function
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-3\. 创建一个云函数
- en: The default values for the Basics section are sufficient. In this case, the
    form comes pre-filled with *function-1* as the name and using *us-central1* as
    the region. Ensure you set the trigger type to HTTP, and that authentication is
    required. Click Save and then the Next button at the bottom of the page.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Basics 部分的默认值已足够。在这种情况下，表单预填了 *function-1* 作为名称，并使用 *us-central1* 作为区域。确保将触发器类型设置为
    HTTP，并且需要进行身份验证。单击“保存”，然后单击页面底部的“下一步”按钮。
- en: Warning
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Although unauthenticated invocations to functions are allowed (and as simple
    as selecting the option in the web form), I strongly suggest you never deploy
    a cloud function without authentication enabled. Exposed services over HTTP that
    are not authenticated pose a risk of getting abused. Since a cloud function’s
    usage is tied directly to your account and budget, it can have a substantial financial
    impact from unauthorized usage.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然允许对函数进行未经身份验证的调用（并且只需在 Web 表单中选择该选项就可以），但我强烈建议您永远不要在未启用身份验证的情况下部署云函数。未经身份验证的公开服务可能会被滥用，这对于您的帐户和预算都会产生重大的财务影响。由于云函数的使用直接与您的帐户和预算相关，未经授权的使用可能会带来重大的财务影响。
- en: Once in the Code section, you can select a runtime and an entry point. Select
    Python 3.8, change the entry point to use *main*, and update the function’s name
    to use `main()` instead of `hello_world()` as shown in [Figure 11-4](#Figure-11-3).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 进入“代码”部分后，您可以选择一个运行时和一个入口点。选择 Python 3.8，将入口点更改为使用 *main*，并更新函数名称以使用 `main()`
    而不是 `hello_world()`，如[图 11-4](#Figure-11-3)所示。
- en: '![pmlo 1104](Images/pmlo_1104.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![pmlo 1104](Images/pmlo_1104.png)'
- en: Figure 11-4\. Cloud functions code
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-4\. 云函数代码
- en: The ability to choose the entry point for the application opens up the possibilities
    of creating other functions to assist the main function or determine some other
    naming convention to interact with the code. Flexibility is great, but having
    defaults and using conventions is more valuable. Once you’ve made the necessary
    changes, click the Deploy button to get this function into a production environment.
    Once it completes, the function should show in the Cloud Functions dashboard.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 选择应用程序入口点的能力，打开了创建其他辅助主函数或确定与代码交互的其他命名约定的可能性。灵活性很好，但具有默认值和使用约定更有价值。完成必要的更改后，单击“部署”按钮将此功能部署到生产环境。一旦完成，该函数应显示在云函数仪表板上。
- en: Next, after deploying, let’s interact with it by sending an HTTP request. There
    are many ways to accomplish this. To get started, click Actions for the selected
    function and choose “Test function.” A new page loads, and although it may be
    hard to see it at first, the “Triggering event” section is where you add the body
    of the request to be sent. Since the function is looking for a `"message"` key,
    update the body to include a message like [Figure 11-5](#Figure-11-4) shows, then
    click the Test the function button.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后，让我们通过发送HTTP请求与之交互。有许多方法可以实现这一点。要开始，请点击所选函数的“操作”，然后选择“测试函数”。加载新页面，尽管一开始可能很难看到，但“触发事件”部分是您添加要发送的请求主体的地方。由于函数正在寻找`"message"`键，因此请更新主体以包含像[图 11-5](#Figure-11-4)所示的消息，然后点击“测试函数”按钮。
- en: '![pmlo 1105](Images/pmlo_1105.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![pmlo 1105](Images/pmlo_1105.png)'
- en: Figure 11-5\. Cloud function code—Triggering event
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-5\. 云函数代码—触发事件
- en: It should only take a few seconds to get the output, which should be the output
    from the value of the `"message"` key. Aside from that output, some logs should
    show up, making this a very straightforward way of interacting with the function.
    One thing that was not required was doing any authentication steps, although the
    function was created with authentication enabled. Whenever you are debugging and
    want to test a deployed function quickly, this is the easiest way by far.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 应该仅需几秒钟即可获得输出，该输出应为`"message"`键的值。除了该输出外，还会显示一些日志，这使得与函数交互变得非常直接。唯一不需要的是进行任何身份验证步骤，尽管函数是启用了身份验证创建的。每当您进行调试并希望快速测试部署的函数时，这无疑是最简单的方式。
- en: This function accepts JSON (JavaScript Object Notation) as input. Although it
    isn’t clear that the cloud function uses HTTP when testing, it is how the input
    gets delivered to the function. JSON is sometimes referred to as the *lingua franca*
    (common language) of web development because programming languages and other services
    and implementations can consume and produce JSON to native constructs that these
    languages and services understand.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受JSON（JavaScript对象表示法）作为输入。尽管在测试时尚不清楚云函数是否使用HTTP，但这是将输入传递给函数的方式。JSON有时被称为Web开发的*通用语言*，因为编程语言和其他服务和实现可以将JSON转换为它们理解的本地结构。
- en: Although HTTP APIs can restrict what types of requests and what format the body
    should be, it is relatively common to use JSON to communicate. In Python, you
    can load JSON into native data structures like lists and dictionaries, which are
    straightforward to use.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HTTP API可以限制请求的类型和主体格式，但通常使用JSON进行通信。在Python中，您可以将JSON加载到像列表和字典这样的本地数据结构中，这些结构易于使用。
- en: 'Before exploring other ways to interact with the function (including authentication),
    let’s leverage Google’s ML services by using their translation service. By default,
    all the APIs from Google’s Cloud Platform are disabled. If you need to interact
    with a cloud offering like language translations, you must enable the API before
    using it. It isn’t much of an issue if you create a cloud function (as in this
    case) and forget to do so. The resulting behavior would be an error captured in
    the logs, and an HTTP 500 returned as an error response back to the client making
    the request. This is an excerpt from the logs of a function that tried using the
    translation API without enabling it first:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索与函数交互的其他方法（包括身份验证）之前，让我们利用Google的ML服务，通过使用其翻译服务。默认情况下，所有来自Google云平台的API都是禁用的。如果您需要与诸如语言翻译之类的云服务进行交互，则必须在使用之前启用该API。如果您创建了一个云函数（如本例）并且忘记这样做，这并不是什么大问题。结果会在日志中记录错误，并作为错误响应返回给发出请求的客户端，HTTP
    500。
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Enable the [Cloud Translation API](https://oreil.ly/6SFRs) before making any
    further modifications to the function. Most of the APIs provided by GCP need to
    be enabled in a similar way, by [going to the APIs and Services link](https://oreil.ly/eV8sr)
    and finding the API you need in the Library page.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步修改函数之前，请启用[Cloud Translation API](https://oreil.ly/6SFRs)。GCP提供的大多数API都需要通过[访问API和服务链接](https://oreil.ly/eV8sr)并在库页面中找到所需的API来启用。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you are not an admin on the GCP account and do not see an API available,
    you may lack the necessary permissions to enable an API. An account administrator
    needs to grant you proper permissions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不是GCP帐户上的管理员并且看不到可用的API，则可能缺少启用API所需的权限。需要帐户管理员授予您适当的权限。
- en: 'After enabling the API, head back to the function by clicking its name so its
    dashboard loads. Once in the dashboard, find the Edit button at the top of the
    page to make changes to the source code. The Edit section presents you first with
    options to configure the function itself first and then the code. There is no
    need to make changes to the deployment configuration, so click Next to finally
    get to the source. Click the *requirements.txt* link that opens that file to add
    the API library that is required to interact with the translation service:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 API 后，点击函数名称返回其仪表板加载页面。在仪表板中，找到页面顶部的编辑按钮以更改源代码。编辑部分首先提供配置函数本身的选项，然后是代码。无需更改部署配置，请点击“下一步”最终进入源代码。点击
    *requirements.txt* 链接打开该文件，添加与翻译服务交互所需的 API 库：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now click *main.py* to edit the contents. Add the import statement to bring
    the translate service in, and add a new function that will be in charge of doing
    the translation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击 *main.py* 编辑内容。添加导入语句以引入翻译服务，并添加一个负责进行翻译的新函数：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This new function takes three arguments to interact with the translation API:
    the input text, the project ID, and the target language for the translation (defaulting
    to French). The input text defaults to English, but the function can be adapted
    to use other languages (e.g., Spanish) as input and English as the output. As
    long as the language is supported, the function can use the input and output with
    any combination.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新函数需要三个参数来与翻译 API 进行交互：输入文本、项目 ID 和翻译的目标语言（默认为法语）。输入文本默认为英语，但函数可以适应其他语言（例如西班牙语）作为输入和英语作为输出。只要支持该语言，函数就可以使用任意组合的输入和输出。
- en: The translation request response is iterable, so a loop is needed after the
    translation is complete.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译请求的响应是可迭代的，因此在翻译完成后需要一个循环。
- en: 'Now modify the `main()` function to pass the value from `"message"` into the
    `translator()` function. I’m using my own project ID (*“gcp-book-1”*) so make
    sure you update that with your own if trying the next example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在修改 `main()` 函数，将 `"message"` 的值传递给 `translator()` 函数。我正在使用自己的项目 ID（*“gcp-book-1”*），所以请确保在尝试下一个示例时更新自己的项目
    ID：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `main()` function still requires a `"message"` value assigned in the incoming
    JSON request but will now do something useful with it. Test it out in the console
    with a sample JSON input:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数仍然需要在传入的 JSON 请求中分配一个 `"message"` 值，但现在会对其进行有用的操作。在控制台上使用示例 JSON
    输入进行测试：'
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The output in the test page (shown in [Figure 11-6](#Figure-11-5)) should be
    almost immediate.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 测试页面的输出（如 [图 11-6](#Figure-11-5) 所示）应该几乎是即时的。
- en: '![pmlo 1106](Images/pmlo_1106.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![pmlo 1106](Images/pmlo_1106.png)'
- en: Figure 11-6\. Translated test
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-6\. 翻译测试
- en: Authenticating to Cloud Functions
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证 Cloud Functions
- en: 'I see HTTP access as access democracy: tremendous flexibility for other systems
    and languages to interact from their implementations into a separate service in
    a remote location using the HTTP spec. All major programming languages can construct
    HTTP requests and process responses from servers. Bringing services together with
    the help of HTTP allows these services to work in new ways, potentially in ways
    that were not thought of initially. Think of HTTP APIs as extensible functionality
    that can plug into anything connected to the internet. But connecting over the
    internet has security implications, like preventing unauthorized access with authenticated
    requests.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我将 HTTP 访问看作是访问民主主义：其他系统和语言都能通过其实现从远程位置的独立服务中使用 HTTP 规范进行交互，具有极大的灵活性。所有主要编程语言都可以构建
    HTTP 请求并处理来自服务器的响应。利用 HTTP 将服务整合在一起可以使这些服务以新的方式工作，潜在地可以实现最初没有考虑到的功能。将 HTTP API
    视为可插入任何连接到互联网的内容的可扩展功能。但是通过互联网连接存在安全影响，如使用经过身份验证的请求来防止未经授权的访问。
- en: 'There are a few ways you can interact remotely with a cloud function. I’ll
    start with the command line, using the *curl* program. Although I tend not to
    use *curl* for interacting with authenticated requests, it does offer a straightforward
    way of documenting all the pieces that you need to be successful in submitting
    the request. [Install the Google Cloud SDK](https://oreil.ly/2l7tA) for your system,
    and then determine the project ID and the function name you deployed before. The
    following example uses *curl* with the SDK to authenticate:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种远程与云函数交互的方式。我将从命令行开始，使用*curl*程序。虽然我倾向于不使用*curl*来进行身份验证请求的交互，但它确实提供了一个直接的方式来记录您需要成功提交请求的所有组件。为您的系统[安装Google
    Cloud SDK](https://oreil.ly/2l7tA)，然后确定您之前部署的项目ID和函数名称。以下示例使用SDK和*curl*进行身份验证：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'On my system, using the *function-1* URL, I get the following response:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上，使用*function-1* URL，我得到以下响应：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The command seems very involved, but it presents a better picture of what is
    needed to make a successful request. First, it declared that the request uses
    a POST method. This method is commonly used when a payload is associated with
    a request. In this case, `curl` is sending JSON from the argument to the `--data`
    flag. Next, the command adds two request headers, one to indicate the type of
    content being sent (JSON) and the other one to indicate that the request is providing
    a token. The token is where the SDK comes into play because it creates a token
    for the request, which is required by the cloud function service to verify the
    request as authenticated. Finally, the URL for the cloud function is used as the
    target for this authenticated POST request sending JSON.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令看起来非常复杂，但它提供了一个更好的图像，说明了需要成功提交请求的所有组件。首先，它声明请求使用POST方法。当请求与负载相关联时，通常会使用此方法。在本例中，`curl`从参数向`--data`标志发送JSON。接下来，命令添加了两个请求头，一个用于指示发送的内容类型（JSON），另一个用于指示请求提供令牌。令牌是SDK发挥作用的地方，因为它为请求创建了一个令牌，云函数服务需要验证请求是否经过身份验证。最后，云函数的URL被用作这个经过身份验证的POST请求的目标，发送JSON。
- en: 'Try running the SDK command on its own to see what it does:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试单独运行SDK命令，看看它的效果：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now that you understand the required components for the request, try the SDK
    directly to make the request for you to reach the deployed cloud function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了请求所需的组件，请直接使用SDK来发出请求，以便您能够访问部署的云函数：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: I think it is an excellent idea from cloud providers like Google to include
    other facilities to interact with their services as it happens here with the cloud
    function. If you only were aware of the SDK command to interact with a cloud function,
    it would be difficult to use a programming language to construct a request, for
    example, with Python. These options offer flexibility, and the more flexible an
    environment is, the better the chances of adapting it in the most reasonable way
    to fit your environment’s needs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为像Google这样的云服务提供商包含其他与其服务交互的便利设施是一个很好的主意，就像这里的云函数一样。如果您只是知道SDK命令来与云函数交互，使用编程语言例如Python构造请求将会变得困难。这些选择提供了灵活性，环境越灵活，就越有可能以最合理的方式进行适应，以满足环境的需求。
- en: Now let’s use Python to interact with the translator function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Python与翻译器函数进行交互。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The following example will call out directly to the `gcloud` command using Python,
    making it easier to quickly demonstrate how to create Python code to interact
    with the cloud function. However, it isn’t a robust way of dealing with authentication.
    You will need to [create a service account](https://oreil.ly/qNtoc) and use the
    *google-api-python-client* to secure the authentication process properly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将直接调用Python使用`gcloud`命令，快速演示如何创建Python代码与云函数进行交互。然而，这并不是处理身份验证的稳健方式。您需要[创建服务账号](https://oreil.ly/qNtoc)并使用*google-api-python-client*来正确地保护身份验证过程。
- en: 'Create a Python file called *trigger.py* and add the following code to retrieve
    the token from the `gcloud` command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*trigger.py*的Python文件，并添加以下代码以从`gcloud`命令中检索令牌：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `token()` function will call the `gcloud` command and process the output
    to make the request. It is worth reiterating that this is a quick way to demonstrate
    making requests to trigger the function from Python. You should consider creating
    a Service Account and OAuth2 from the *google-api-python-client* if looking to
    implement this in a production environment.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`token()`函数将调用`gcloud`命令并处理输出以发出请求。值得重申的是，这是一种快速演示从Python触发函数的方法。如果希望在生产环境中实现这一点，则应考虑从*google-api-python-client*创建服务帐户和OAuth2。'
- en: 'Now create the request using that token to communicate with the cloud function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用该令牌创建请求，以与云函数通信：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that I’ve added the *requests* library (version 2.25.1 in my case) to
    the script, so you need to install it before continuing. Now run the *trigger.py*
    file to test it out, ensuring you have updated the script with your project ID:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已经在脚本中添加了*requests*库（在我的情况下是版本2.25.1），因此在继续之前，您需要安装它。现在运行*trigger.py*文件来测试它，确保您已经使用您的项目ID更新了脚本：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Building a Cloud-Based CLI
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建基于云的命令行界面（CLI）
- en: 'Now that you understand the concepts for building a command line tool, packaging
    it, and distributing it while leveraging the cloud for its ML offerings, it is
    interesting to see these come together. In this section, I will reuse all the
    different parts to create one. Create a new directory, and add the following to
    a *setup.py* file so that packaging is solved right away:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您理解了构建命令行工具、打包和分发它以及利用云提供的ML服务的概念，很有意思看到这些内容如何结合在一起。在本节中，我将重复使用所有不同的部分来创建一个。创建一个新目录，并将以下内容添加到*setup.py*文件中，以便立即解决打包问题：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The *setup.py* file will create a *cloud-translate* executable mapped to a
    `main()` function within the *trigger.py* file. We haven’t created that function
    yet, so add the *trigger.py* file that was created in the previous section and
    add the function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*setup.py*文件将创建一个*cloud-translate*可执行文件，映射到*trigger.py*文件中的一个`main()`函数。我们还没有创建那个函数，因此请添加在上一节中创建的*trigger.py*文件，并添加该函数：'
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The file isn’t that different from the initial *trigger.py* where it runs directly
    with Python. The Click framework allows us to define a *text* input and then print
    the output to the terminal when it completes. Run `python setup.py develop` so
    that everything gets wired together, including the dependencies. As expected,
    the framework gives us the help menu:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件与最初的*trigger.py*并没有太大的区别，它直接使用Python运行。Click框架允许我们定义一个*text*输入，然后在完成时将输出打印到终端。运行`python
    setup.py develop`以确保所有东西都被连接在一起，包括依赖项。正如预期的那样，该框架为我们提供了帮助菜单：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Machine Learning CLI Workflows
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习CLI工作流程
- en: The shortest distance between two points is a straight line. Likewise, a command
    line tool is often the most straightforward approach to using machine learning.
    In [Figure 11-7](#Figure-11-6), you can see that there are many different styles
    of ML techniques. In the case of unsupervised machine learning, you can train
    “on the fly”; in other cases, you may want to use a trained nightly model and
    place it in object storage. Yet, you may wish to use high-level tools like AutoML,
    AI APIS, or models created by third parties in others.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 两点之间的最短距离是直线。同样地，命令行工具通常是使用机器学习的最直接方法。在[图 11-7](#Figure-11-6)中，您可以看到有许多不同的ML技术风格。在无监督机器学习的情况下，您可以“即时训练”；在其他情况下，您可能希望使用每晚训练过的模型，并将其放置在对象存储中。然而，在其他情况下，您可能希望使用AutoML、AI
    API或第三方创建的模型等高级工具。
- en: Notice that there are many different problem domains where adding ML enhances
    a CLI or is the entire purpose of the CLI. These domains include text, computer
    vision, behavioral analytics, and customer analysis.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有许多不同的问题领域，在这些领域中，通过添加ML来增强CLI或使CLI的整个目的。这些领域包括文本、计算机视觉、行为分析和客户分析。
- en: It is essential to point out that there are many targets for deploying command
    line tools that include machine learning. A filesystem like Amazon EFS, GCP Filestore,
    or Red Hat Ceph have the advantage of being a centralized Unix mount point for
    a cluster. The *bin* directory could include ML CLI tools delivered via a Jenkins
    server that mounts this same volume.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 强调有许多部署命令行工具的目标，其中包括机器学习。像Amazon EFS、GCP Filestore或Red Hat Ceph这样的文件系统具有作为集中Unix挂载点的优势。*bin*目录可以包含通过挂载同一卷的Jenkins服务器传递的ML
    CLI工具。
- en: Other delivery targets include the Python Package Repository (PyPI), and public
    Container Registries like Docker, GitHub, and Amazon. Yet more targets include
    Linux packages like Debian and RPM. A command line tool that packages machine
    learning has a much more extensive collection of deployment targets than even
    a microservice because a command line tool is an entire application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其他交付目标包括 Python Package Repository（PyPI）和像 Docker、GitHub 和 Amazon 这样的公共容器注册表。还有更多的目标包括像
    Debian 和 RPM 这样的 Linux 包。一个打包机器学习的命令行工具拥有比微服务甚至更广泛的部署目标收藏，因为一个命令行工具就是一个完整的应用程序。
- en: '![pmlo 1107](Images/pmlo_1107.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![pmlo 1107](Images/pmlo_1107.png)'
- en: Figure 11-7\. Machine learning CLI workflows
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-7\. 机器学习 CLI 工作流程
- en: 'A few good examples of projects suitable for doing machine learning with a
    CLI include the following resources:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 适合使用 CLI 进行机器学习的几个好例子包括以下资源：
- en: DevML
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: DevML
- en: '[DevML](https://oreil.ly/pMU53) is a project that analyzes GitHub organizations
    and allows ML practitioners to create their own “secret ML” predictions, perhaps
    by connecting it to [streamlit](https://streamlit.io) or including developer clustering
    reports in Amazon QuickSight.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[DevML](https://oreil.ly/pMU53) 是一个分析 GitHub 组织的项目，允许机器学习实践者创建自己的“秘密 ML” 预测，可以通过连接到
    [streamlit](https://streamlit.io) 或将开发者聚类报告包含在 Amazon QuickSight 中来实现。'
- en: Python MLOps Cookbook
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Python MLOps Cookbook
- en: The [Python MLOps Cookbook GitHub repo](https://oreil.ly/4jAUL) contains a simple
    ML model as a set of utilities. This project has detailed coverage in [Chapter 7](ch07.xhtml#Chapter7).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python MLOps Cookbook GitHub 仓库](https://oreil.ly/4jAUL) 包含一组实用工具作为简单的 ML
    模型。本项目在 [第 7 章](ch07.xhtml#Chapter7) 中有详细介绍。'
- en: Spot Price Machine Learning
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Spot 价格机器学习
- en: Yet another ML CLI example is a project on Spot Price Machine Learning Clustering.
    [In this GitHub repository](https://oreil.ly/OiutZ), different attributes of AWS
    spot instances, including memory, CPU, and price, are used to create clusters
    of machine types that are similar.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 ML CLI 示例是关于 Spot 价格机器学习聚类的项目。[在这个 GitHub 仓库中](https://oreil.ly/OiutZ)，使用
    AWS Spot 实例的不同属性，包括内存、CPU 和价格，来创建类似的机器类型的聚类。
- en: With these CLI workflows out of the way, let’s move on to wrapping up the chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些 CLI 工作流程，让我们继续总结本章。
- en: Conclusion
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: This chapter has described how to create command line tools from the ground
    up and use a framework to create tools to perform automation rapidly. Even when
    examples may look trivial, the details and how things work together are essential
    aspects. When learning new concepts or subjects that others commonly dread (like
    packaging in general), it is easy to feel discouraged and try to work around them.
    Although Python has a long road toward better packaging, getting started is not
    that hard, and doing the heavy lifting with proper packaging of your tools will
    make you invaluable in any team. With packaging and command line tools, you are
    now well-positioned to start bringing different services together for automation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经介绍了如何从头开始创建命令行工具，并使用框架快速进行自动化工具的创建。即使示例看起来可能很琐碎，但细节和各个部分如何协作是至关重要的方面。在学习新概念或通常让其他人望而却步的主题（如打包）时，很容易感到泄气并试图绕过它们。尽管
    Python 在改进打包方面还有很长的路要走，但入门并不难，通过正确打包工具的繁重工作将使您在任何团队中都变得不可或缺。通过打包和命令行工具，您现在已经具备了将不同服务集成到自动化中的良好位置。
- en: 'This chapter did that by leveraging the cloud and its many ML offerings: a
    powerful translation API from Google. It is critical to remember that there is
    no need to create all the models from scratch and you should leverage cloud providers’
    offerings whenever possible, especially when it isn’t a core competency of your
    company.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过利用云及其众多机器学习服务，例如来自谷歌的强大翻译 API，来实现这一点。记住，没有必要从头开始创建所有模型，尽可能利用云服务提供者的服务，特别是当这不是你公司核心竞争力时。
- en: Finally, I want to emphasize that being able to craft new solutions to tricky
    problems is an MLOps superpower, based on knowing how to connect services and
    applications. As you now know, using HTTP, command line tools, and leveraging
    cloud offerings via their SDKs is a strong foundation to make substantial improvements
    in almost any production environment.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想强调的是，能够为棘手的问题制定新解决方案是 MLOps 的超能力，这基于了解如何连接服务和应用程序。正如您现在所知，使用 HTTP、命令行工具和通过它们的
    SDK 利用云服务提供者是在几乎任何生产环境中实现重大改进的坚实基础。
- en: 'In the next chapter we go into other details of machine learning engineering,
    and one of my favorite topics: case studies. Case studies are real-world problems
    and situations where you can extract useful experiences and apply them today.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨机器学习工程的其他细节，以及我最喜欢的主题之一：案例研究。案例研究是真实世界中的问题和情况，您可以从中提取有用的经验并今天应用它们。
- en: Exercises
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Add some more options to the CLI that use cloud functions, like making the URL
    configurable.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CLI中添加一些使用云函数的选项，比如使URL可配置。
- en: Find out how the Service Account and OAuth2 work with the Google SDK and integrate
    it in *trigger.py* to avoid using the *subprocess* module.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弄清楚服务帐户和OAuth2在Google SDK中的工作原理，并将其集成到*trigger.py*中，以避免使用*subprocess*模块。
- en: Enhance the cloud function by translating a separate source, like a page from
    Wikipedia.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过翻译来自维基百科页面等其他来源来增强云函数。
- en: Create a new cloud function that does image recognition and make it work with
    a command line tool.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的云函数进行图像识别，并使其与命令行工具配合使用。
- en: Fork the [Python MLOps Cookbook repository](https://oreil.ly/fX1Uu) and build
    a slightly different containerized CLI tool that you publish to a public container
    registry like DockerHub or GitHub Container Registry.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆[Python MLOps Cookbook repository](https://oreil.ly/fX1Uu)并构建一个稍微不同的容器化CLI工具，将其发布到像DockerHub或GitHub
    Container Registry这样的公共容器注册表中。
- en: Critical Thinking Discussion Questions
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批判性思维讨论问题
- en: Name one possible consequence of unauthenticated cloud functions.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未经身份验证的云函数可能会带来哪些可能的后果？
- en: What are some of the drawbacks of not using a virtual environment?
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用虚拟环境的一些缺点是什么？
- en: Describe two aspects of good debugging techniques and why they are useful.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述好的调试技术的两个方面及其有用性。
- en: Why is knowing packaging useful? What are some critical aspects of packaging?
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么了解打包很有用？打包的一些关键方面是什么？
- en: Is it a good idea to use an existing model from a cloud provider? Why?
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用云提供商现有模型是个好主意吗？为什么？
- en: Explain the trade-offs in deploying an open source CLI tool powered by machine
    learning using a public container registry versus using the Python Package Repository.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释使用公共容器注册表部署由机器学习驱动的开源CLI工具与使用Python包仓库之间的权衡。
