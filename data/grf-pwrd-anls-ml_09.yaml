- en: Chapter 7\. Better Referrals and Recommendations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。更好的推荐和推荐
- en: 'This chapter will demonstrate how graph analytics can retrieve information
    from a network to make better referrals and recommendations, using two real-world
    use cases. In the first use case, we will build a referral network between patients
    and healthcare specialists. We will see how to determine which doctors are the
    most influential and how their interrelations form communities. The second use
    case is about making a better recommendation engine using features based on the
    connections and affinities among customers, context factors, products, and features.
    By the end of this chapter, you should be able to:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示如何使用图分析从网络中检索信息，以便更好地进行推荐和推荐，使用两个真实的用例。在第一个用例中，我们将建立一个患者和医疗专家之间的推荐网络。我们将看到如何确定哪些医生是最有影响力的，以及他们之间的相互关系如何形成社区。第二个用例涉及使用基于客户、上下文因素、产品和特征之间连接和亲和力的特征来构建更好的推荐引擎。在本章结束时，您应该能够：
- en: Understand how graph connections provide context
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解图连接如何提供上下文
- en: Apply multiple techniques for analyzing context in order to make recommendations
    and referrals
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用多种技术分析上下文，以便进行推荐和推荐
- en: Know how to model and analyze a referral network
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何建模和分析推荐网络
- en: Know how to model and analyze a recommendation engine using graphs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何使用图分析建模和分析推荐引擎
- en: Explain the meaning of a high PageRank score using the concepts of referral
    and authority
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释高PageRank分数的含义，使用转诊和权威的概念
- en: 'Case 1: Improving Healthcare Referrals'
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例1：改善医疗转诊
- en: Today’s healthcare industry has evolved to include many specialties and specialists.
    This has advanced the state of the art in many areas and given patients the potential
    to receive expert care. When a patient’s situation is beyond the routine care
    offered by a general practitioner, the general practitioner may refer the patient
    to a specialist. There may be subsequent referrals to other specialists. In many
    healthcare systems, a patient does not have the authority to see a specialist
    without a referral; a formal referral from one doctor to another is required in
    order to manage healthcare costs and efficiency.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的医疗保健行业已发展到包括许多专业和专家。这在许多领域推进了技术进步，并使患者有可能接受专家护理。当患者的情况超出一般执业医生提供的常规护理时，一般执业医生可能会将患者转诊给专家。可能会有后续的转诊到其他专家。在许多医疗系统中，患者无权在没有转诊的情况下看专家；需要一个医生对另一个医生的正式转诊，以管理医疗成本和效率。
- en: Understanding referral behavior is important to doctors, their patients, healthcare
    provider organizations, and insurance companies. Healthcare specialists who want
    to grow their businesses and client bases must build and maintain a strong level
    of referrals. According to market research in 2020, there is annual leaked revenue
    of $900,000 per physician alone due to missed referrals.^([1](ch07.html#ch01fn17))
    In this regard, medical practitioners are similar to lawyers, physical trainers,
    home decorators, and many other service providers who in part rely on referrals
    to build their businesses. Patients may want to know if a referral is due to quality
    of care or some economic factor. Insurers can study the referral data to see if
    there is a suspicious pattern that may constitute a form of fraud. Is a provider
    steering referrals to another provider beyond what is medically necessary?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 了解推荐行为对医生、他们的患者、医疗服务提供机构和保险公司都很重要。希望扩展业务和客户基础的医疗专家必须建立和维护强大的推荐水平。根据2020年的市场研究，每位医生每年因未能提供转诊而流失的收入高达90万美元。^([1](ch07.html#ch01fn17))
    在这方面，医疗从业者类似于律师、体育教练、家庭装饰师和许多其他部分依赖于推荐来建立业务的服务提供者。患者可能想知道推荐是否由于护理质量或某些经济因素。保险公司可以研究推荐数据，看看是否存在可疑的模式，这可能构成一种欺诈形式。提供者是否在医疗必要范围外引导转诊？
- en: To answer these questions, we need to be able to see the big picture and analyze
    multiple layers of doctors making referrals to other doctors in what can be a
    chain of referrals, or sometimes even a loop. The industry talks about referral
    *networks*. The structure of these provider-patient referral networks lends itself
    quite well to graph analysis.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这些问题，我们需要能够看到全局图景并分析多层次的医生之间进行推荐的情况，这可能是一系列的推荐链，甚至有时是一个循环。该行业讨论推荐*网络*的结构。这些提供者-患者推荐网络的结构非常适合进行图分析。
- en: 'Solution: Form and Analyze a Referral Graph'
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案：形成和分析转诊图
- en: The goal of a referral network is to ensure the healthcare quality of the patient
    by sending them to the correct specialty practices via their doctors. A referral
    network achieves this through streamlined communication among patients, doctors,
    and healthcare specialists that is transparent and efficient for all stakeholders.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 转诊网络的目标是通过将患者发送到正确的专科实践中来确保患者的医疗质量，方法是通过透明且对所有利益相关者有效的患者、医生和医疗专家之间的简化沟通来实现。
- en: Understanding the dynamics in a referral network is valuable to both the individual
    participants and an organization like a health insurance provider that wants to
    manage the network as a whole. An in-depth analysis of a referral network can
    reveal inefficiencies in the system. For example, a doctor might routinely refer
    patients with specific symptoms to a particular specialist, not realizing that
    the specialist tends to refer those patients again to another specialist. Today’s
    medical providers are busy dealing with the patient issues immediately in front
    of them and may not see the more holistic system-level view. A doctor or administrator
    who has access to analysis of the referral network could identify these patterns
    and adjust their referral protocols in light of the data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 了解转诊网络的动态对个体参与者以及像健康保险提供者这样希望全面管理网络的组织都是有价值的。对转诊网络的深入分析可以揭示系统中的低效。例如，医生可能会经常将具有特定症状的患者转诊给特定专家，而不知道该专家倾向于再次将这些患者转诊给另一专家。如今的医疗提供者忙于立即处理面前的患者问题，可能无法看到更全面的系统级视角。能够访问转诊网络分析的医生或管理员可以识别这些模式，并根据数据调整其转诊方案。
- en: 'In general, there are three reasons why doctors refer their patients to other
    healthcare specialists: first, to seek the advice of the specialist on the diagnosis
    or treatment; second, to add the specialist to a team of healthcare providers
    for the patient; and third, to transfer the patient when the original doctor is
    not the right fit because of experience gaps or other personal factors. In a referral
    network, vertices represent doctors, patients, and healthcare specialists. A patient’s
    referral by a doctor to a healthcare specialist is represented as a directed edge.
    Making the right referrals at the right time is an important part of providing
    good quality and efficient health care. We can analyze the resultant directed
    network to identify important doctors and specialists.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，医生将其患者转诊给其他医疗专家有三个原因：第一，寻求专家在诊断或治疗上的建议；第二，将专家添加到为患者提供服务的医疗提供者团队中；第三，当原始医生由于经验差距或其他个人因素不适合时，将患者转移。在转诊网络中，顶点代表医生、患者和医疗专家。医生向医疗专家转诊患者的行为表示为有向边。在适当的时间做出正确的转诊是提供优质和高效医疗的重要组成部分。我们可以分析生成的有向网络以识别重要的医生和专家。
- en: Implementing a Referral Network of Healthcare Specialists
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施医疗专家转诊网络
- en: TigerGraph has a starter kit that models a healthcare referral network. We use
    this starter kit to explore and analyze the referral network of healthcare specialists,
    patients, and doctors. You can install it following the steps from [Chapter 3](ch03.html#see_your_customers_and_business_better).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: TigerGraph 提供了一个入门套件，用于建模医疗转诊网络。我们使用这个入门套件来探索和分析医疗专家、患者和医生的转诊网络。你可以按照 [第三章](ch03.html#see_your_customers_and_business_better)
    中的步骤进行安装。
- en: The Healthcare Referral Network Starter Kit
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 医疗转诊网络入门套件
- en: Deploy a new TigerGraph Cloud instance, selecting “Healthcare – Referral Networks,
    Hub & Community Detection” as the starter kit. After successful installation,
    you can load the data following the steps listed in the section [“Load data and
    install queries for a starter kit”](ch03.html#load_data_and_install_queries_for_a_sta)
    in [Chapter 3](ch03.html#see_your_customers_and_business_better).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 部署一个新的 TigerGraph 云实例，选择“医疗 - 转诊网络、中心和社区检测”作为入门套件。安装成功后，你可以按照 [“加载数据和安装入门套件的查询”](ch03.html#load_data_and_install_queries_for_a_sta)
    小节在 [第三章](ch03.html#see_your_customers_and_business_better) 中列出的步骤加载数据。
- en: Graph Schema
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图谱模式
- en: The Healthcare Referral Network Starter Kit includes more than 11K vertices
    and more than 40K edges. There are five different vertex types and five directed
    edge types.^([2](ch07.html#ch01fn18)) The schema of this starter kit is shown
    in [Figure 7-1](#graph_schema_for_the_healthcare_refer).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 医疗转诊网络入门套件包括超过11K个顶点和超过40K条边。有五种不同的顶点类型和五种有向边类型。^([2](ch07.html#ch01fn18)) 该入门套件的模式显示在[图 7-1](#graph_schema_for_the_healthcare_refer)中。
- en: '![Graph schema for the Healthcare - Referral networks, Hub & Community Detection
    Starter Kit](assets/gpam_0701.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![医疗保健 - 转诊网络、枢纽和社区检测入门套件的图模式](assets/gpam_0701.png)'
- en: Figure 7-1\. Graph schema for the Healthcare - Referral Networks, Hub & Community
    Detection Starter Kit (see a larger version of this figure at [https://oreil.ly/gpam0701](https://oreil.ly/gpam0701))
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-1\. 医疗保健 - 转诊网络、枢纽和社区检测入门套件的图模式（请参阅该图的更大版本：[https://oreil.ly/gpam0701](https://oreil.ly/gpam0701)）
- en: We describe the five vertex types in [Table 7-1](#vertex_types_in_the_healthcare_referral).
    A `**Prescriber**` is a doctor or nurse practitioner who performs medical service
    and then submits a `**Claim**` associated with a `**Patient**`. Each `**Prescriber**`
    has a `**Specialty**` and `**Subspecialty**`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[表 7-1](#vertex_types_in_the_healthcare_referral)中描述了五种顶点类型。`**处方者**`是一个医生或护士从业者，执行医疗服务，然后提交与`**患者**`相关联的`**索赔**`。每个`**处方者**`都有一个`**专科**`和`**亚专科**`。
- en: Four of the five edge types are very straightforward; the **`referral`** edge
    type deserves some special attention. A `**Prescriber**` may make a `**referral**`
    to another `**Prescriber**` so that the `**Patient**` can receive additional care.
    However, if you look at the Graph statistics table on the Load Data page, you
    will see that there are zero referral edges! The source data does not specify
    any referrals. One of the queries we will run will use the data in the graph to
    *infer* referrals. Link inference, also known as link prediction, is one of the
    most valuable capabilities offered by graph analytics.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 五种边类型中有四种非常直接；`**转诊**`边类型值得特别关注。`**处方者**`可能向另一`**处方者**`推荐，以便`**患者**`可以接受额外的护理。然而，如果您查看加载数据页面上的图统计表，您将看到没有转诊边缘！源数据没有指定任何转诊。我们将运行的一个查询将使用图中的数据来推断转诊。链接推断，也称为链接预测，是图分析提供的最有价值的能力之一。
- en: Table 7-1\. Vertex types in the Healthcare Referral graph model
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1\. 医疗转诊图模型中的顶点类型
- en: '| Vertex type | Description |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 顶点类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `**Prescriber**` | A medical practitioner who can make diagnoses and prescribe
    medicines |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `**处方者**` | 能够诊断并开药的医疗从业者 |'
- en: '| `**Claim**` | A description of billable medical services performed by the
    Prescriber and associated with a Patient |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `**索赔**` | 由处方者执行的可计费医疗服务的描述，与患者相关联 |'
- en: '| `**Patient**` | A person who receives medical care |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `**患者**` | 接受医疗服务的人 |'
- en: '| `**Specialty**` | A branch of medical practice focused on a category of biological
    systems, disorders, treatments, or patients |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `**专科**` | 医疗实践的一个分支，专注于一类生物系统、障碍、治疗或患者 |'
- en: '| `**Subspecialty**` | A subcategory of a Specialty |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `**亚专科**` | 专科的一个子类别 |'
- en: Queries and Analytics
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询和分析
- en: The Healthcare Referral Network Starter Kit contains numerous queries. We will
    focus on four queries that showcase how graph analytics techniques can provide
    insights into healthcare referral network behavior. The following is a brief description
    of these four queries. Then we’ll dive into more details of how each query works.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 医疗转诊网络入门套件包含众多查询。我们将专注于展示图分析技术如何提供医疗保健转诊网络行为洞察的四个查询。以下是这四个查询的简要描述。然后我们将深入探讨每个查询的工作细节。
- en: Get common patients
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 获取共同的患者
- en: Given two doctors, find all patients that these doctors have in common.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两位医生，找出这些医生共同的所有患者。
- en: Infer the referral network
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 推断转诊网络
- en: The source data does not explicitly specify referrals. This analysis infers
    referrals by looking for situations where a **`Patient`** had a **`Claim`** submitted
    by one **`Prescriber`** and then another **`Claim`** submitted by a different
    **`Prescriber`** within a limited amount of time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 源数据并未明确指定转诊。这项分析通过查找一个`**患者**`由一个`**处方者**`提交了一个`**索赔**`，然后由另一个不同的`**处方者**`在有限的时间内提交了另一个`**索赔**`来推断转诊。
- en: Find influential doctors
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 查找有影响力的医生
- en: It’s easy to see which doctors receive the most referrals, but which doctors
    are the most *influential*? Influence is a more subtle concept than just the number
    of referrals. There are multiple ways to define *influence*. This analysis uses
    the PageRank algorithm’s concept of influence to find the most influential **`Prescribers`**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 易于看出哪些医生接收了最多的转诊，但哪些医生影响力最大？影响力比仅仅转诊数量更加微妙。有多种方法来定义**影响力**。本分析使用PageRank算法的影响力概念来找出最具影响力的**`处方医师`**。
- en: Find referral communities
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 查找转诊社群
- en: Looking at the referral graph as a social network, what communities do we see?
    That is, which **`Prescribers`** are closely affiliated with other **`Prescribers`**
    due to referral relationships? This analysis looks not only at the presence of
    one-to-one relationships but also at how groups of providers might be closely
    affiliated.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将转诊图看作社交网络，我们能看到哪些社群？也就是说，哪些**`处方医师`**由于转诊关系而紧密联系？该分析不仅考虑一对一关系的存在，还考虑了如何将提供者组合紧密联系在一起。
- en: Get common patients
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取共同的患者
- en: The query `get_common_patients` takes two `**Prescriber**` vertices as input
    parameters and finds each `**Patient**` that has a `**Claim**` with these two
    doctors. For example, [Figure 7-2](#common_patients_between_doctors_douglas) illustrates
    the query output if we used the suggested inputs of prescribers Douglas Thomas
    and Helen Su. The query not only discovers that they have five patients in common
    but also shows why the patients are seeing the doctors. Note that we are not requiring
    that this reflect a referral relationship. A person could be seeing the two doctors
    for unrelated reasons, such as an ulcer and a broken bone. Nevertheless, this
    information is helpful for several reasons. Providers can compare the number of
    common patients to what they expect. They can also look at the overall characteristics
    of the set of common patients. Is there anything noteworthy or unusual about the
    demographics or health profiles of these common patients? Are there indirect referrals
    in which there is no referral edg, but the patient would have received better
    care if a direct referral had been made?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 查询`get_common_patients`以两个**`处方医师`**顶点作为输入参数，并找到每个具有这两位医生`**声明**`的`**患者**`。例如，如果我们使用建议的输入，即处方医师道格拉斯·托马斯和海伦·苏，[图7-2](#common_patients_between_doctors_douglas)说明了查询的输出。该查询不仅发现他们有五名共同患者，还显示了患者为何看这两位医生。请注意，我们不要求这反映转诊关系。一个人可能因为溃疡和骨折等不相关的原因看这两位医生。尽管如此，这些信息对几个原因都很有帮助。提供者可以比较共同患者的数量与他们的预期。他们还可以查看共同患者群体的整体特征。这些共同患者的人口统计学或健康状况是否有显著或不寻常的地方？是否存在间接转诊，即没有转诊边缘，但如果进行直接转诊，患者可能会得到更好的护理？
- en: '![Common patients between doctors Douglas Thomas and Helen Su](assets/gpam_0702.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![道格拉斯·托马斯和海伦·苏医生之间的常见患者](assets/gpam_0702.png)'
- en: Figure 7-2\. Common patients between doctors Douglas Thomas and Helen Su (see
    a larger version of this figure at [https://oreil.ly/gpam0702](https://oreil.ly/gpam0702))
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-2。道格拉斯·托马斯和海伦·苏医生之间的常见患者（请查看该图更大的版本：[https://oreil.ly/gpam0702](https://oreil.ly/gpam0702)）
- en: The `get_common_patients` query is implemented in six steps. The first four
    steps find the common patients, and the last two steps gather the connecting vertices
    and edges so that we can display the connectivity. You may find it helpful to
    refer to this figure as we walk through the computation steps.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_common_patients`查询实施了六个步骤。前四步找到共同患者，最后两步收集连接的顶点和边，以便我们可以显示连接性。在我们计算步骤时，参考这个图可能会有所帮助。'
- en: 'The first step is to collect all the claims associated with the first `**Prescriber**`
    by traversing over the `submitted_by` edge type. To remember which vertices we’ve
    traversed to, we mark `@visited` to `true` for each visited `**Claim**`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是通过遍历`submitted_by`边类型收集与第一个**处方医师**相关联的所有声明。为了记住我们已经遍历过的顶点，我们对每个已访问的**声明**标记`@visited`为`true`：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In our example, if Douglas Thomas is Prescriber 1, then `claims1` will include
    vertices c10005, c0007, c0009, c10011, and c10013\. It could include more than
    these. Those other vertices will get filtered out in a later stage.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，如果道格拉斯·托马斯是**处方医师1**，那么`claims1`将包括顶点c10005、c0007、c0009、c10011和c10013。可能会包括更多。这些其他顶点将在后期阶段被过滤掉。
- en: 'Then, in the next step we find the linked `**Patient**` elements for each `**Claim**`.
    Again, we use `@visited` to mark the vertices that we use. In this case, these
    are `**Patient**` vertices:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在下一步中，我们为每个`**Claim**`找到链接的`**Patient**`元素。同样，我们使用`@visited`来标记我们使用的顶点。在这种情况下，这些是`**Patient**`顶点：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Continuing with our example of Douglas Thomas, this step would find `**Patient**`
    p1003, p1004, p1005, p1006, and p1007\. Again, it might find more, but these will
    be filtered out later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的例子，对于Douglas Thomas，这一步会找到`**Patient**` p1003, p1004, p1005, p1006 和 p1007。可能会找到更多，但稍后会被过滤掉。
- en: 'In the third step, we do the same as in the first step, but now we collect
    the `**Claim**` elements for the second `**Prescriber**`. This would find the
    six claims in the lower part of [Figure 7-2](#common_patients_between_doctors_douglas):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们与第一步相同，但现在收集第二个`**Prescriber**`的`**Claim**`元素。这会找到[图 7-2](#common_patients_between_doctors_douglas)下部分的六个索赔：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the fourth step we do the same as in the second step, but now we start traversing
    from the `**Claim**` elements found in the third step, and we use a `WHERE` condition
    to include only the `**Patient**` vertices that have been visited before. Any
    `**Patient**` that has been visited already must be a patient of the first `**Prescriber**`,
    so we know this `**Patient**` is a common patient. This is the filtering stage
    that we mentioned before:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步中，我们与第二步相同，但现在我们从第三步中找到的`**Claim**`元素开始遍历，并使用`WHERE`条件仅包括之前已访问过的`**Patient**`顶点。任何之前已访问过的`**Patient**`必定是第一个`**Prescriber**`的患者，因此我们知道这个`**Patient**`是共同患者。这是我们之前提到的过滤阶段：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the fifth step, we select each `**Claim**` from common `**Patient**` elements
    and collect their edges using the `**associated**` edge type. We store these edges
    in `@@edges_to_display`. We will gather more edges in the last step:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在第五步中，我们从通用的`**Patient**`元素中选择每个`**Claim**`，并使用`**associated**`边类型来收集它们的边。我们将这些边存储在`@@edges_to_display`中。在最后一步中，我们会收集更多的边：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we collect all edges between the `**Claim**` elements found in the
    fifth step and the two `**Prescriber**` elements. We store those edges in `@@edges_to_display`
    and print them:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们收集在第五步中找到的`**Claim**`元素与两个`**Prescriber**`元素之间的所有边。我们将这些边存储在`@@edges_to_display`中并打印它们：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Infer the referral network
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推断转诊网络
- en: The source data does not explicitly include **`referral`** edges, so we create
    a query to infer when there was a referral and then insert a **`referral`** edge
    into the graph. If a patient visited Prescriber 1 at Time A and then visited Prescriber
    2 a little while later at Time B, it may be due to a referral. The query parameter
    `max_days` sets the upper limit for the number of days between two doctor visits
    that will be considered a referral. The query has a default value of 30 days.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 源数据没有明确包含**`referral`**边，因此我们创建一个查询来推断何时有转诊，然后将一个**`referral`**边插入图中。如果患者在时间点A访问了Prescriber
    1，然后在稍后的时间点B访问了Prescriber 2，这可能是由于转诊。查询参数`max_days`设置了两次医生访问之间被视为转诊的最大天数上限，默认值为30天。
- en: 'There are a couple of reasons why this time sequence might *not* be due to
    a referral:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因可能导致这种时间顺序*不是*由转诊引起：
- en: Both Prescriber 1 and Prescriber 2 are treating aspects of the same condition
    of the patient, but Prescriber 1 did not make the suggestion to see Prescriber
    2.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prescriber 1和Prescriber 2都在治疗患者相同病症的不同方面，但Prescriber 1没有建议患者去看Prescriber 2。
- en: The visit to Prescriber 2 is unrelated to the visit to Prescriber 1.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Prescriber 2的访问与对Prescriber 1的访问无关。
- en: To make these distinctions between true and false referrals would require more
    information than we have in our dataset.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要区分真实转诊和错误转诊需要比我们数据集中拥有的更多信息。
- en: 'The query `infer_all_referrals` merely calls `infer_referrals`, once for each
    `**Pre⁠scriber**` vertex. `infer_referrals` does the real work:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 查询`infer_all_referrals`仅仅调用`infer_referrals`，每次对每个`**Pre⁠scriber**`顶点调用一次。`infer_referrals`才是真正的工作：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Figure 7-3](#graph_traversal_example_for_infer_refer) shows an example of
    the graph traversal flow in the `infer_referrals` query. There are four hops to
    get from `input_prescriber` D1 to another `**Prescriber**` D2\. These correspond
    to the four `SELECT` statements described in [Figure 7-3](#graph_traversal_example_for_infer_refer).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-3](#graph_traversal_example_for_infer_refer)展示了在`infer_referrals`查询中进行图遍历的示例流程。从`input_prescriber`
    D1到另一个`**Prescriber**` D2需要四次跳转。这对应于[图 7-3](#graph_traversal_example_for_infer_refer)中描述的四个`SELECT`语句。'
- en: '![Graph traversal example for infer_referrals query](assets/gpam_0703.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![推断参考查询的图遍历示例](assets/gpam_0703.png)'
- en: Figure 7-3\. Graph traversal example for `infer_referrals` query
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-3\. `infer_referrals` 查询的图遍历示例
- en: 'The `infer_referrals` query takes two input parameters: `input_prescriber`,
    a vertex of type `**Prescriber**`; and the integer value `max_days`. Starting
    from `input_prescriber`, the query selects all `**Claim**` elements related to
    the input prescriber by traversing the edge type **`submitted_by`**. From there,
    it finds all `**Patient**` vertices that belong to that `**Claim**` set by selecting
    the edge type `**associated**`. In [Figure 7-3](#graph_traversal_example_for_infer_refer),
    these two steps correspond to going from Adam (the input prescriber) to `**Patient**`
    Cor.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`infer_referrals` 查询接受两个输入参数：`input_prescriber`，类型为 `**Prescriber**` 的顶点；以及整数值
    `max_days`。从 `input_prescriber` 开始，查询通过遍历边类型 **`submitted_by`** 选择与输入开药人相关的所有
    `**Claim**` 元素。从那里，它通过选择边类型 `**associated**` 找到所有属于那个 `**Claim**` 集合的 `**Patient**`
    顶点。在 [Figure 7-3](#graph_traversal_example_for_infer_refer) 中，这两个步骤对应于从 Adam（输入开药人）到
    `**Patient**` Cor。'
- en: 'Notice that patient Cor has multiple claims from a single prescriber (Adam).
    The date of a claim is a key factor in deciding whether there is a referral or
    not, so we need to pay attention to each individual date. The following GSQL code
    snippet shows the first two hops from `input_prescriber` to their patients, including
    collecting the dates of each patient’s claims in a `@date_list` accumulator:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，患者 Cor 从同一个开药人（Adam）那里有多个索赔。索赔的日期是决定是否有转诊的关键因素，因此我们需要注意每个单独的日期。以下的 GSQL 代码片段展示了从
    `input_prescriber` 到他们的患者的前两跳，包括收集每个患者索赔日期的 `@date_list` 累加器：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we want to find the claims made by other prescribers for these patients.
    The clause `WHERE t.@visited == false` in the following code ensures that these
    other claims are different from the ones we looked at before. We then compare
    the date of a claim encountered in this step against the dates of claims in the
    Patient’s `@date_list`. If the time difference is less than `max_days`, we mark
    this new claim as a referral (earlier in the query, we converted `max_days` to
    `max_seconds`):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要找出其他开药人为这些患者提出的索赔。以下代码中的 `WHERE t.@visited == false` 子句确保这些其他索赔与我们之前查看过的不同。然后我们比较此步骤中遇到的索赔日期与患者的
    `@date_list` 中的索赔日期。如果时间差小于 `max_days`，我们将此新索赔标记为转诊（在查询的前面，我们将 `max_days` 转换为
    `max_seconds`）：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we find the `**Prescriber**` vertices associated with the marked claims
    and use an `INSERT` statement to create the edges. For informational purposes,
    we count the number of inserted edges with the `@@num_referrals_created` accumulator.
    In GSQL, graph updates are not committed until the end of the query. Therefore,
    it would not work to count the number of `**referral**` edges within this query
    directly. We could only perform such a count in a subsequent query:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们查找与标记索赔相关的 `**Prescriber**` 顶点，并使用 `INSERT` 语句创建边。出于信息目的，我们使用 `@@num_referrals_created`
    累加器计算插入的边数。在 GSQL 中，图更新直到查询结束前才会提交。因此，在此查询中直接计算 `**referral**` 边的数量是行不通的。我们只能在随后的查询中执行这样的计数：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Lastly, we `RETURN @@num_referrals_created`, sending data back to the query
    that called this one. The caller query (`infer_all_referrals`) adds together each
    returned value for each `**Prescriber**` to compute the total number of edges
    created for the entire graph.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `RETURN @@num_referrals_created` 将数据发送回调用此查询的查询。调用者查询（`infer_all_referrals`）为每个
    `**Prescriber**` 返回的每个返回值相加，以计算整个图中创建的边的总数。
- en: Subqueries in GSQL
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GSQL 中的子查询
- en: A query can be defined as a subquery by using `RETURNS` `(<data_type>)` in the
    header and `RETURN <value>` at the end of the query. Besides returning a value,
    a subquery can have graph modification side effects (e.g., inserting edges). `PRINT`
    statements in subqueries do not print to the console; an alternative is to write
    to a file with `PRINTLN` or `LOG`. See TigerGraph’s [GSQL Language Reference](https://oreil.ly/Q7U-D)
    for more details.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在头部使用 `RETURNS` `(<data_type>)` 并在查询末尾使用 `RETURN <value>` 来定义查询作为子查询。除了返回值之外，子查询还可以具有图修改的副作用（例如插入边）。子查询中的
    `PRINT` 语句不会打印到控制台；一个替代方法是使用 `PRINTLN` 或 `LOG` 将内容写入文件。更多详细信息，请参阅 TigerGraph 的
    [GSQL 语言参考](https://oreil.ly/Q7U-D)。
- en: Find influential doctors
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 找出有影响力的医生
- en: This query finds the most influential specialists. An influential specialist
    is considered an authority. They not only receive a lot of referrals but also
    work on the important cases. If they were to drop out of the graph suddenly, the
    impact would be significant. Analysis of relative influence can help doctors understand
    their relative importance and see if they can improve it. Healthcare administrators
    can take a holistic look to see if they can reduce overdependence on individuals
    and provide more balanced care to patients while reducing costs. Epidemiologists,
    pharmaceutical companies, and medical equipment vendors may also want to know
    which doctors are the most influential.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询查找最具影响力的专家。一个具有影响力的专家被视为权威。他们不仅接受了很多转诊，而且处理重要病例。如果他们突然从图中退出，影响将是显著的。相对影响力分析可以帮助医生了解他们的相对重要性，并看看是否可以提高它。医疗管理人员可以全面考虑，看看是否可以减少对个人的过度依赖，并为患者提供更平衡的护理，同时降低成本。流行病学家、制药公司和医疗设备供应商也可能想知道哪些医生最具影响力。
- en: Fortunately for us, a well-known graph algorithm measures influence in this
    way, considering both the number and relative importance of incoming edges. The
    *PageRank* *algorithm*, developed by Google founders Larry Page and Sergey Brin,
    ranks a web page based on how many other pages are linking it and the rank of
    these other pages. We can look at the influence of doctors in a referral network
    in a similar way. A doctor’s influence increases if they receive more referrals
    or if the influence of those referrers increases.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一个著名的图算法通过这种方式衡量影响力，考虑了传入边的数量和相对重要性。由Google创始人Larry Page和Sergey Brin开发的*PageRank*
    *算法*根据指向它的其他页面数量和这些其他页面的等级来排名网页。我们可以类似地查看转诊网络中医生的影响力。如果医生接收的转诊更多，或者这些转诊者的影响力增加，医生的影响力就会增加。
- en: An implementation of the PageRank algorithm (`tg_pagerank`) is included in TigerGraph’s
    GDS Library. The algorithm is included in this starter kit for convenience, but
    installing library algorithms into your database instance is a simple process.
    Unlike other GSQL algorithms we have seen that were written for a specific graph
    schema in a specific starter kit, this algorithm is general purpose. It has 10
    input parameters (shown in [Table 7-2](#input_parameters_for_tg_pagerank_librar)),
    but 8 of them have default values. We only need to set the first 2\. In our case,
    we set `v_type` `=` `**Prescriber**` and `e_type` `=` `**referral**`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: TigerGraph的GDS库中包含了*PageRank*算法（`tg_pagerank`）的实现。这个算法包含在这个起始套件中以方便使用，但将库算法安装到您的数据库实例中是一个简单的过程。与我们看到的其他为特定图架构和特定起始套件编写的GSQL算法不同，这个算法是通用的。它有10个输入参数（在[表7-2](#input_parameters_for_tg_pagerank_librar)中显示），但其中8个具有默认值。我们只需要设置前两个。在我们的案例中，我们设置`v_type`
    `=` `**Prescriber**`和`e_type` `=` `**referral**`。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: Inside GraphStudio, the GSQL GDS Library is available in the New Query window.
    With a graph selected, choose “Write Queries” in the left sidebar, then click
    the green ⨁ button to add a new query to the list of installed and saved queries.
    Click “Choose from library” in the new window that appears. Hover over the question
    mark icon next to any query for a brief explanation of its purpose.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphStudio中，GSQL GDS库可在新查询窗口中使用。选择一个图后，在左侧边栏中选择“编写查询”，然后点击绿色的⨁按钮将新查询添加到已安装和已保存查询列表中。在新弹出的窗口中点击“从库中选择”。将鼠标悬停在任何查询旁边的问号图标上，可以简要了解其目的。
- en: Table 7-2\. Input parameters for `tg_pagerank` library algorithm
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表7-2\. `tg_pagerank`库算法的输入参数
- en: '| Parameter | Default value | Description |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 默认值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `v_type` |   | Name of vertex type to use. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `v_type` |   | 要使用的顶点类型的名称。 |'
- en: '| `e_type` |   | Name of edge type to use. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `e_type` |   | 要使用的边类型的名称。 |'
- en: '| `max_change` | 0.001 | Stop iterating when the interim PageRank scores are
    stable, changing less than 0.001. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `max_change` | 0.001 | 当中间PageRank分数稳定时（变化小于0.001）停止迭代。 |'
- en: '| `max_iter` | 25 | Stop iterating if we have computed interim PageRank scores
    this many times. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `max_iter` | 25 | 如果我们已经计算了这么多次的中间PageRank分数，则停止迭代。 |'
- en: '| `damping` | 0.85 | Relative importance of neighbors versus random movement
    (between unconnected vertices). Some random movement is needed for stability.
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `damping` | 0.85 | 相邻节点相对于随机移动（在未连接顶点之间）的相对重要性。对于稳定性来说，需要一些随机移动。 |'
- en: '| `top_k` | 100 | Number of top scores to print in the output. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `top_k` | 100 | 在输出中打印的前K个分数的数量。 |'
- en: '| `print_accum` | TRUE | Print the output in JSON format. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `print_accum` | TRUE | 以JSON格式打印输出。 |'
- en: '| `result_attr` | FALSE | Store the results as vertex attributes. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `result_attr` | FALSE | 将结果存储为顶点属性。 |'
- en: '| `file_path` | *empty string* | Write the results in tabular format to this
    file. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `file_path` | *空字符串* | 将结果以表格格式写入此文件。 |'
- en: '| `display_edges` | FALSE | Include edges of interest in the output. If the
    algorithm is run on GraphStudio, selecting this option causes a better visual
    display. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `display_edges` | FALSE | 在输出中包含感兴趣的边缘。如果在GraphStudio上运行该算法，并选择此选项，会导致更好的视觉显示。
    |'
- en: The next three parameters after `e_type` are specific to PageRank. The last
    five parameters are general purpose and appear in many or most GSQL algorithms
    in the GDS Library. They deal with the way the query output is printed to the
    console and/or exported to a file. `result_attr` is a way to store the PageRank
    results in the graph as a vertex attribute so that later queries can make use
    of this algorithm’s results in their own calculations. The `display_edges` parameter
    specifies whether the output should include edges that are helpful to visualize
    the results. For example, if the `get_common_patients` query were to add this
    parameter, it would specify whether steps 5 and 6 should execute.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`e_type`之后的三个参数是PageRank特有的。最后五个参数是通用的，并且出现在GDS库中许多或大多数算法中。它们处理查询输出在控制台打印和/或导出到文件的方式。`result_attr`是一种将PageRank结果存储为图的顶点属性的方式，以便稍后的查询可以在其自己的计算中使用该算法的结果。`display_edges`参数指定输出是否应包含有助于可视化结果的边。例如，如果`get_common_patients`查询要添加此参数，它将指定是否应执行步骤5和6。
- en: 'If you run PageRank with parameter settings `v_type =` `**Prescriber**`, `e_type
    =` `**referral**`, and `top_k` `= 5`, you should get the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`v_type =` `**Prescriber**`，`e_type =` `**referral**`和`top_k` `= 5`设置运行PageRank，您应该得到以下输出：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Find a referral community
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找推荐社区
- en: This query detects communities within a referral network. A community is a set
    of vertices that are highly connected to one another while having sparse relationships
    with the rest of the graph. In a referral network, communities arise through dense
    connections among doctors, patients, and healthcare providers when they interact
    with one another. They form a group together because of their many interactions
    with one another. Detecting communities can help doctors to identify the spread
    of their referrals within a network and make better referrals for their patients.
    Healthcare managers can investigate the communities to evaluate the local healthcare
    systems.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询检测推荐网络中的社区。社区是一组高度相互连接的顶点，与图的其余部分之间的关系稀疏。在推荐网络中，社区通过医生、患者和医疗服务提供者之间的密集连接而产生，当它们相互作用时形成一个组。它们因为彼此之间的许多互动而形成一个群体。检测社区可以帮助医生识别他们在网络中推荐的传播，并为他们的患者做出更好的推荐。医疗管理人员可以调查社区以评估当地的医疗系统。
- en: A widely popular graph algorithm to detect communities is the Louvain algorithm,
    which we mentioned in [Chapter 6](ch06.html#analyzing_connections_for_deeper_insigh).
    This algorithm, developed by Vincent Blondel of the University of Louvain, chooses
    graph communities by trying to optimize^([3](ch07.html#ch01fn19)) the relative
    density of edges inside a community, known as *modules*, versus the edges outside
    the modules. A key feature of the Louvain method is that it does not have a fixed
    number of communities to detect as an input parameter, making it advantageous
    for practical applications like those where the number of communities to detect
    is not known at the outset. It starts with detecting small modules and then groups
    them together into larger modules whenever that improves the modularity score.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一种广受欢迎的检测社区的图算法是Louvain算法，我们在[第6章](ch06.html#analyzing_connections_for_deeper_insigh)中提到过。这种算法由洛汉大学的Vincent
    Blondel开发，通过优化社区内边的相对密度（称为*模块*）与模块外边的边来选择图社区。Louvain方法的一个关键特点是它没有固定的输入参数来检测社区数量，这使得它在实际应用中具有优势，例如在那些初始时不知道要检测的社区数量的情况下。它从检测小模块开始，然后在能够提高模块性评分时将它们组合成较大的模块。
- en: The Louvain algorithm (`tg_louvain`) is included in the Healthcare – Referral
    Networks, Hub & Community Detection Starter Kit. It has eight input parameters
    (shown in [Table 7-3](#input_parameters_for_tg_louvain_library)). The vertex type
    (`**Prescriber**`) and edge type (`**referral**`, in both forward and reverse
    directions) have been hardcoded into the query. There is no need to adjust any
    of the parameters, though you might experiment with increasing the `output_level`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在健康护理-转诊网络，枢纽和社区检测入门套件中的Louvain算法（`tg_louvain`）。它有八个输入参数（在[表 7-3](#input_parameters_for_tg_louvain_library)中显示）。顶点类型（**Prescriber**）和边类型（**referral**，在正向和反向方向上）已经硬编码到查询中。无需调整任何参数，尽管您可以尝试增加`output_level`。
- en: Table 7-3\. Input parameters for `tg_louvain` library algorithm
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 表7-3. `tg_louvain`库算法的输入参数
- en: '| Parameter | Default value | Description |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 默认值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `iter1` | 10 | Maximum iterations for move. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `iter1` | 10 | 移动的最大迭代次数。 |'
- en: '| `iter2` | 10 | Maximum iterations for merge. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `iter2` | 10 | 合并的最大迭代次数。 |'
- en: '| `iter3` | 10 | Maximum iterations for refine. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `iter3` | 10 | 优化的最大迭代次数。 |'
- en: '| `split` | 10 | Number of data batches, to reduce peak memory consumption.
    `split`=1 processes the whole graph at once. `split`=10 processes the graph in
    10 batches. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `split` | 10 | 数据批次数，以减少内存峰值消耗。`split`=1一次处理整个图。`split`=10将图分为10批次处理。 |'
- en: '| `output_level` | 0 | If 0: JSON output is statistics about communities. If
    1: also output the community IDs indexed by cluster size.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '| `output_level` | 0 | 如果为0：JSON输出是有关社区的统计信息。如果为1：还输出按群集大小索引的社区ID。'
- en: 'If 2: also output the membership of each community. |'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为2：还输出每个社区的成员资格。
- en: '| `print_accum` | TRUE | Print the output in JSON format. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `print_accum` | TRUE | 以JSON格式打印输出。 |'
- en: '| `result_attr` | FALSE | Store the results as vertex attributes. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `result_attr` | FALSE | 将结果存储为顶点属性。 |'
- en: '| `file_path` | *empty string* | Write the results in tabular format to this
    file. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `file_path` | *空字符串* | 将结果以表格格式写入此文件。 |'
- en: 'Run the query with default settings. With more than 11,000 vertices, it is
    difficult to visualize the results, so we will examine the JSON output. The first
    three sections of the JSON output are shown belows. The first section tells us
    that the algorithm grouped the vertices into 17 communities. The second section
    says the largest community has 11,055 members. The next largest community has
    only 10 members. The third section says that the community with `id` = 0 is the
    one with 11,055 members, community 68157440 has 6 members, and so on. Because
    this is a heuristic algorithm, you might get slightly different community sizes
    and qualities. The community IDs may certainly differ:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认设置运行查询。超过11,000个顶点，难以可视化结果，因此我们将检查JSON输出。JSON输出的前三个部分如下所示。第一部分告诉我们算法将顶点分组为17个社区。第二部分显示最大的社区有11,055个成员。第二大的社区只有10名成员。第三部分显示`id`=0的社区是具有11,055名成员的社区，68157440号社区有6名成员，等等。由于这是一种启发式算法，可能会得到略有不同的社区大小和质量。社区ID可能会有所不同：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Case 2: Personalized Recommendations'
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况2：个性化推荐
- en: Consumers today often have too many choices. They have trouble knowing what
    is available and reaching a decision, and vendors have trouble making sure that
    they are noticed and meeting the consumers’ needs. Recommendation engines have
    become increasingly crucial for guiding users through this jungle of offerings.
    Recommendation engines aim to prevent users from information overload and provide
    them with more personalized information, making the solution’s user experience
    more efficient. An online retailer like Amazon may have hundreds of thousands
    of separate products in the same category. Online retailers offering many products
    benefit from a recommendation engine because it helps shoppers find products of
    interest more quickly and easily. Repeat business also comes from customers who
    are satisfied with a personalized experience that other retailers do not offer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的消费者通常有太多选择。他们很难知道有什么可用并做出决定，而供应商也很难确保他们被注意到并满足消费者的需求。推荐引擎越来越重要，用于引导用户穿过这些产品的丛林。推荐引擎旨在防止用户信息过载，并为他们提供更个性化的信息，使解决方案的用户体验更高效。像亚马逊这样的在线零售商可能在同一类别中拥有数十万个单独的产品。在线零售商提供许多产品，因此受益于推荐引擎，因为它有助于购物者更快速、更轻松地找到感兴趣的产品。重复业务也来自于对个性化体验满意的客户，其他零售商没有提供这种体验。
- en: Traditional recommendation engines provide suggestions of products, content,
    or services to users based on their historical behavior and the behavior of similar
    users. There are a few problems with this approach, however. First, new users
    do not have a history yet, so we cannot make correct suggestions to them at the
    beginning. This is known as the `cold start problem`. Second, when only looking
    into the user’s historical behavior, we are limited to suggesting the same type
    of content repeatedly. The user might miss out on other products, content, and
    services the vendor offers. Finally, making highly personalized recommendations
    is not easily scalable, because as the user base and the level of detail grow,
    the number of persons, products, and factors to consider will grow as well, requiring
    exponentially more comparisons over time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的推荐引擎根据用户的历史行为和相似用户的行为向用户提供产品、内容或服务的建议。然而，这种方法存在一些问题。首先，新用户没有历史记录，因此我们无法在开始时向他们提供正确的建议。这被称为“冷启动问题”。其次，当仅查看用户的历史行为时，我们仅限于重复推荐同类型的内容。用户可能会错过供应商提供的其他产品、内容和服务。最后，制定高度个性化的建议不容易扩展，因为随着用户基数和细节级别的增长，要考虑的人数、产品和因素也会相应增长，随着时间的推移需要指数级别的更多比较。
- en: To combat these issues, we need a recommendation engine that maintains and processes
    up-to-date information in near real time. It must also not rely on batch processing.
    Another requirement is to be fast and scalable to millions of users and products.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们需要一个推荐引擎，能够几乎实时地维护和处理最新的信息，且不依赖批处理。另一个要求是速度快且能够扩展到数百万用户和产品。
- en: 'Solution: Use Graph for Multirelationship-Based Recommendations'
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案：使用图进行基于多关系的推荐
- en: Making recommendations to users of an application is, in essence, discovering
    connections or similarities. Purchasing a product is a connection between a consumer
    and a product, and there are also connections among a consumer, a product, and
    their respective features. If two persons have similar tastes, that similarity
    is a type of connection, and products that are often purchased together likewise
    share a connection. These connections arise once users interact with the application,
    and recommendation is a form of analyzing these connections. Collectively, these
    connections form a graph. By modeling the data as a graph, we can query right
    on the graph-structured data without making large join operations on batch data.
    Therefore, a graph is a natural and flexible way to represent these connections.
    Organizing the relationships in such a way makes adding, modifying, and removing
    data easy and the application highly scalable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序向用户推荐产品，本质上是发现连接或相似性。购买产品是消费者和产品之间的一种连接，而消费者、产品及其特征之间也存在连接。如果两个人有相似的喜好，那么这种相似性就是一种连接，经常一起购买的产品也分享同样的连接。这些连接是用户与应用程序互动后产生的，推荐是分析这些连接的一种形式。总体而言，这些连接形成了一个图。通过将数据建模为图，我们可以直接在图结构数据上进行查询，而无需在批处理数据上进行大型连接操作。因此，图是表示这些连接的一种自然且灵活的方式。以这种方式组织关系使得添加、修改和删除数据变得简单，并使应用程序具有高可扩展性。
- en: 'Another benefit of using graphs for a recommendation engine is to prevent a
    cold start for the user. Because a graph model is a single interconnected system,
    we can populate the starting user experience with a mix of recommendation techniques:
    content associated with the new user’s demographic information; content-based,
    collaborative filtering; and vendor promotion. In a graph, these techniques can
    be implemented using pattern matching and similarity scoring. Moreover, adding
    more data, adding more relationships, and revising the recommendation scheme is
    straightforward.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图进行推荐引擎的另一个好处是避免用户的冷启动问题。因为图模型是一个单一的互连系统，我们可以使用混合的推荐技术来填充初始用户体验：与新用户的人口统计信息相关联的内容；基于内容的、协同过滤的推荐；以及供应商促销。在图中，这些技术可以通过模式匹配和相似性评分来实现。此外，增加更多数据、建立更多关系和修订推荐方案都变得非常简单。
- en: Implementing a Multirelationship Recommendation Engine
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施多关系推荐引擎
- en: TigerGraph offers a starter kit to demonstrate how graph analytics can derive
    customer product recommendations. The starter kit can be installed by following
    the steps in [Chapter 3](ch03.html#see_your_customers_and_business_better).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: TigerGraph提供了一个入门套件，展示了如何利用图分析生成客户产品推荐。可以通过按照[第三章](ch03.html#see_your_customers_and_business_better)中的步骤安装这个入门套件。
- en: The Recommendation Engine 2.0 Starter Kit
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推荐引擎2.0入门套件
- en: Deploy a new TigerGraph Cloud instance, selecting “Recommendation Engine 2.0
    (Hyper-Personalized Marketing)” as the starter kit. Launch it and load the data
    following the steps in the section [“Load data and install queries for a starter
    kit”](ch03.html#load_data_and_install_queries_for_a_sta) in [Chapter 3](ch03.html#see_your_customers_and_business_better).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 部署一个新的TigerGraph Cloud实例，选择“推荐引擎2.0（超个性化营销）”作为入门套件。按照第三章的[“加载数据和安装查询入门套件”](ch03.html#load_data_and_install_queries_for_a_sta)中的步骤加载数据。
- en: Graph Schema
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图模式
- en: '[Figure 7-4](#graph_schema_for_the_recommendation_eng) shows the graph schema
    of this starter kit, which contains six vertex types and seven edge types.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-4](#graph_schema_for_the_recommendation_eng)展示了这个入门套件的图模式，包含六种顶点类型和七种边类型。'
- en: '![Graph schema for the Recommendation Engine 2.0](assets/gpam_0704.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![推荐引擎2.0的图模式](assets/gpam_0704.png)'
- en: Figure 7-4\. Graph schema for the Recommendation Engine 2.0 (see a larger version
    of this figure at [https://oreil.ly/gpam0704](https://oreil.ly/gpam0704))
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-4\. 推荐引擎2.0的图模式（查看此图的更大版本，请访问[https://oreil.ly/gpam0704](https://oreil.ly/gpam0704)）
- en: '[Table 7-4](#vertex_types_in_the_recommendation_engi) describes the vertex
    types. A `**Demographic**` vertex refers to the demographic properties of a `**Customer**`.
    A `**Customer**` is a natural person who has an account in our web shop. Furthermore,
    each `**Customer**` has a `**History**` of buying a `**Product**`. A `**Feature**`
    can be a characteristic of a `**Demographic**`, `**Customer**`, or a `**Product**`
    vertex. With `**Context**`, we add a contextual layer to our queries with time
    constraints or weather conditions.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-4](#vertex_types_in_the_recommendation_engi)描述了顶点类型。`**人口统计学**`顶点指的是`**顾客**`的人口统计属性。`**顾客**`是我们网店中有账户的自然人。此外，每个`**顾客**`都有购买`**产品**`的`**历史**`。`**特征**`可以是`**人口统计学**`、`**顾客**`或`**产品**`顶点的特征。通过`**上下文**`，我们为我们的查询添加了一个具有时间约束或天气条件的上下文层。'
- en: Table 7-4\. Vertex types in the Recommendation Engine 2.0 graph model
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-4\. 推荐引擎2.0图模型中的顶点类型
- en: '| Vertex type | Description |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 顶点类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `**Customer**` | A natural person |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `**顾客**` | 一个自然人 |'
- en: '| `**Demographic**` | A demographic property of a `**Customer**` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `**人口统计学**` | 一个`**顾客**`的人口统计属性 |'
- en: '| `**History**` | A buying history of a `**Customer**` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `**历史**` | 一个`**顾客**`的购买历史 |'
- en: '| `**Product**` | A product |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `**产品**` | 一个产品 |'
- en: '| `**Feature**` | A feature of a `**Customer**` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `**特征**` | 一个`**顾客**`的特征 |'
- en: '| `**Context**` | A contextual constraint |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `**上下文**` | 一个上下文约束 |'
- en: In our simplified example, each `**Context**` vertex has an ID value, which
    is a word or phrase that describes its characteristic. In a real-world example,
    the schema would probably categorize the data into different types of context,
    such as location, date, weather, and so on, but we have lumped them all together
    into one attribute.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们简化的示例中，每个`**上下文**`顶点都有一个ID值，这是描述其特征的单词或短语。在真实世界的示例中，模式可能会将数据分类到不同类型的上下文中，例如位置、日期、天气等，但我们将它们全部
    lumped 到一个属性中。
- en: Some of the edge types have weight attributes. The `**product_feature**` edge
    type has an attribute simply called `weight`. A high `weight` means that feature
    is an important aspect of that product. The `**customer_feature**` edge type has
    an attribute called `affinity`. A high affinity means there is a strong association
    between that feature and the customer’s desires. We can use these weights to compute
    how strongly a customer will prefer a product, that is, to make a feature-based
    recommendation. A standard approach is to multiply the `**product_feature**` `weight`
    by the `**customer​_​fea⁠ture**` `affinity`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一些边类型具有权重属性。`**产品特征**`边类型有一个称为`weight`的属性。高`weight`意味着该特征是该产品的重要方面。`**顾客特征**`边类型具有一个称为`affinity`的属性。高亲和力意味着该特征与顾客的需求之间有很强的关联。我们可以使用这些权重来计算顾客对产品的偏好程度，即基于特征的推荐。一个标准的方法是将`**产品特征**`的`weight`乘以`**顾客特​_​fea⁠ture**`的`affinity`。
- en: The graph in this starter kit is intentionally very small to make it easy to
    follow the calculations. The entire graph is shown in [Figure 7-5](#recommendation_graph).
    From top to bottom, the vertex types are `**Customer**`, `**Demographic**`, `**Feature**`,
    `**Product**`, and `**Context**`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个入门套件中的图表故意设计得非常小，以便于跟踪计算。整个图表在[图 7-5](#recommendation_graph)中显示。从上到下，顶点类型分别为`**顾客**`、`**人口统计学**`、`**特征**`、`**产品**`和`**上下文**`。
- en: '![Recommendation graph](assets/gpam_0705.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![推荐图](assets/gpam_0705.png)'
- en: Figure 7-5\. Recommendation graph (see a larger version of this figure at [https://oreil.ly/gpam0705](https://oreil.ly/gpam0705))
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-5\. 推荐图（请查看此图的更大版本：[https://oreil.ly/gpam0705](https://oreil.ly/gpam0705)）
- en: Queries and Analytics
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询与分析
- en: The Recommendation Engine 2.0 Starter Kit includes three queries that show how
    recommendation engines can be improved using graph analytics. They allow us to
    select top-ranked products while considering the **`Context`** and **`Feature`**
    elements of the `**Customer**`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐引擎 2.0 入门套件包括三个查询，展示了如何使用图分析改进推荐引擎。它们允许我们选择考虑 **上下文** 和 **特征** 元素的排名前列产品。
- en: Recommend by features and context
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 按特征和上下文推荐
- en: Return the `top_k` products for `source_customer` while taking into account
    `weather` and `time_of_day`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑 `weather` 和 `time_of_day` 的情况下，为 `source_customer` 返回 `top_k` 产品。
- en: Recommend products by customer and context
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 根据客户和上下文推荐产品
- en: Recommend the highest-rated product for a customer while taking into account
    the weather and the time of the day.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑天气和一天中的时间的情况下，向客户推荐评分最高的产品。
- en: Get top demographic
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 获取顶级人口统计数据
- en: Display the demographic with the highest average affinity among its customers
    and features related to the demographic.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 显示与其顾客之间的平均亲和力最高的人口统计数据，并显示与该人口统计数据相关的特征。
- en: Recommend by features and context
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按特征和上下文推荐
- en: Given a set of context conditions and a customer, the `recommend_by_​fea⁠tures​_​and_context`
    query returns the products that satisfy the context conditions and have the strongest
    match between their features and the features preferred by the customers. This
    query takes four input parameters. The first parameter, `source_customer`, names
    the `**Customer**` whose top-rated products we would like to know. Then with `weather`
    and `time_of_day` we specify the `**Context**` of our selection, and with `top_k`
    we set how many top-rated products we want to return.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 针对一组上下文条件和一个客户，`recommend_by_​fea⁠tures​_​and_context` 查询返回满足上下文条件且在其特征与客户偏好特征之间具有最强匹配的产品。此查询接受四个输入参数。第一个参数
    `source_customer` 指定我们想要了解其顶级产品的 **客户**。然后，使用 `weather` 和 `time_of_day` 指定我们选择的
    **上下文**，使用 `top_k` 设置我们想要返回的顶级产品数量。
- en: 'The query begins by initializing the vertex set `start` to `source_customer`.
    Next, we count how many context filters the user wants to apply. If the user does
    not want to filter by an input factor (`time_of_day` or `weather`), then the user
    should just leave that input parameter blank. The following code counts the number
    of activated context filters:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 查询从将顶点集 `start` 初始化为 `source_customer` 开始。接下来，计算用户想要应用的上下文过滤器数量。如果用户不希望按照输入因素（`time_of_day`
    或 `weather`）进行过滤，则应将该输入参数留空。以下代码计算激活的上下文过滤器数量：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we find those products that satisfy our context filters. We start by
    initializing `candidate_products` to be all products and `filtered_context` to
    be all contexts. Then, if `min_filters` is not zero, it means that the `**Context**`
    has been set, so we execute our first `SELECT` statement to narrow down `filtered_context`
    to only the elements that match `time_of_day` or `weather`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们找出满足我们上下文过滤器的产品。我们首先将 `candidate_products` 初始化为所有产品，并将 `filtered_context`
    初始化为所有上下文。然后，如果 `min_filters` 不为零，则表示已设置了 **上下文**，因此我们执行第一个 `SELECT` 语句，将 `filtered_context`
    缩小到仅匹配 `time_of_day` 或 `weather` 的元素：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We use another `SELECT` statement to refine `candidate_products` down to only
    those that link to all of our `filtered_context`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用另一个 `SELECT` 语句来将 `candidate_products` 细化到仅链接到所有 `filtered_context` 的产品：
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `ACCUM` clause counts how many context matches each product makes. The `HAVING`
    clause filters the final selection to only include products that match on all
    the specified context parameters. Referring to [Figure 7-5](#recommendation_graph),
    if we set parameters `weather` `= "BW"` and `time_of_day` `= "T2"`, then `candidate_products`
    will be {P004}, the only product that connects to both `filtered_context` vertices.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACCUM` 子句计算每个产品进行了多少次上下文匹配。`HAVING` 子句将最终选择过滤为仅包括在所有指定上下文参数上匹配的产品。参考 [图 7-5](#recommendation_graph)，如果设置参数
    `weather` `= "BW"` 和 `time_of_day` `= "T2"`，则 `candidate_products` 将为 {P004}，即唯一连接到两个
    `filtered_context` 顶点的产品。'
- en: Now we can compute the overall recommendation score between the customer and
    products. We use a two-hop path to find connections between our given `**Customer**`
    and the candidate `**Product**` vertices, with `**Feature**` serving as an intermediary.
    For each selected product that connects to a feature of interest, we multiply
    the `**prod⁠uct​_​feature**` weight by `**customer_feature**` affinity and add
    that to the accumulator `@max_score`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以计算客户和产品之间的总体推荐得分。我们使用两跳路径来查找给定的`**Customer**`和候选`**Product**`节点之间的连接，`**Feature**`作为中介。对于每个连接到感兴趣特征的选择产品，我们将`**prod⁠uct​_​feature**`权重乘以`**customer_feature**`亲和力，并加到累加器`@max_score`中。
- en: 'Adding the contributions of all the relevant features to compute a total score
    would be a valid approach, but that is not what we are actually doing here. `@max_score`
    is defined as a `MaxAccum`, so it preserves the highest value that it is given.
    In other words, we look for the single most important feature and use only that
    one for scoring.^([4](ch07.html#ch01fn20)) Then we use `@max_score` along with
    the SQL-like `ORDER BY` and `LIMIT` clauses to select the `top_k` products with
    the highest recommendation scores:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 添加所有相关特征的贡献来计算总分数是一个有效的方法，但这并不是我们实际正在做的。`@max_score`被定义为`MaxAccum`，因此它保留了给定的最高值。换句话说，我们寻找最重要的单一特征，并仅使用该特征进行评分。^([4](ch07.html#ch01fn20))
    然后我们使用类似 SQL 的`ORDER BY`和`LIMIT`子句与`@max_score`一起选择具有最高推荐得分的`top_k`产品：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Suppose we set `weather` `= "GW"` and `time_of_day` `= "T2"`. Then `candidate_products`
    will be {P004, P002}, as highlighted in [Figure 7-6](#graph_paths_for_recommendation_by_featu).
    (Since `"GW"` connects to every product, it has no filtering effect.) If `source_customer`
    `= C002`, there is only one `Customer-Feature-Product` path to **`candidate_products`**,
    with weight 23.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们设置`weather = "GW"`和`time_of_day = "T2"`。那么`candidate_products`将为{P004, P002}，如[图
    7-6](#graph_paths_for_recommendation_by_featu)中所示（因为`"GW"`连接到每个产品，它没有过滤效果）。如果`source_customer
    = C002`，则只有一条`Customer-Feature-Product`路径到**`candidate_products`**，权重为23。
- en: '![Graph paths for recommendation by features and context](assets/gpam_0706.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![推荐路径按特征和上下文分析](assets/gpam_0706.png)'
- en: Figure 7-6\. Graph paths for recommendation by features and context (see a larger
    version of this figure at [https://oreil.ly/gpam0706](https://oreil.ly/gpam0706))
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-6\. 推荐路径按特征和上下文分析（查看此图的更大版本，请访问[https://oreil.ly/gpam0706](https://oreil.ly/gpam0706)）。
- en: 'To see the scores, switch to the JSON output. Now suppose we set `source_customer`
    `= C001`, `weather` `= GW`, `time_of_day` `= T``2`, and `top_k = 2`. Think about
    what paths you can see from `C001` to `GW` and `T``2` in [Figure 7-6](#graph_paths_for_recommendation_by_featu)
    that lead to the following recommendation scores:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看分数，请切换到 JSON 输出。现在假设我们设置`source_customer = C001`，`weather = GW`，`time_of_day
    = T``2`，以及`top_k = 2`。想想从`C001`到`GW`和`T``2`在[图 7-6](#graph_paths_for_recommendation_by_featu)中可以看到的路径，从而导致以下推荐得分：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Recommend products by customer and context
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推荐产品根据客户和上下文。
- en: Given a set of context conditions and a set of customers, this query returns
    the product that satisfies the context conditions and that has the strongest match
    between its features and the features preferred by the customers. The basic task
    of this query is very similar to that of our first query, recommend by features
    and context, but there are some interesting differences. The first difference
    is that this query accepts a list of any context values (`input_context_set`)
    rather than asking for one weather condition and one time condition. The second
    difference is that it can process multiple input customers (`input_customer_set`)
    instead of a single one. Both of these changes make it more universal. A third
    difference is that it returns only one product. That is because this query shows
    a visual representation of all the connections to `**Customer**` and `**Context**`
    vertices that led to the recommendation. If it selected the top k products, then
    the visual representation would not be as easy to interpret.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 针对一组上下文条件和一组客户，此查询返回满足上下文条件且其特征与客户偏好特征最匹配的产品。此查询的基本任务与我们的第一个查询非常相似，即按特征和上下文推荐，但存在一些有趣的差异。第一个差异是此查询接受任意上下文值列表（`input_context_set`），而不是询问一个天气条件和一个时间条件。第二个差异是它可以处理多个输入客户（`input_customer_set`），而不是单个客户。这两个变化使得它更加通用。第三个差异是它仅返回一个产品。这是因为此查询显示了导致推荐的`**Customer**`和`**Context**`节点的所有连接的视觉表示。如果选择了前
    k 个产品，则视觉表示将不那么容易解释。
- en: 'The query starts by defining a tuple type and several accumulators. The first
    four definitions are to help with sorting products by their average affinity to
    the customers. A `HeapAccum` will automatically sort the tuples given to it. After
    we have our `HeapAccum`, we will need to convert it to a vertex set for further
    processing:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 查询从定义元组类型和多个累加器开始。前四个定义是为了通过它们与客户的平均亲和力来排序产品。`HeapAccum`将自动排序给定给它的元组。在我们有了`HeapAccum`之后，我们将需要将其转换为顶点集以进行进一步处理：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: A heap is a more scalable way to get the top k elements from a very large list
    because the heap has a fixed and usually small size. While `ORDER BY` and `LIMIT`
    are syntactically simpler, they will build a temporary table of all the elements
    to be sorted.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是从非常大的列表中获取前 k 个元素的更可伸缩的方法，因为堆具有固定且通常较小的大小。虽然`ORDER BY`和`LIMIT`在语法上更简单，但它们将构建一个临时表来排序所有元素。
- en: 'The last seven accumulators are simply to collect the vertices and edges to
    display. While we choose to have separate containers for each type, you could
    merge them into just one vertex set and one edge set:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后七个累加器仅用于收集要显示的顶点和边缘。虽然我们选择为每种类型单独使用容器，但您可以将它们合并为一个顶点集和一个边集：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We start with selecting all the `**Product**` vertices that share a `**Feature**`
    with a `**Customer**` vertex in `customer_vertex_set` and that also link to one
    of the input `**Context**` vertices in `context_vertex_set`. In a graph query
    language like GSQL, you perform this selection by searching for paths that make
    these connections. [Figure 7-7](#graph_path_to_select_products_that_have) shows
    the graph schema previously seen in [Figure 7-4](#graph_schema_for_the_recommendation_eng),
    with the search path and the specified vertex sets highlighted.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先选择与`customer_vertex_set`中的`**Customer**`顶点共享`**Feature**`的所有`**Product**`顶点，并且还链接到`context_vertex_set`中输入`**Context**`顶点之一的顶点。在像GSQL这样的图查询语言中，您通过搜索构成这些连接的路径来执行此选择。[图 7-7](#graph_path_to_select_products_that_have)显示了之前在[图 7-4](#graph_schema_for_the_recommendation_eng)中看到的图模式，突出显示了搜索路径和指定的顶点集。
- en: '![Graph path to select products that have features valued by certain customers
    and that satisfy certain context constraints](assets/gpam_0707.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图形路径选择由某些客户评价的特征的产品，并满足某些上下文约束](assets/gpam_0707.png)'
- en: Figure 7-7\. Graph path to select products that have features valued by certain
    customers and that satisfy certain context constraints (see a larger version of
    this figure at [https://oreil.ly/gpam0707](https://oreil.ly/gpam0707))
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-7. 选择由某些客户评价的特征的产品并满足某些上下文约束的图路径（在[https://oreil.ly/gpam0707](https://oreil.ly/gpam0707)上查看此图的较大版本）
- en: 'There are two syntax options to describe this path in GSQL: as three one-hop
    paths separated by commas or as one multihop path. While the multihop path is
    usually more elegant, the separate paths can give you more control over how the
    query is executed, if performance tuning is required. Note how the multihop `FROM`
    clause corresponds exactly to the highlighted path in the figure:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在GSQL中，有两种语法选项来描述此路径：作为由逗号分隔的三个一跳路径或作为一个多跳路径。虽然多跳路径通常更优雅，但单独的路径可以在需要性能调优时更好地控制查询的执行方式。请注意多跳`FROM`子句如何与图中突出显示的路径完全对应：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Each **`Customer-Feature-Product`** path has a score: `cf.affinity * pf.weight`.
    We compute all the path scores and accumulate them in `AvgAccum` accumulators
    (`@product_avg_scor``e`) to get an average score for each product. We then insert
    each product with its score into a `HeapAccum` (`@@order_product_heap`), which
    sorts them. Since we set the size of our heap to 1, we end with the single highest-scoring
    product:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`**Customer-Feature-Product**`路径都有一个得分：`cf.affinity * pf.weight`。我们计算所有路径得分，并在`AvgAccum`累加器（`@product_avg_scor``e`）中累加它们，以获得每个产品的平均得分。然后，我们将每个产品及其得分插入`HeapAccum`（`@@order_product_heap`），对其进行排序。由于我们将堆的大小设置为1，因此我们最终得到了得分最高的单个产品：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In one `SELECT` statement, we have performed our recommendation analysis.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个`SELECT`语句中，我们执行了我们的推荐分析。
- en: 'The purpose of the final `SELECT` statement is to visualize the elements that
    we want to display in a graph. We traverse the same paths that we did before,
    using an almost identical `FROM` clause, with one change: we include only our
    top product instead of all products. We add all elements from the vertex types
    we’ve visited in the `@@final_customer_vertex_set`, `@@final_feature_vertex_set`,
    `@@final_product_vertex_set`, and `@@final_context_vertex_set` accumulators, and
    then print those accumulators:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的`SELECT`语句的目的是可视化我们想在图表中显示的元素。我们沿用之前的路径，使用几乎相同的`FROM`子句，只有一个改变：我们只包括我们的顶级产品，而不是所有产品。我们从顶点类型中的`@@final_customer_vertex_set`、`@@final_feature_vertex_set`、`@@final_product_vertex_set`和`@@final_context_vertex_set`累加器中添加所有元素，然后打印这些累加器：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Figure 7-8](#example_query_result_for_recomm_by_cust) shows the output when
    the input customers are `C002` and `C003` and the input contexts are `BW` (bad
    weather) and `T3` (lunch). The weights that determined this selection are shown.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-8](#example_query_result_for_recomm_by_cust)展示了输入客户为`C002`和`C003`，输入上下文为`BW`（恶劣天气）和`T3`（午餐）时的输出结果。决定此选择的权重显示在图中。'
- en: '![Example query result for recomm_by_customer_and_context](assets/gpam_0708.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![recomm_by_customer_and_context的示例查询结果](assets/gpam_0708.png)'
- en: Figure 7-8\. Example query result for `recomm_by_customer_and_context` (see
    a larger version of this figure at [https://oreil.ly/gpam0708](https://oreil.ly/gpam0708))
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-8\. `recomm_by_customer_and_context`的示例查询结果（请参阅此图的更大版本：[https://oreil.ly/gpam0708](https://oreil.ly/gpam0708)）
- en: Get top demographics
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取顶级人口统计数据
- en: The query called `display_top_demographic` finds the `**Demographic**` element
    that has the highest average affinity score among its members and displays the
    `**Customer**` and `**Feature**` elements that are connected to this `**Demographic**`.
    The intuition here is that a `**Demographic**` with high affinity should have
    members that are similar to one another, and therefore you should be able to make
    better predictions about their preferences. The structure of this query is very
    similar to that of recommend products by customer and context. We score each `**Demographic**`
    element according to its average feature-based affinity to its connected `**Customer**`
    elements. This tells us if we have a `**Demographic**` group that is strongly
    bound versus a group that is only loosely bound.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 查询`display_top_demographic`找到具有其成员中最高平均亲和力分数的`**Demographic**`元素，并显示连接到此`**Demographic**`的`**Customer**`和`**Feature**`元素。这里的直觉是，具有高亲和力的`**Demographic**`应该有相似的成员，因此您应该能够更好地预测他们的偏好。这个查询的结构与按客户和上下文推荐产品的结构非常相似。我们根据其与连接的`**Customer**`元素之间基于特征的平均亲和力评分每个`**Demographic**`元素。这告诉我们，我们是否有一个强烈联系的`**Demographic**`组，还是一个仅仅松散联系的组。
- en: 'Unlike the previous query, this one does not have input parameters since it
    is calculating the top `**Demographic**` of the entire dataset without any given
    `**Context**`. We start with defining a tuple type and accumulators to score and
    sort `**Demographic**` vertices:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的查询不同，这个查询没有输入参数，因为它在没有给定`**Context**`的情况下计算整个数据集的顶级`**Demographic**`。我们从定义元组类型和累加器开始，以对`**Demographic**`顶点进行评分和排序：
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We also define six accumulators to collect the vertices and edges to display.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了六个累加器来收集要显示的顶点和边。
- en: We use `SELECT – FROM` to find the paths that connect `**Demographic**` to `**Customer**`
    via `**Feature**`. [Figure 7-9](#graph_paths_that_connect_demographic_to) illustrates
    this selection.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`SELECT – FROM`来找到连接`**Demographic**`到`**Customer**`通过`**Feature**`的路径。[图
    7-9](#graph_paths_that_connect_demographic_to)说明了这种选择。
- en: '![Graph paths that connect Demographic to Customer via Feature. After finding
    the paths, we score them by multiplying their edge weights.](assets/gpam_0709.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![连接`**Demographic**`到`**Customer**`通过`**Feature**`的图路径。在找到路径之后，我们通过乘以它们的边权重来对它们进行评分。](assets/gpam_0709.png)'
- en: Figure 7-9\. Graph paths that connect **`Demographic`** to **`Customer`** via
    **`Feature`**. After finding the paths, we score them by multiplying their edge
    weights. (See a larger version of this figure at [https://oreil.ly/gpam0709](https://oreil.ly/gpam0709).)
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-9\. 连接**`Demographic`**到**`Customer`**通过**`Feature`**的图路径。在找到路径之后，我们通过乘以它们的边权重来对它们进行评分。（请参阅此图的更大版本：[https://oreil.ly/gpam0709](https://oreil.ly/gpam0709)）
- en: 'Then we use an `ACCUM` statement to calculate the average `demographic` score
    for each element in `**Demographic**` by multiplying the attributes of `cf.affinity`
    with `df.affinity` and adding that score in `@@demographic_avg_score`. We create
    a `Top_Demographic_Tuple` for each `**Demographic**` and add that to `@@top_product_heap`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`ACCUM`语句来计算每个**人口统计**元素的平均`人口统计`分数，方法是将`cf.affinity`的属性乘以`df.affinity`，并将该分数添加到`@@demographic_avg_score`中。我们为每个**人口统计**创建一个`Top_Demographic_Tuple`，并将其添加到`@@top_product_heap`中：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A few lines are needed to convert the heap to a simple vertex set:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将堆转换为简单顶点集需要几行代码。
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The goal of the second `SELECT` statement is to display the found top `**Demographic**`
    and its connected `**Customer**` and `**Feature**` elements. We would like to
    also display the edges directly connecting `**Customer**` to `**Demographic**`,
    so the path traversal in the `FROM` clause is a bit longer this time. During these
    traversals, we store all the edges in `@@final_demo_customer_edge_set`, `@@final_demo_feature_edge_set`,
    and `@@final_context_feature_edge_set` using accumulators. With `POST-ACCUM` we
    store all the visited vertices `@@final_demographic_vertex_set`, `@@final_customer_vertex_set`,
    and `@@final_feature_vertex_set`. Finally, we use these variables to display the
    graph:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`SELECT`语句的目标是显示找到的顶级**人口统计**及其连接的**客户**和**特征**元素。我们还希望直接显示连接**客户**到**人口统计**的边，因此这次`FROM`子句中的路径遍历稍微长一些。在这些遍历过程中，我们使用累加器将所有边存储在`@@final_demo_customer_edge_set`、`@@final_demo_feature_edge_set`和`@@final_context_feature_edge_set`中。通过`POST-ACCUM`，我们将所有访问过的顶点存储在`@@final_demographic_vertex_set`、`@@final_customer_vertex_set`和`@@final_feature_vertex_set`中。最后，我们使用这些变量来显示图形：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Figure 7-10](#output_of_the_display_top_demographic_q) shows the result of
    running `display_top_demographic`. The `Old_Cruisers` demographic is selected
    because of the average weight of the affinity paths to all connected `**Customer**`
    elements. Because of the very small size of this sample dataset, there is only
    one connected `**Customer**`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-10](#output_of_the_display_top_demographic_q)展示了运行`display_top_demographic`的结果。由于与所有连接的**客户**元素的亲和路径的平均权重，选择了**Old_Cruisers**人口统计。由于这个样本数据集非常小，所以只有一个连接的**客户**。'
- en: '![Output of the display_top_demographic query](assets/gpam_0710.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![显示顶级人口统计查询的输出](assets/gpam_0710.png)'
- en: Figure 7-10\. Output of the `display_top_demographic` query (see a larger version
    of this figure at [https://oreil.ly/gpam0710](https://oreil.ly/gpam0710))
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-10的输出。显示`display_top_demographic`查询的结果（在[https://oreil.ly/gpam0710](https://oreil.ly/gpam0710)查看更大版本）。
- en: Chapter Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: In this chapter, we have looked into graph techniques to identify important
    vertices in a network. With a real-world use case, we have defined a referral
    network of doctors, patients, and specialists to demonstrate how analyzing its
    structure can help doctors make the proper referrals more efficiently.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了使用图技术识别网络中重要顶点的方法。通过一个真实的用例，我们定义了一个医生、患者和专家的推荐网络，展示了分析其结构如何帮助医生更有效地进行适当的推荐。
- en: We have also demonstrated how we can use a network of contextual information
    to improve customer recommendations. Our proposed solution includes a network
    of customers, demographics, features, and products. We have seen that analyzing
    the connections between these entities makes the recommendation more natural and
    scalable. This approach also helps us to avoid the cold start problem, which we
    often encounter using traditional database data structures.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还展示了如何利用上下文信息网络来改进客户推荐。我们提出的解决方案包括一个客户、人口统计、特征和产品网络。我们发现分析这些实体之间的连接使得推荐更加自然和可扩展。这种方法还帮助我们避免了使用传统数据库数据结构时经常遇到的冷启动问题。
- en: In the next chapter, we will demonstrate the use of graph analytics in the field
    of cybersecurity. We will show how we can detect and mitigate cyberattacks against
    firewalls and block devices used in DDoS attacks.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将展示如何在网络安全领域中使用图分析技术。我们将展示如何检测和缓解针对防火墙和用于DDoS攻击的设备的网络攻击。
- en: ^([1](ch07.html#ch01fn17-marker)) “Importance of Physician Referral Network
    in Healthcare,” JournoMed, August 18, 2020, [*https://journomed.com/importance-of-physician-referral-network-in-healthcare*](https://journomed.com/importance-of-physician-referral-network-in-healthcare).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.html#ch01fn17-marker)) “医疗中医生转诊网络的重要性”，JournoMed，2020年8月18日，[*https://journomed.com/importance-of-physician-referral-network-in-healthcare*](https://journomed.com/importance-of-physician-referral-network-in-healthcare)。
- en: ^([2](ch07.html#ch01fn18-marker)) Actually, in this schema, each directed edge
    also has a corresponding reverse edge, so there are 10 edge types.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.html#ch01fn18-marker)) 实际上，在这个模式中，每条有向边还有一个对应的反向边，因此共有10种边类型。
- en: ^([3](ch07.html#ch01fn19-marker)) No known algorithm is guaranteed to find the
    most optimal solution without expending compute resources that grow exponentially
    with the data size. Louvain efficiently finds a “good” answer in a time-efficient
    way.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch07.html#ch01fn19-marker)) 没有已知的算法能够在不消耗随数据规模呈指数增长的计算资源的情况下找到最优解。Louvain算法以时间高效的方式有效地找到一个“好”的答案。
- en: ^([4](ch07.html#ch01fn20-marker)) You could easily modify the scoring scheme
    by changing this accumulator type from a `MaxAccum` to a `SumAccum` (total affinity)
    or `AvgAccum` (average affinity).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch07.html#ch01fn20-marker)) 通过将累加器类型从`MaxAccum`修改为`SumAccum`（总亲和力）或`AvgAccum`（平均亲和力），您可以轻松修改评分方案。
