- en: Chapter 8\. Strengthening Cybersecurity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 加强网络安全
- en: 'In this chapter, we will describe how graphs can strengthen a cybersecurity
    system. We will demonstrate how graph analytics can identify root causes of a
    reported alert, detect bypassing of a firewall, and discover anomalous behavior
    such as flooding and footprinting. We will also show how graphs can find connections
    to suspicious IP addresses that may be responsible for attacks. After finishing
    this chapter, you should be able to:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述图形分析如何加强网络安全系统。我们将展示图形分析如何识别报警的根本原因，检测防火墙的绕过，发现洪水攻击和足迹扫描等异常行为。我们还将展示图形如何找到与可疑IP地址的连接，这些地址可能是攻击的来源。完成本章后，您应该能够：
- en: Understand how to apply graph concepts within the cybersecurity space
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络安全领域应用图形概念的理解
- en: Build graph queries to trace microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建图形查询以追踪微服务
- en: Build graph queries to detect statistical anomalies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建图形查询以检测统计异常
- en: The Cost of Cyberattacks
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络攻击的成本
- en: We rely on technology constantly challenged by cyberattacks that aim to damage,
    disrupt, or maliciously control our IT infrastructure or our sensitive data. According
    to a Ponemon Institute survey in 2019, 66% of small to medium enterprises had
    experienced a cyberattack within the past 12 months.^([1](ch08.html#ch01fn21))
    These cyberattacks have become a daily threat to the functioning of our society.
    For example, leading up to the US presidential election of 2016, Russian hackers
    coordinated attacks on members of the Democratic Party to steer the election’s
    outcome. According to the US National Security Agency (NSA), email accounts of
    more than 300 people affiliated with Hillary Clinton’s campaign as well as those
    of other Democratic Party organizations were attacked.^([2](ch08.html#ch01fn22))
    These attacks led to information leaks that sought to harm Clinton’s election
    campaign. In a more recent example, from February 2022, a hacker group executed
    a large-scale cyberattack on NVIDIA, one of the world’s largest semiconductor
    chip companies. The attackers leaked credentials and employee information online.
    The perpetrators claimed they had access to more than one terabyte of company
    data, which they would release if NVIDIA did not meet their ransom demands.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依赖技术，这些技术不断受到网络攻击的挑战，这些攻击旨在损害、破坏或恶意控制我们的IT基础设施或敏感数据。根据2019年Ponemon研究所的一项调查，66%的中小型企业在过去12个月内经历过网络攻击。^([1](ch08.html#ch01fn21))
    这些网络攻击已经成为我们社会运作的日常威胁。例如，2016年美国总统选举前，俄罗斯黑客协调攻击民主党成员，试图操控选举结果。根据美国国家安全局（NSA）的说法，与希拉里·克林顿竞选活动及其他民主党组织有关的300多人的电子邮件账户遭到攻击。^([2](ch08.html#ch01fn22))
    这些攻击导致信息泄露，旨在损害克林顿的竞选活动。更近期的例子是2022年2月，一组黑客对全球最大的半导体公司之一NVIDIA进行了大规模网络攻击。攻击者泄露了公司的凭证和员工信息。肇事者声称他们可以访问超过1TB的公司数据，如果NVIDIA不满足他们的赎金要求，他们将会公开这些数据。
- en: Cyberattacks can damage governmental and commercial organizations as well as
    individuals, leading to political disruptions and financial implications. According
    to research into the costs of data breaches conducted by the Ponemon Institute
    and IBM, the average cost of a single data breach is $3.86 million globally. The
    US tops this chart with an average cost of $8.64 million for a single breach.
    A key challenge to minimizing these damages is identifying the breach as soon
    as possible. Researchers claim that organizations can save $1.12 million when
    a breach is detected within less than 200 days. However, they also suggest that
    the time to detect and contain a data breach is still, on average, up to 315 days
    for a malicious breach.^([3](ch08.html#ch01fn23)) The average cost of a data breach
    is expected to be $5 million in 2023.^([4](ch08.html#ch01fn24))
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 网络攻击可能会损害政府和商业组织以及个人，导致政治混乱和财务损失。根据Ponemon研究所和IBM对数据泄露成本的研究，全球单一数据泄露的平均成本为386万美元。美国在这一领域排名首位，单一泄露的平均成本为864万美元。最大的挑战之一是尽早发现这些损害。研究人员声称，当在不到200天内检测到数据泄露时，组织可以节省112万美元。然而，他们也指出，对恶意数据泄露进行检测和遏制的平均时间仍然长达315天。^([3](ch08.html#ch01fn23))
    数据泄露的平均成本预计在2023年将达到500万美元。^([4](ch08.html#ch01fn24))
- en: Understanding how attackers operate is essential to building effective cybersecurity
    systems. The Common Attack Pattern Enumerations and Classifications (CAPEC)^([5](ch08.html#ch01fn25))
    initiative provides a standard set of categories and descriptions of cyberattack
    patterns that analysts, developers, and IT architects can use to enhance defenses.
    CAPEC divides these attack patterns into nine categories. For example, Abuse Existing
    Functionality is an attack pattern where the adversary manipulates the functionality
    of an application to achieve a malicious output not originally intended or depletes
    a resource to influence functionality. Collect and Analyze Information attack
    patterns focus on gathering, collecting, and stealing information. Methods used
    in this category include active querying and passive observation. The example
    case from the 2016 US presidential election falls under this category. Inject
    Unexpected Items includes attack patterns that focus on the ability to control
    or disrupt the behavior of an application. These attack patterns install and execute
    malicious code by exploiting an input on the target application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 理解攻击者的操作方式对于构建有效的网络安全系统至关重要。《通用攻击模式枚举和分类》（CAPEC）^([5](ch08.html#ch01fn25)) 项目提供了一套标准的网络攻击模式类别和描述，分析员、开发人员和IT架构师可以利用这些来增强防御能力。CAPEC将这些攻击模式分为九类。例如，“滥用现有功能”是一种攻击模式，对手利用应用程序的功能来达到原本不被预期的恶意输出或耗尽资源以影响功能。攻击模式“收集和分析信息”侧重于获取、收集和窃取信息。该类别中使用的方法包括主动查询和被动观察。2016年美国总统选举的案例属于这一类别。攻击模式“注入意外项目”包括专注于控制或干扰应用程序行为的攻击模式。这些攻击模式通过利用目标应用程序的输入来安装和执行恶意代码。
- en: Problem
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题。
- en: A key challenge is monitoring the information flow so that vulnerabilities are
    visible and attacks are reported quickly. Suppose a microservice triggers another
    microservice that raises an alert. In that case, the system must be able to support
    deep-link analytics to trace the root cause or pattern matching for detecting
    anomalous behavior. With the growing volume of data stored, processed, and modified,
    it becomes more difficult to efficiently manage and extract relevant information
    from the data in real time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键挑战是监控信息流，以便漏洞可见并快速报告攻击。假设一个微服务触发另一个微服务引发警报，那么系统必须能够支持深度链接分析以追溯根本原因，或者进行模式匹配以检测异常行为。随着存储、处理和修改的数据量不断增长，从中实时高效地管理和提取相关信息变得更加困难。
- en: 'The information above reveals that cybersecurity attack detection:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 上述信息显示，网络安全攻击检测需要：
- en: Must process a large volume of data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须处理大量数据。
- en: Must identify threats and trigger alerts as fast as possible
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽快识别威胁并触发警报。
- en: Must assist in finding the original point of failure
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须帮助找出原始故障点。
- en: Is an urgent and growing business need remaining unmet at many enterprises
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是许多企业急需但尚未满足的紧迫且增长迅速的业务需求。
- en: Solution
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Cybersecurity aims to ensure confidentiality, integrity, and availability of
    information and to protect networks, devices, and data from unauthorized access
    or criminal use.^([6](ch08.html#ch01fn26)) Graphs are a natural fit for modeling
    digital systems and detecting attacks because the internet itself, with its infrastructure
    and devices, is an interconnected network. It is the medium through which cyberattacks
    are made. An attack pattern can be analyzed as a chain of events, or a path within
    the graph consisting of individual processes. A process can be an object or interaction
    between different objects, depending on what we want to model.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全旨在确保信息的保密性、完整性和可用性，并保护网络、设备和数据免受未经授权的访问或犯罪性使用。^([6](ch08.html#ch01fn26))
    图表是模拟数字系统和检测攻击的自然选择，因为互联网本身及其基础设施和设备构成了一个互连网络。攻击模式可以被分析为一系列事件的链条，或者是图中由个别过程组成的路径。一个过程可以是一个对象或不同对象之间的互动，这取决于我们想要模型化的内容。
- en: Often, a large number of attacks are the work of relatively few perpetrators.
    This is the case with DDoS attacks. In a graph model, this translates to a hub
    structure. A graph-based cybersecurity system can seek out and analyze unexpected
    hubs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，大量攻击是由相对较少的肇事者完成的。DDoS攻击即是如此。在图模型中，这反映为一个中心结构。基于图的网络安全系统可以寻找并分析意外的中心点。
- en: We must consider four aspects when building a cyberattack defense system based
    on graphs. First, the data that we collect in our organization is a network in
    itself, but we must model its processes, assets, and operations as a unified real-time
    graph. Second, we must monitor key operations and vulnerable places in our graph.
    Therefore, we can use known attack patterns to express those within our graph
    and build our defense around them. Third, the graph can assist us when an actual
    attack occurs. It can help to identify where the attack takes place in the graph
    and trace both upstream to the source and downstream to the effects. Lastly, we
    collect historical data from our organization and merge it with data from a third
    party, such as an anonymized dataset from McAfee or Norton, and feed that into
    machine learning models to predict future attacks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建基于图的网络攻击防御系统时，我们必须考虑四个方面。首先，我们在组织内收集的数据本身就是一个网络，但我们必须将其过程、资产和操作建模为统一的实时图。其次，我们必须监控图中的关键操作和易受攻击的位置。因此，我们可以使用已知的攻击模式在我们的图中表达这些，并围绕它们构建我们的防御。第三，当实际攻击发生时，图可以帮助我们。它可以帮助识别攻击发生在图中的位置，并追溯攻击的上游和下游影响。最后，我们从组织中收集历史数据，并将其与来自第三方（如McAfee或Norton的匿名数据集）的数据合并，并将其馈入机器学习模型以预测未来的攻击。
- en: A cybersecurity system must be able to integrate multiple data sources and process
    them in real time. For example, we need to integrate service information to know
    which microservice is called throughout our operations or server information to
    know where our applications are deployed and see the status of our virtual machines.
    Another common data source to include is user information regarding permission
    and authorizations. Graphs can integrate these many data types into a single view,
    where services, databases, and users are linked with an interconnected cybersecurity
    solution.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全系统必须能够集成多个数据源并实时处理它们。例如，我们需要集成服务信息，以了解在我们的操作中调用哪些微服务，或者服务器信息，以了解我们的应用程序部署在哪里，并查看我们的虚拟机的状态。另一个包括的常见数据源是用户信息，涉及权限和授权。图可以将这些多种数据类型集成为单一视图，其中服务、数据库和用户与互联的网络安全解决方案相链接。
- en: Implementing a Cybersecurity Graph
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施网络安全图
- en: Using one of TigerGraph Cloud’s starter kits, we will show how to implement
    a cyberattack detection system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TigerGraph Cloud的一个入门套件，我们将展示如何实施一个网络攻击检测系统。
- en: The Cybersecurity Threat Detection Starter Kit
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络安全威胁检测入门套件
- en: Using TigerGraph Cloud, deploy a new cloud instance and select “Cybersecurity
    Threat Detection” as the starter kit. Once this starter kit is installed, load
    the data following the steps listed in the section [“Load data and install queries
    for a starter kit”](ch03.html#load_data_and_install_queries_for_a_sta) in [Chapter 3](ch03.html#see_your_customers_and_business_better).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TigerGraph Cloud，部署一个新的云实例，并选择“网络安全威胁检测”作为入门套件。安装了这个入门套件后，按照第三章的“加载数据和安装查询入门套件”部分中列出的步骤加载数据。
- en: Graph Schema
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图模式
- en: The Cybersecurity Threat Detection Starter Kit schema has nine vertex types,
    with **`Event`** as the central vertex type. In total there are 1,325 vertices
    and 2,692 edges. The schema of this starter kit is shown in [Figure 8-1](#graph_schema_for_the_cybersecurity_thre).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络安全威胁检测入门套件**的模式有九种顶点类型，以**`Event`**作为中心顶点类型。总共有1,325个顶点和2,692条边。这个入门套件的模式如图[8-1](#graph_schema_for_the_cybersecurity_thre)所示。'
- en: '![Graph Schema for the Cybersecurity Threat Detection Starter Kit](assets/gpam_0801.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![网络安全威胁检测入门套件的图模式](assets/gpam_0801.png)'
- en: Figure 8-1\. Graph Schema for the Cybersecurity Threat Detection Starter Kit
    (see a larger version of this figure at [https://oreil.ly/gpam0801](https://oreil.ly/gpam0801))
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-1\. 网络安全威胁检测入门套件的图模式（在[https://oreil.ly/gpam0801](https://oreil.ly/gpam0801)查看此图的更大版本）
- en: 'There are six types of events: authentication, firewall, login, request, read,
    and write. If an event is caused by a person or network device, it may be associated
    with a `**UserID**`, `**Device**`, or `**IP**` address. The `**Event**` may be
    an action that involves a `**Service**`, `**Servers**`, or a `**Resource**`. A
    `**Service**` or `**Servers**` can report an `**Alert**`, which has an `**Alert_Type**`.
    These vertex types are described in [Table 8-1](#vertex_types_in_the_cybersecurity_threa).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 六种事件类型包括：认证、防火墙、登录、请求、读取和写入。如果事件是由人或网络设备引起的，则可能与 `**用户ID**`、`**设备**` 或 `**IP**`
    地址相关联。`**事件**` 可能是涉及 `**服务**`、`**服务器**` 或 `**资源**` 的动作。`**服务**` 或 `**服务器**` 可能会报告
    `**警报**`，而 `**警报**` 则具有 `**警报类型**`。这些顶点类型在 [Table 8-1](#vertex_types_in_the_cybersecurity_threa)
    中有描述。
- en: Table 8-1\. Vertex types in the Cybersecurity Threat Detection graph model
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Table 8-1\. Cybersecurity Threat Detection 图模型中的顶点类型
- en: '| Vertex type | Description |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 顶点类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `**Event**` | An event triggered by an action in the system |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `**事件**` | 系统中动作触发的事件 |'
- en: '| `**IP**` | An IP address involved in an **`Event`** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `**IP**` | 参与 **`事件`** 的IP地址 |'
- en: '| `**UserID**` | A user ID referring to a user involved in an **`Event`** |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `**用户ID**` | 与 `**事件**` 相关的用户ID |'
- en: '| `**Service**` | A microservice that performs the action of an **`Event`**
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `**服务**` | 执行 **`事件`** 动作的微服务 |'
- en: '| `**Alert**` | An alert triggered by a **`Service`** on a **`Server`** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `**警报**` | 由 **`服务`** 在 **`服务器`** 上触发的警报 |'
- en: '| `**Alert_Type**` | The alert type of an **`Alert`** |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `**警报类型**` | **`警报`** 的警报类型 |'
- en: '| `**Server**` | A server on which an **`Event`** occurs |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `**服务器**` | 发生 `**事件**` 的服务器 |'
- en: '| `**Resource**` | A resource used in an **`Event`** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `**资源**` | 在 **`事件`** 中使用的资源 |'
- en: '| `**Device**` | A device used in an **`Event`** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `**设备**` | **`事件`** 中使用的设备 |'
- en: An `**Event**` can be associated with a `**Device**`, `**IP**`, or `**UserID**`.
    The associations are represented by the edge types **`From_Device`**, **`Has_ip`**,
    and `user_event`, respectively. We use two edge directions to indicate the relationships
    between `**Event**` and `**Services**`. If we want to know which `**Services**`
    belong to an `**Event**`, we use **`To_Service`**, or if we want to know the `**Event**`
    that belongs to the `**Service**`, we use **`From_Service`**. Similarly, we can
    find the `**Server**` elements that belong to the `**Event**` and vice versa,
    respectively, with the edges **`To_Server`** and **`From_Server`**. With edges
    **`Output_To_Resource`** and **`Read_From_Resource`**, respectively, we can find
    which `**Event**` is triggered with the `**Resource**` and which `**Resource**`
    are involved in an `**Event**`. We use **`Service_Alert`** and **`Server_Alert`**
    to indicate which `**Service**` and `**Servers**` are related to the reported
    `**Alert**`. And to find the `**Alert_Type**` for each `**Alert**`, we use the
    edge type **`Alert_Has_Type`**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `**事件**` 可能与 `**设备**`、`**IP**` 或 `**用户ID**` 相关联。这些关联由边类型 **`From_Device`**、**`Has_ip`**
    和 `user_event` 表示。我们使用两种边方向来表示 `**事件**` 与 `**服务**` 之间的关系。如果我们想知道哪些 `**服务**` 属于一个
    `**事件**`，我们使用 **`To_Service`**，或者如果我们想知道属于 `**服务**` 的 `**事件**`，我们使用 **`From_Service`**。类似地，我们可以找到属于
    `**事件**` 的 `**服务器**` 元素及其相反关系，分别使用边 **`To_Server`** 和 **`From_Server`**。通过边 **`Output_To_Resource`**
    和 **`Read_From_Resource`**，我们可以找出哪些 `**事件**` 是由 `**资源**` 触发的，以及哪些 `**资源**` 参与了
    `**事件**`。我们使用 **`Service_Alert`** 和 **`Server_Alert`** 来指示哪些 `**服务**` 和 `**服务器**`
    与报告的 `**警报**` 相关联。而要找出每个 `**警报**` 的 `**警报类型**`，我们使用边类型 **`Alert_Has_Type`**。
- en: Queries and Analytics
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询与分析
- en: 'The queries included in this starter kit present a sample of several different
    cyberattack patterns that can be detected using graph-based queries and analytics.
    Three of them correspond to attack pattern categories described by CAPEC: functionality
    bypassing, footprinting, and fingerprinting.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此起始套件中包含的查询展示了使用基于图的查询和分析可以检测到的几种不同的网络攻击模式示例。其中三种对应于CAPEC描述的攻击模式类别：功能绕过、足迹探测和指纹识别。
- en: Detect bypassing of a firewall
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 检测防火墙绕过
- en: Detect users who read from a resource that is protected by a firewall but who
    are somehow evading the firewall.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 检测通过防火墙保护的资源但某种方式逃避防火墙的用户。
- en: Suspicious IP detection
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可疑IP检测
- en: Given an IP address, find all connections to banned IP addresses within a given
    number of hops.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个IP地址，查找与一定跳数内所有连接到被禁止IP地址的连接。
- en: Flooding detection
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 洪水检测
- en: Detect anomalies based on an unusually high number of requests to a service.
    Return the user who is responsible for the flooding event.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 检测基于对服务的异常高请求数的异常情况。返回负责洪水事件的用户。
- en: Footprinting detection
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 足迹检测
- en: Detect anomalies based on an unusually high number of calls to an endpoint of
    a service in a short period of time. Return the user who is responsible for the
    footprinting event.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 检测基于短时间内对服务端点的异常高调用次数的异常情况。返回负责足迹事件的用户。
- en: Tracing the source of an alert
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 追溯警报源头
- en: Track down which user elements and IP addresses cause an alert for a corrupted
    file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪导致损坏文件警报的用户元素和 IP 地址。
- en: Some of these queries will display paths from events or IPs of interest back
    to the targeted related entities. Other queries are most easily understood by
    looking at the tabular results.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一些查询会显示从感兴趣的事件或 IP 返回到相关实体的路径。其他查询通过查看表格结果最容易理解。
- en: Detect bypassing of a firewall
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测绕过防火墙的行为
- en: A functionality bypass attack accesses services while bypassing functionality
    intended to provide system protection.^([7](ch08.html#ch01fn27)) If access to
    a certain resource is protected by a firewall, then every read access should be
    preceded by a successful firewall event, as illustrated in [Figure 8-2](#traversal_path_and_first_two_user_sets)
    (reading from right to left). The `firewall_bypass_detection` query detects users
    or IP addresses that somehow evaded firewall protection and read a protected resource.
    It uses both graph traversal and set algebra to group users into four different
    categories. We start with selecting all the `**Resource**` elements for which
    `Firewall_required == TRUE`. From those resources, we first traverse to all read
    `**Event**` vertices. This corresponds to the first hop shown in [Figure 8-2](#traversal_path_and_first_two_user_sets).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 功能绕过攻击是访问服务的一种方式，同时绕过意图提供系统保护的功能。[^7]如果某一资源的访问受到防火墙的保护，那么每次读取访问都应该先成功通过防火墙事件，如图
    [8-2](#traversal_path_and_first_two_user_sets) 中所示（从右向左读取）。`firewall_bypass_detection`
    查询用于检测某些用户或 IP 地址如何逃避防火墙保护并读取受保护资源。它使用图遍历和集合代数将用户分成四个不同的类别。我们首先选择所有 `**Resource**`
    元素，其中 `Firewall_required == TRUE`。从这些资源中，我们首先遍历到所有读取 `**Event**` 顶点。这对应于 [8-2](#traversal_path_and_first_two_user_sets)
    图中显示的第一跳。
- en: '![Traversal path and first two user sets for firewall_bypass_detection query](assets/gpam_0802.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![firewall_bypass_detection 查询的遍历路径和前两个用户集](assets/gpam_0802.png)'
- en: Figure 8-2\. Traversal path and first two user sets for `firewall_bypass_detection`
    query
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-2\. `firewall_bypass_detection` 查询的遍历路径和前两个用户集
- en: 'Then we identify four sets of users. In this case, we will consider both `**UserID**`
    and `**IP**` addresses as “users.” The first set of users is simply everyone linked
    to the read events to firewall-protected resources:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们识别四组用户。在这种情况下，我们将考虑 `**UserID**` 和 `**IP**` 地址都作为“用户”。第一组用户是所有与读取防火墙保护资源相关联的用户：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second set is the subset of those users who are also linked to a firewall
    event:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组是那些同时也与防火墙事件相关联的用户的子集：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The third set is those users who read without also engaging in a firewall event.
    We can obtain this set by subtracting the second set from the first set:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第三组是那些仅进行读取而没有参与防火墙事件的用户。我们可以通过从第一组中减去第二组来获得此集合：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our fourth and final set of users is those who had both a read and a firewall
    event (second set), but the read event took place prior to the firewall event,
    meaning that the firewall was bypassed:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第四组也是最后一组用户是那些既有读取事件又有防火墙事件（第二组），但读取事件发生在防火墙事件之前，这意味着防火墙被绕过：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Table view is the best option for viewing these results. You’ll find nine IDs
    in the `IP_userID_no_firewall` category and one IP in the `IP_userID_bypass_firewall`
    group. In a real use case, a user could have many read and firewall events over
    time, so timestamps, session IDs, or some other mechanism should be used to determine
    which events are part of the same session.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表视图是查看这些结果的最佳选项。您将在 `IP_userID_no_firewall` 类别中找到九个 ID，以及在 `IP_userID_bypass_firewall`
    组中找到一个 IP。在实际用例中，用户可能会随着时间的推移拥有许多读取和防火墙事件，因此应使用时间戳、会话 ID 或其他机制来确定哪些事件属于同一会话。
- en: Suspicious IP detection
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可疑 IP 检测
- en: While being closely connected to an undesired entity is not evidence of wrongdoing,
    it is a justified cause for closer investigation. The `suspicious_ip_detection`
    query detects banned IP addresses that are linked to a given input IP address
    within a certain number of hops. The query uses a `WHILE` loop and the GSQL `ACCUM`
    clause’s natural orientation for breadth-first search to efficiently discover
    shortest paths. It returns the number of banned IP addresses within a given number
    of hops and the number of the shortest paths to those banned IP addresses.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与不受欢迎的实体紧密连接并不意味着有错，但这是更深入调查的正当理由。`suspicious_ip_detection`查询检测与给定输入IP地址在一定跳数内连接的禁止IP地址。该查询使用`WHILE`循环和GSQL的`ACCUM`子句进行广度优先搜索，以有效地发现最短路径。它返回给定跳数内的禁止IP地址数量以及到这些禁止IP地址的最短路径数量。
- en: 'The query has three parameters: `input_ip` is the IP address to investigate,
    `depth` is how many hops away from `input_ip` we would like to travel (the default
    is 3), and `display_paths` is a Boolean indicator to specify whether to visualize
    the paths to the banned IP addresses:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 查询有三个参数：`input_ip`是要调查的IP地址，`depth`是我们希望从`input_ip`出发前进的跳数（默认为3），`display_paths`是一个布尔指示器，指定是否可视化到禁止IP地址的路径：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The implementation follows a classic breadth-first unweighted shortest path
    search method. Each vertex has two accumulators to track information about shortest
    paths from `input_ip` to itself. We initialize a vertex set (called `start`) to
    be `input_ip` and initialize its accumulator `@num_shortest_paths` to 1 (because
    there is one path from `input_ip` to itself). Then, using a `WHILE` loop that
    iterates depth times, we repeat the following.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实现遵循经典的广度优先非加权最短路径搜索方法。每个顶点都有两个累加器来跟踪从`input_ip`到自身的最短路径信息。我们初始化一个顶点集（称为`start`），其初始值为`input_ip`，并将其累加器`@num_shortest_paths`初始化为1（因为从`input_ip`到自身有一条路径）。然后，使用一个`WHILE`循环，重复以下步骤。
- en: 'First we travel from `start` to all neighboring vertices that have not been
    visited. We know a vertex `t` has not been visited before if `t.@num_shortest_paths
    == 0`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`start`到所有未访问的邻居顶点。我们知道顶点`t`之前未被访问过，如果`t.@num_shortest_paths == 0`。
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Second, we account for shortest paths. When we arrive at a previously unvisited
    neighbor vertex `t`, it must have been along a shortest path. Therefore we update
    `t`’s count of shortest paths to itself (`t.@num_shortest_paths`) and its collection
    of edges to display these paths (`t.@edge_list`):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们考虑最短路径。当我们到达以前未访问的邻居顶点`t`时，这必然是沿着最短路径进行的。因此，我们更新`t`到自身的最短路径计数(`t.@num_shortest_paths`)以及它的边集合以显示这些路径(`t.@edge_list`)：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Third, we check if the neighbor is tagged as a banned IP. If it is, we update
    three global accumulators. First, we add that neighbor to `@@nearby_banned_IPs`.
    Second, we add the number of shortest paths to `t` `(``t.@num_shortest_paths)`
    to `@@num_paths_to_banned_IPs`. Third, we append the paths themselves (`t.@edge_list`)
    to `@@paths_to_banned_IPs`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们检查邻居是否被标记为禁止IP。如果是，我们更新三个全局累加器。首先，我们将该邻居添加到`@@nearby_banned_IPs`中。其次，我们将到`t`的最短路径数(`t.@num_shortest_paths`)添加到`@@num_paths_to_banned_IPs`中。第三，我们将路径本身(`t.@edge_list`)附加到`@@paths_to_banned_IPs`中：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We then update the vertex set `start` to be the target set `t`. We repeat the
    three steps above, this time starting the traversal from our newly visited vertices
    of the previous round. We perform depth rounds to ensure that we move that many
    steps away from our input IP address, or until we run out of unvisited vertices
    (`WHILE start.size() > 0 LIMIT depth DO`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们更新顶点集`start`为目标集`t`。我们重复以上三个步骤，这次从上一轮新访问的顶点开始遍历。我们进行深度轮次以确保我们离输入IP地址移动那么多步，或者直到我们用完未访问的顶点(`WHILE
    start.size() > 0 LIMIT depth DO`)。
- en: Using the suggested inputs `input_ip` = 188.117.3.237 and `depth` = 4, we find
    18 suspicious IPs, as shown in [Figure 8-3](#ips_connected_to_a_given_banned_ipcomma).
    A higher depth will find even more, but the greater distance may decrease the
    likelihood of malfeasance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用建议的输入 `input_ip` = 188.117.3.237 和 `depth` = 4，我们发现了18个可疑IP地址，如图8-3所示。增加深度将找到更多，但是距离增加可能会降低违规行为的可能性。
- en: '![IPs connected to a given banned IP, within a depth of 4](assets/gpam_0803.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![与给定禁止IP地址相连接的IP地址，在深度为4内](assets/gpam_0803.png)'
- en: Figure 8-3\. IPs connected to a given banned IP, within a depth of 4 (see a
    larger version of this figure at [https://oreil.ly/gpam0803](https://oreil.ly/gpam0803))
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-3\. 与给定禁止IP地址相连接的IP地址，在深度为4内（请参见此图的更大版本[https://oreil.ly/gpam0803](https://oreil.ly/gpam0803)）
- en: Flooding detection
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 洪水检测
- en: The next two queries focus on detecting anomalies that may be a cyberattack.
    A *flooding* attack makes a large number of service requests to a target in an
    attempt to overwhelm it.^([8](ch08.html#ch01fn28)) The `flooding_detection` query
    detects if one service receives many more requests than usual. This query is a
    good example of how GSQL’s support for algorithmic programming and accumulators
    makes it easy to calculate statistics such as mean and standard deviation, and
    then to perform filtering based on those values.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个查询专注于检测可能的网络攻击异常。*Flooding*攻击会向目标发送大量服务请求，试图使其超负荷。^([8](ch08.html#ch01fn28))
    `flooding_detection`查询检测一个服务是否接收到比通常多得多的请求。这个查询是GSQL支持算法编程和累加器的良好示例，使得可以轻松计算统计数据，如平均值和标准偏差，并根据这些值执行过滤。
- en: The query includes one parameter, `n_sigma`, where `sigma>` refers to standard
    deviation. The default value is 3.0, which means that an IP is considered an outlier
    if its number of login events is more than three standard deviations above the
    mean. This parameter lets users easily tune the alert threshold.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 查询包括一个参数`n_sigma`，其中`sigma`表示标准偏差。默认值为3.0，这意味着如果IP的登录事件数量超过平均值三个标准偏差，那么该IP被视为异常值。此参数使用户能够轻松调整警报阈值。
- en: The overall flow of this query consists of four single hops, where we eventually
    count the number of service requests per IP and compare it against the mean among
    all other IPs to determine if it is an outlier. [Figure 8-4](#accumulation_in_the_flooding_detection)
    shows a sample graph and how the events would be aggregated by the query.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的整体流程包括四个单一的跳跃，最终我们将计算每个IP的服务请求次数，并与所有其他IP的平均值进行比较，以确定它是否是异常值。[图8-4](#accumulation_in_the_flooding_detection)展示了一个样本图表，以及该查询如何聚合事件。
- en: '![Accumulation in the flooding_detection query](assets/gpam_0804.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![在flooding_detection查询中的累积](assets/gpam_0804.png)'
- en: Figure 8-4\. Accumulation in the `flooding_detection` query
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-4\. 在`flooding_detection`查询中的累积
- en: 'In the first hop, we select all the login events per IP address by traversing
    from `**IP**` to `**Event**` via **`Has_IP`** edges. The clause `WHERE event.Event_Type
    == "login"` filters the selection to only include login events. Then we count
    the number of logins per IP address: `@count_map += (i->1)`. The `i``->1` in this
    statement means that we add 1 for each occurrence by an IP address `i`. In the
    next few hops, we will transfer or regroup the counts from this step to compute
    the subtotal by user, request event, and service:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个跳跃中，我们通过**`IP`**到**`Event`**的**`Has_IP`**边遍历选择每个IP地址的所有登录事件。子句`WHERE event.Event_Type
    == "login"`将选择过滤为仅包括登录事件。然后我们计算每个IP地址的登录次数：`@count_map += (i->1)`。该语句中的`i->1`表示我们针对每个IP地址`i`添加1。在接下来的几个跳跃中，我们将从这一步开始传输或重新分组计数，以计算按用户、请求事件和服务计算的小计：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the second hop, we link the number of login events to the users. This is
    done by traversing from `login_events` to `**User**` over **`User_Events`** edges.
    We use `user.@count_map += le.@count_map` to group the previously counted events
    by user. In [Figure 8-4](#accumulation_in_the_flooding_detection), we see that
    User1 has two login events from IP1:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个跳跃中，我们将登录事件数量与用户关联起来。这是通过在**`User_Events`**边上从`login_events`到**`User`**的遍历完成的。我们使用`user.@count_map
    += le.@count_map`来按用户对先前计算的事件进行分组。在[图8-4](#accumulation_in_the_flooding_detection)中，我们看到User1从IP1登录了两次：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the third hop, we link to the request events of the users that we found
    in the second hop. The clause `WHERE event.Event_Type == "request"` checks that
    we are including only request events. Then we copy our previous counts to the
    request events:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个跳跃中，我们链接到我们在第二个跳跃中找到的用户的请求事件。子句`WHERE event.Event_Type == "request"`检查我们是否仅包括请求事件。然后我们将我们之前的计数复制到请求事件中：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the fourth and final hop, we link the request events from the previous hop
    to `**Service**` elements. We also accumulate our ongoing counts and group them
    by `**Service**`. In [Figure 8-4](#accumulation_in_the_flooding_detection), we
    see that Service1 has a total of four login events from IP1, two via User1 and
    two via User3\. Now we can compute the final statistics to determine whether the
    IP has triggered an unusual volume of requests. We do this in three steps. In
    the first step, we use `AvgAccum` accumulators to easily calculate the mean count
    among all IPs:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四和最后一跳中，我们将上一跳的请求事件链接到**`Service`**元素。我们还累积我们正在进行的计数，并按**`Service`**进行分组。在[图 8-4](#accumulation_in_the_flooding_detection)中，我们看到Service1共有四个来自IP1的登录事件，两个通过User1和两个通过User3。现在我们可以计算最终的统计数据，以确定IP是否触发了异常数量的请求。我们通过三个步骤来完成此操作。在第一步中，我们使用`AvgAccum`累加器轻松计算所有IP之间的平均计数：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the second step, we compute the standard deviation (using the `@mean` from
    the first pass):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们计算标准差（使用第一次传递中的`@mean`）：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lastly, we check for outliers by comparing each login count with the mean and
    standard deviation. If the count is larger than the mean plus the product of `n_sigma`
    (our threshold value set in the parameter) and the standard deviation, then the
    IP’s login behavior is an outlier:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将每个登录次数与平均值和标准差进行比较来检查异常值。如果计数大于平均值加上`n_sigma`（我们在参数中设置的阈值）乘以标准差，那么该IP的登录行为就是异常的：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For simplicity, we did not include the time aspect of each login and request
    event. In a real-life scenario, a login event must precede its associated request
    event, and the request events must occur within a small enough time window to
    be considered an attack. In this example, we kept it simple and only demonstrated
    how graphs can obtain event triggers over the entire network to calculate individual
    statistics.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们没有包含每次登录和请求事件的时间方面。在实际情况中，登录事件必须先于其关联的请求事件发生，并且请求事件必须在足够短的时间窗口内发生，以被视为攻击。在这个例子中，我们保持简单，仅演示了如何通过整个网络获取事件触发器来计算各个统计数据。
- en: Running the query with `n_sigma` = 3 finds IP 216.61.220.149 listed twice in
    the table view, once for high use of service 11 and once for service 12.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行带有`n_sigma` = 3的查询，在表视图中两次列出IP 216.61.220.149，一次用于服务11的高使用率，一次用于服务12。
- en: Footprint detection
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 足迹检测
- en: Another type of cyberattack is footprinting. `Footprinting` calls many endpoints
    of a service in a short time in an attempt to understand its configuration, behavior,
    and vulnerabilities.^([9](ch08.html#ch01fn29)) The `footprinting_detection` query
    demonstrates how we can detect users carrying out these operations. The implementation
    is very similar to the flooding detection query in the sense that it computes
    the mean, standard deviation, and outlier to detect `**Users**` with anomalous
    behavior.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的网络攻击是足迹侦测。`Footprinting`会在短时间内调用服务的许多端点，试图了解其配置、行为和漏洞。^([9](ch08.html#ch01fn29))
    `footprinting_detection`查询展示了我们如何检测执行这些操作的用户。其实现与洪泛检测查询非常相似，因为它计算平均值、标准差和异常值来检测`**Users**`的异常行为。
- en: 'This query has three parameters: `n_sigma` sets the threshold for determining
    an outlier, and `start_date` and `end_date` determine the time window in which
    we want to detect footprinting.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询有三个参数：`n_sigma`设置确定异常值的阈值，而`start_date`和`end_date`确定我们希望检测足迹的时间窗口。
- en: 'First, we select all **`Events`** that are of type `"request"` and that occurred
    between `start_date` and `end_date`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们选择所有类型为**`Events`**的“请求”，并且发生在`start_date`和`end_date`之间：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we record all the endpoint requests by each user. We do this by traversing
    from **`Events`** to `**User**` using the **`User_Event`** edge type. We add every
    endpoint that the user has called to `event.@api_map`. Because the maps are attached
    to each event, each event will have a single map entry:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们记录每个用户的所有端点请求。我们通过从**`Events`**到**`User`**使用**`User_Event`**边类型进行这样做。我们将用户调用的每个端点都添加到`event.@api_map`中。因为这些映射附加到每个事件，每个事件将具有单个映射条目：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we traverse from **`Events`** to `**Service**` to group the endpoint requests
    by service:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从**`Events`**到**`Service`**进行遍历，将端点请求按服务分组：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then compute outlier statistics as we did in the flooding detection query.
    There is a small difference here between the flooding detection and footprinting
    detection queries. The flooding detection’s `MapAccum` value type is `SumAccum<INT>`.
    It is already a sum. In footprinting detection, the `MapAccum` value type is `SetAccum<STRING>`:
    a collection of names of endpoints. To compute a mean, we need to know how many
    endpoints are in each set, thus `cnt.size()`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们计算异常值统计，与洪水检测查询中的操作类似。在洪水检测中，`MapAccum`的值类型为`SumAccum<INT>`，它已经是一个总和。在足迹检测中，`MapAccum`的值类型为`SetAccum<STRING>`：一个端点名称的集合。要计算平均值，我们需要知道每个集合中有多少个端点，因此使用`cnt.size()`：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The standard deviation and outlier computations are exactly analogous to the
    computations in the flooding detection query. Running the query with the default
    input values shows that user 1 has unusually high use of services 13 and 14.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差和异常值计算与洪水检测查询中的计算完全类似。使用默认输入值运行查询显示，用户1对服务13和14的使用异常高。
- en: Tracing the source of an alert
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 追踪警报来源
- en: In our last example, an alert has already been raised, and we follow a path
    in the graph to track down the users and their IP addresses that may have caused
    an alert. The path we will follow is illustrated in [Figure 8-5](#path_traversal_to_file_the_source_of_an).
    We start from the most recent `**Alert**` of a particular `**Alert_Type**` that
    was raised and then trace backward to its cause. From the `**Alert**`, we follow
    links to the `**Service**` that raised the `**Alert**`. If the `**Alert_Type**`
    is data corruption of a file, the `**Alert**` would be noticed during a file read
    `**Event**`, so we trace back to that. A write `**Event**` would have caused the
    corruption, so we trace back to that. Finally, we trace back to the `**UserID**`
    and the `**IP**` that performed that write. The overall flow of this query is
    eight hops in a straight line. With traditional relational databases, this would
    be eight joins, which is prohibitively slow. In contrast, we can obtain this insight
    in real time by traversing the graph model directly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一个示例中，已经触发了一个警报，我们沿着图中的路径跟踪用户及其可能导致警报的IP地址。我们将要跟踪的路径在[图8-5](#path_traversal_to_file_the_source_of_an)中有所说明。我们从最近的特定`**Alert_Type**`的`**Alert**`开始，然后向后追溯到其原因。从`**Alert**`开始，我们跟随到引发`**Alert**`的`**Service**`。如果`**Alert_Type**`是文件数据损坏，那么在文件读取`**Event**`期间会注意到`**Alert**`，因此我们追溯到那时。写入`**Event**`会导致损坏，因此我们追溯到那时。最后，我们追溯到执行该写入的`**UserID**`和`**IP**`。这个查询的整体流程是直线上的八次跳跃。在传统关系数据库中，这将是八次连接，速度非常慢。相比之下，通过直接遍历图模型，我们可以实时获取这些洞察。
- en: '![Path traversal to file the source of an alert](assets/gpam_0805.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![路径遍历以查找警报来源](assets/gpam_0805.png)'
- en: Figure 8-5\. Path traversal to file the source of an alert
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-5\. 追踪警报来源的路径遍历
- en: 'The `alert_source_tracing` query has three input parameters: `alert_type` is
    the type of alert to trace; `num_days` is the number of days to look back starting
    from the moment the alert was raised; and `top_ip` is the quantity of IP addresses
    the query will return:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`alert_source_tracing`查询有三个输入参数：`alert_type`是要追踪的警报类型；`num_days`是从警报被触发时开始往回查看的天数；`top_ip`是查询将返回的IP地址的数量。'
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The two `MaxAccum` accumulators `@latest_alert_time` and `@latest_read_time`
    compute and record the times of the most recent alert and the most recent read
    events responsible for the alerts, respectively. `SumAccum<INT> @coun``t` counts
    the number of write events per user or IP, so that we know which IP addresses
    are the most prolific. The `ListAccum<EDGE> @path_list` collects all the edges
    needed to represent the paths from the input `alert_type` back to the `**IP**`
    vertices that seem to have triggered those alerts.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`MaxAccum`累加器`@latest_alert_time`和`@latest_read_time`分别计算并记录了最近一次警报和导致警报的最近读取事件的时间。`SumAccum<INT>
    @count`统计每个用户或IP的写入事件数量，以便了解哪些IP地址最为频繁。`ListAccum<EDGE> @path_list`收集了从输入的`alert_type`到触发这些警报的**IP**顶点的路径所需的所有边。
- en: 'We group the eight hops into four two-hop stages. In the first stage, we get
    `**Alerts**` of the given `alert_typ``e` and then trace back to the affected `**Service**`.
    Each **`Alert`**’s date is added to its `**Service**`’s `@latest_alert_time` accumulator.
    Because it is a `MaxAccum`, it automatically retains the most recent alert date.
    We add the edges that we traverse for these two hops to `@path_list` accumulators
    at the endpoints of our traversal so far:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将八次跳跃分组为四个两跳阶段。在第一阶段，我们获取给定`alert_type`的`**Alerts**`，然后追溯到受影响的`**Service**`。每个**`Alert`**的日期都添加到其`**Service**`的`@latest_alert_time`累加器中。因为它是`MaxAccum`，它自动保留最近的警报日期。到目前为止，我们遍历的两个跳的边缘被添加到我们遍历路径的端点的`@path_list`累加器中：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the second stage, we traverse back from these services to files that were
    read and that triggered the alert. We traverse two more hops to go from these
    `**Services**` back to the file `**Resource**` via a read `**Event**`. We only
    consider events that were reasonable triggers for the alert, occurring within
    one day before the alert:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二阶段，我们从这些服务回溯到被读取并触发警报的文件。我们再进行两次跳跃，从这些`**Services**`通过读取`**Event**`回到文件`**Resource**`。我们只考虑在警报前一天内合理触发警报的事件：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After selecting the appropriate file read events, we perform two tasks. First,
    we record the time of the most recent read to each file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择适当的文件读取事件之后，我们执行两项任务。首先，记录每个文件最近读取的时间：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Second, we transfer the partial paths from the first hop to the **`Resource`**
    vertices and extend the paths with the edges that connect **`Service`** to **`Resource`**:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们将第一跳的部分路径传输到`**Resource**`顶点，并使用连接**`Service`**到**`Resource`**的边扩展路径：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the third stage, we trace back from those files to users who wrote to those
    files. This double-hop traversal is structurally similar to the stage two traversal.
    This stage starts from `**Resource**` vertices to `**User**` vertices using the
    **`Output_To_Resource`** and **`User_Event`** edges. It accepts events that are
    writes and that occurred up to `num_days` days before the latest read. In addition,
    we increment `user.@count` to store the number of times the user has written to
    the file, and we again transfer and extend the paths:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三阶段，我们从这些文件追溯到写入这些文件的用户。这种双跳遍历在结构上与第二阶段的遍历类似。该阶段从`**Resource**`顶点到`**User**`顶点开始，使用**`Output_To_Resource`**和**`User_Event`**边。它接受那些在最新读取前`num_days`天内发生的写入事件。此外，我们增加`user.@count`来存储用户写入文件的次数，然后再次传输和扩展路径：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this final stage of the query, we trace back from those user vertices, through
    login events, ending at the IP addresses that caused the alert. We start our traversal
    from the `**User**` vertices and perform a double hop using **`User_Event`** and
    **`Has_IP`** edges. We use accumulators to transfer and extend the paths one more
    time. The paths now have length 8, from `**Alert_Type**` to `**IP**`. We also
    compute the number of times a user has written to the file per IP address. Finally,
    we sort the list of IPs by write count and only take the `top_ip` addresses to
    return:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询的最后阶段，我们从用户顶点追溯回那些引发警报的IP地址。我们从`**User**`顶点开始遍历，并使用**`User_Event`**和**`Has_IP`**边进行双跳。我们使用累加器传输和扩展路径一次。路径现在的长度为8，从`**Alert_Type**`到`**IP**`。我们还计算用户每个IP地址写入文件的次数。最后，我们按写入计数对IP地址列表进行排序，并仅获取`top_ip`地址返回：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using the default input values (`alert_type` = `"Data Corrupted"`, `num_days`
    = 7, and `top_ip` = 3), we find that the top IP sources of file corruption have
    31, 18, and 11 events, respectively, of a user writing to an eventually corrupted
    file, within the time window. The visual display of the paths explains how we
    arrived at these sums.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认输入值（`alert_type` = `"Data Corrupted"`，`num_days` = 7，`top_ip` = 3），我们发现文件损坏的前三个IP来源分别为31、18和11个事件，表示用户在时间窗口内写入最终损坏的文件。路径的可视化显示解释了我们如何得出这些总数。
- en: Chapter Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: In this chapter, we have shown how graphs can strengthen cybersecurity. Cyberattacks
    follow patterns, and these patterns can be represented as a graph query. We demonstrated
    detection queries for three types of attacks, a risk-assessment query that measures
    the proximity to banned IPs, and a source-tracing query to see who and what caused
    an alert.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了图如何加强网络安全。网络攻击遵循模式，这些模式可以表示为图查询。我们展示了针对三种攻击类型的检测查询，一种风险评估查询，该查询测量与禁止IP的接近程度，以及源追踪查询，查看是谁以及什么导致了警报。
- en: ^([1](ch08.html#ch01fn21-marker)) Ponemon Institute, *2019 Global State of Cybersecurity
    in Small and Medium-Sized Businesses*, 2019, [*https://www.cisco.com/c/dam/en/us/products/collateral/security/ponemon-report-smb.pdf*](https://www.cisco.com/c/dam/en/us/products/collateral/security/ponemon-report-smb.pdf).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.html#ch01fn21-marker)) Ponemon Institute，《2019年中小型企业全球网络安全状况报告》，2019年，[*https://www.cisco.com/c/dam/en/us/products/collateral/security/ponemon-report-smb.pdf*](https://www.cisco.com/c/dam/en/us/products/collateral/security/ponemon-report-smb.pdf)。
- en: ^([2](ch08.html#ch01fn22-marker)) Mark Mazzetti and Katie Benner, “12 Russian
    Agents Indicted in Mueller Investigation,” *New York Times*, July 13, 2018, [*https://www.nytimes.com/2018/07/13/us/politics/mueller-indictment-russian-intelligence-hacking.html*](https://www.nytimes.com/2018/07/13/us/politics/mueller-indictment-russian-intelligence-hacking.html).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.html#ch01fn22-marker)) Mark Mazzetti和Katie Benner，《穆勒调查中起诉的12名俄罗斯特工》，*纽约时报*，2018年7月13日，[*https://www.nytimes.com/2018/07/13/us/politics/mueller-indictment-russian-intelligence-hacking.html*](https://www.nytimes.com/2018/07/13/us/politics/mueller-indictment-russian-intelligence-hacking.html)。
- en: ^([3](ch08.html#ch01fn23-marker)) IBM Security, “Cost of a Data Breach Report
    2020,” 2020, [*https://www.ibm.com/downloads/cas/QMXVZX6R*](https://www.ibm.com/downloads/cas/QMXVZX6R).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch08.html#ch01fn23-marker)) IBM Security，《2020年数据泄露成本报告》，2020年，[*https://www.ibm.com/downloads/cas/QMXVZX6R*](https://www.ibm.com/downloads/cas/QMXVZX6R)。
- en: '^([4](ch08.html#ch01fn24-marker)) Acronis, *Acronis Cyber Protection Operation
    Center Report: Cyberthreats in the Second Half of 2022 – Data Under Attack*, 2022,
    [*https://dl.acronis.com/u/rc/White-Paper-Acronis-Cyber-Protect-Cloud-Cyberthreats-Report-Year-End-2022-EN-US-221212.pdf*](https://dl.acronis.com/u/rc/White-Paper-Acronis-Cyber-Protect-Cloud-Cyberthreats-Report-Year-End-2022-EN-US-221212.pdf).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch08.html#ch01fn24-marker)) Acronis，《Acronis网络保护运营中心报告：2022年下半年的网络威胁——数据遭受攻击》，2022年，[*https://dl.acronis.com/u/rc/White-Paper-Acronis-Cyber-Protect-Cloud-Cyberthreats-Report-Year-End-2022-EN-US-221212.pdf*](https://dl.acronis.com/u/rc/White-Paper-Acronis-Cyber-Protect-Cloud-Cyberthreats-Report-Year-End-2022-EN-US-221212.pdf)。
- en: ^([5](ch08.html#ch01fn25-marker)) “CAPEC List Version 3.9,” CAPEC, last updated
    October 21, 2021, [*https://capec.mitre.org/data/index.html*](https://capec.mitre.org/data/index.html).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch08.html#ch01fn25-marker)) “CAPEC列表版本3.9”，CAPEC，最后更新于2021年10月21日，[*https://capec.mitre.org/data/index.html*](https://capec.mitre.org/data/index.html)。
- en: ^([6](ch08.html#ch01fn26-marker)) “What Is Cybersecurity?” Cybersecurity & Infrastructure
    Security Agency, February 1, 2021, [*https://www.cisa.gov/news-events/news/what-cybersecurity*](https://www.cisa.gov/news-events/news/what-cybersecurity).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch08.html#ch01fn26-marker)) “什么是网络安全？”网络安全与基础设施安全局，2021年2月1日，[*https://www.cisa.gov/news-events/news/what-cybersecurity*](https://www.cisa.gov/news-events/news/what-cybersecurity)。
- en: '^([7](ch08.html#ch01fn27-marker)) “CAPEC-554: Functionality Bypass,” CAPEC,
    last updated October 21, 2021, [*https://capec.mitre.org/data/definitions/554.html*](https://capec.mitre.org/data/definitions/554.html).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch08.html#ch01fn27-marker)) “CAPEC-554：功能绕过”，CAPEC，最后更新于2021年10月21日，[*https://capec.mitre.org/data/definitions/554.html*](https://capec.mitre.org/data/definitions/554.html)。
- en: '^([8](ch08.html#ch01fn28-marker)) “CAPEC-125: Flooding,” CAPEC, last updated
    October 21, 2021, [*https://capec.mitre.org/data/definitions/125.html*](https://capec.mitre.org/data/definitions/125.html).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch08.html#ch01fn28-marker)) “CAPEC-125：洪水攻击”，CAPEC，最后更新于2021年10月21日，[*https://capec.mitre.org/data/definitions/125.html*](https://capec.mitre.org/data/definitions/125.html)。
- en: '^([9](ch08.html#ch01fn29-marker)) “CAPEC-169: Footprinting,” CAPEC, last updated
    October 21, 2021, [*https://capec.mitre.org/data/definitions/169.html*](https://capec.mitre.org/data/definitions/169.html).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch08.html#ch01fn29-marker)) “CAPEC-169：足迹”，CAPEC，最后更新于2021年10月21日，[*https://capec.mitre.org/data/definitions/169.html*](https://capec.mitre.org/data/definitions/169.html)。
