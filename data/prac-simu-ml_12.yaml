- en: Chapter 10\. Using Cameras in Simulations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。在模拟中使用相机
- en: It’s time to get some real vision. And we don’t mean the shiny robot man, we
    mean cameras (and lights, and action). In this chapter, we’re going to look at
    how you can use a camera that sees the world of your simulation as an observation
    for your agents.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候获得一些真正的视觉了。我们不是指闪亮的机器人，而是指相机（还有灯光和行动）。在这一章中，我们将看看如何使用一台相机将你的模拟世界作为代理的观察结果。
- en: No longer will your observations be bound by feeding your agent numbers from
    code, and from sensors! Instead, you’ll be bound by what the camera you choose
    to set up can see. (Which, if we’re getting technical, are also numbers, but we
    digress.)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你不再需要通过代码向代理输入数字或从传感器输入观测结果！相反，你将受限于你选择设置的相机能够看到的内容。（从技术上讲，这也是数字，但我们离题了。）
- en: Observations and Camera Sensors
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察结果和相机传感器
- en: So far, all the observations we’ve been using are basically numbers—usually
    `Vector3`s—that we’ve been providing to the agent via our `CollectObservations`
    method, or collecting by using sensors of some kind, looking into our environment
    to measure things, or using grid-based observations for a 2D spatial representation
    of things.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的所有观察结果基本上都是数字——通常是`Vector3`——我们通过`CollectObservations`方法向代理提供，或者通过某种类型的传感器收集，观察环境来测量事物，或者使用基于网格的观察结果进行二维空间表示。
- en: We’ve either implemented `CollectObservations()` in our `Agent`, and passed
    in vectors, and other forms of numbers, or we’ve added components to the agent
    in the Unity Editor, which have—under the hood—created raycasts (perfect lasers
    to measure distances and what they hit) and automatically passed the numbers arising
    from those into the ML-Agents system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Agent`中要么实现了`CollectObservations()`，并传入了向量和其他形式的数字，要么在Unity编辑器中向代理添加了组件，这些组件在幕后创建了射线投射（完美的激光用于测量距离和其击中的内容），并自动将这些数字传递给ML-Agents系统。
- en: 'There’s another way to provide observations to our agent: by using `CameraSensor`
    and `RenderTextureSensor`. These allow us to pass image information, in the form
    of a 3D Tensor, to the convolutional neural network (CNN) of the agent policy.
    So, basically, more numbers. But from our perspective, it’s a *picture*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种方法可以向我们的代理提供观测结果：通过使用`CameraSensor`和`RenderTextureSensor`。这些允许我们传递图像信息，以3D张量的形式，给代理策略的卷积神经网络（CNN）。所以，基本上是更多的数字。但从我们的角度来看，这是一幅*图片*。
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '[Convolutional neural network](https://oreil.ly/kPfSW) is often used as a term
    to describe any form of neural network that deals with images.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[卷积神经网络](https://oreil.ly/kPfSW)通常用作描述处理图像的任何形式的神经网络的术语。'
- en: Using images as observations allows an agent to learn from spatial regularities
    in the images it receives in order to form a policy.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图像作为观察结果允许代理从图像中的空间规律中学习，以形成策略。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can combine visual observations with the vector observations you’ve already
    used. We’ll get to that later.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将视觉观察结果与已经使用的向量观察结果结合起来。我们稍后再讨论这个。
- en: Broadly speaking, adding a `CameraSensor` to your agents is quite straightforward,
    and as with many things in Unity, it involves adding a component in the Inspector.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上说，向你的代理添加`CameraSensor`非常简单，和在Unity中的许多其他操作一样，涉及在检视面板中添加一个组件。
- en: 'We’ll be working through a full example in this chapter momentarily, but the
    typical steps are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们马上就会通过一个完整的例子来详细讨论，但典型的步骤如下：
- en: In the Unity Editor, locate your agent in the Hierarchy and select it.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中，定位到场景层次结构中的代理并选择它。
- en: In the Inspector for the agent, use the Add Component button to add a Camera
    Sensor component.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代理的检视面板中，使用“添加组件”按钮添加一个相机传感器组件。
- en: In the Camera Sensor component that gets added, assign the camera (from any
    camera in the Hierarchy) to the Camera field.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加的相机传感器组件中，将相机（从层次结构中的任何相机）分配给相机字段。
- en: You can also name the camera sensor, and specify a width and height and whether
    you want the image the neural network is working with to be grayscale or not.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以为相机传感器命名，并指定宽度、高度以及神经网络处理的图像是否为灰度。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Every sensor component (whether it’s a camera or otherwise) must have a unique
    sensor name, on a per-agent basis.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个传感器组件（无论是相机还是其他）必须在每个代理上具有唯一的传感器名称。
- en: We’ll come back to the camera sensor shortly, and discuss how to connect a camera
    to it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会回到相机传感器，并讨论如何连接相机到其中。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Visual observations are useful when it’s difficult to numerically represent
    the state you want your agent to work with using vectors, but they can make your
    agent slower to train.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当难以用向量数值化表示您希望代理程序处理的状态时，视觉观察是很有用的，但可能会使您的代理训练速度变慢。
- en: Building a Camera-Only Agent
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建仅相机代理
- en: To demonstrate the use of a camera sensor, our activity for this chapter is
    the creation of a very simple simulation that solely relies on a camera for its
    observations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示相机传感器的使用，本章的活动是创建一个非常简单的模拟，仅依赖于相机进行观察。
- en: The simulation we’re going to build is a cube agent (surprising nobody, dear
    reader, it exists in a void) that must keep a sphere (also known as a ball, but
    not an agent ball) balanced on its top.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将构建的模拟是一个立方体代理（亲爱的读者，它存在于虚空中），必须在其顶部保持一个球（也称为球，但不是代理球）平衡。
- en: 'First, as you’ve done a few times, create a new empty Unity project and import
    the ML-Agents package. Then, in a new scene, do the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，像以前做过几次一样，在Unity中创建一个新的空项目，并导入ML-Agents包。然后，在一个新场景中，执行以下操作：
- en: Create a new cube in the Hierarchy, and name it “Agent.”
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中创建一个新的立方体，并命名为“代理”。
- en: Create a new sphere in the Hierarchy, and name it “Ball.”
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中创建一个新的球体，并命名为“球”。
- en: Set the scale of the agent cube to `(5, 5, 5)`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代理立方体的比例设置为`(5, 5, 5)`。
- en: Move the ball sphere above the agent, as shown in [Figure 10-1](#fig:Visual-vis).
    An approximate placement is fine; you just need the ball floating in the space
    above the cube somewhere.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将球体移动到代理上方，如[图10-1](#fig:Visual-vis)所示。大致位置即可；您只需让球在立方体上方的空间中浮动即可。
- en: '![psml 1001](assets/psml_1001.png)'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1001](assets/psml_1001.png)'
- en: Figure 10-1\. The ball above the cube
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-1\. 立方体上方的球
- en: Next, create a new empty object in the Hierarchy, name it something like “Balancing
    Ball,” and drag the agent and the ball under it, as children. This represents
    the entire simulation environment.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在层次结构中创建一个新的空对象，命名为“平衡球”，并将代理和球拖到其下作为子对象。这代表整个模拟环境。
- en: That’s it for now. We promise we’re going somewhere with this.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目前就这些了。我们保证我们正在做某些事情。
- en: Coding the Camera-Only Agent
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写仅相机代理的代码
- en: Now we’re going to write the code that drives our simple agent. To get coding,
    as usual create a new script asset as a component on the agent. We named ours
    “BalancingBallAgent.” Double-click the new asset file for your code in the Project
    view to open it in your code editor.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写驱动我们简单代理的代码。要开始编码，像往常一样，在项目视图中创建一个新的脚本资产作为代理的组件。我们将其命名为“BalancingBallAgent”。双击项目视图中的新资产文件以在您的代码编辑器中打开它。
- en: 'Once you’ve got the file open in your code editor, follow these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在代码编辑器中打开文件后，请按照以下步骤操作：
- en: 'Add the following imports so that you get all the bits of Unity you need:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下导入，以便获取Unity所需的所有部分：
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We obviously need a bunch of stuff from ML-Agents, but we also want Unity’s
    random number system so that we can generate random numbers.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们显然需要从ML-Agents中获取大量内容，但我们也想要Unity的随机数系统，以便我们可以生成随机数。
- en: 'Next, delete the entire class that’s been provided for you, and replace it
    with:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，删除为您提供的整个类，并替换为：
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that you’ll need to make sure the class name is the same as the asset file
    you created. Naturally, it will descend from `Agent`.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，您需要确保类名与您创建的资产文件相同。当然，它将从`Agent`继承。
- en: 'Add some member variables, one to store a reference to the `GameObject` that
    is the ball, and another to that ball’s `Rigidbody`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些成员变量，一个用于存储作为球体的`GameObject`引用，另一个用于该球体的`Rigidbody`：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, override the `Initialize()` method, which comes from `Agent` and is called
    once when the agent is first enabled:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，覆盖`Initialize()`方法，这来自`Agent`，在代理首次启用时调用一次：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inside `Initialize()`, we get a handle on the ball’s `Rigidbody`, and could
    do other setup if we needed to (but we don’t right now).
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`Initialize()`内部，我们获取球体的`Rigidbody`的句柄，并可以进行其他设置（但目前不需要）。
- en: 'Override the `Heuristic()` method, which also comes from `Agent` and allows
    us to manually control the agent:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`Heuristic()`方法，这也来自`Agent`，允许我们手动控制代理：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As usual, `Heuristic()` allows the agent to choose an action using a custom
    heuristic. This means you can provide some sort of custom decision-making logic
    that’s separate from any machine learning. Most commonly this is used to provide
    manual control of an agent, by a human, and that’s what we’re doing here. We’ll
    use it to test the agent, and not train it, though (we’re not doing IL or GAIL
    this time).
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 像往常一样，`Heuristic()`允许代理使用自定义启发式选择动作。这意味着您可以提供一些与任何机器学习分开的自定义决策逻辑。最常见的用途是由人类提供对代理的手动控制，这正是我们在这里所做的。我们将用它来测试代理，而不是训练它，尽管（这次我们不进行IL或GAIL）。
- en: 'Our code should be pretty familiar to you by now, if you’ve been working through
    the book sequentially, but essentially it:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，如果你按顺序阅读本书，我们的代码应该对你来说已经很熟悉了，但本质上它：
- en: Gets the continuous component of the `ActionBuffers` being passed to the method.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取传递给该方法的`ActionBuffers`的连续部分。
- en: Gets the first entry in the array of continuous actions, and assigns the negative
    value of the horizontal input to it.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取连续动作数组中的第一个条目，并将水平输入的负值赋给它。
- en: Gets the second entry in the array of continuous actions, and assigns the value
    of the vertical input to it.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取连续动作数组中的第二个条目，并将垂直输入的值赋给它。
- en: Note
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For information on Unity’s Input Manager, check the [Unity documentation](https://oreil.ly/WOjxC).
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关Unity输入管理器的信息，请查阅[Unity文档](https://oreil.ly/WOjxC)。
- en: 'Next, we’ll implement the `OnEpisodeBegin()` function, also from `Agent`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`Agent`中的`OnEpisodeBegin()`函数：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this function, we do what we need to do to set the agent and environment
    up at the beginning of a training episode. For our ball-balancing agent, we need
    to:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个函数中，我们需要做的是在训练周期开始时设置代理和环境。对于我们的平衡球代理，我们需要：
- en: Set the agent’s rotation to the default position.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代理的旋转设置为默认位置。
- en: Randomly rotate the agent on the x-axis, somewehere between `-10` and `10`.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在x轴上随机旋转代理，在`-10`到`10`之间。
- en: Randomly rotate the agent on the z-axis, somewhere between `-10` and `10`.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在z轴上随机旋转代理，在`-10`到`10`之间。
- en: Set the ball’s `Rigidbody` velocity to nothing.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将球的`Rigidbody`速度设为零。
- en: Randomly position the ball itself to somewhere between `-1.5` and `1.5` on the
    x- and z-axes, and at `4` on the y-axis (which should roughly be the height you
    placed it earlier), so it’s always at the same height above the agent, but in
    a different place above it.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将球本身的位置随机设置在x轴和z轴之间的`-1.5`到`1.5`之间，并且在y轴上为`4`（这大致是您之前放置的高度），这样它始终位于代理的正上方，但是在不同的位置上。
- en: 'Finally, for the code, we implement `OnActionReceived()`. We’ll do this in
    pieces, because it’s quite a bit of code. First, we’ll implement the skeleton:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于代码，我们实现`OnActionReceived()`。我们将分段实现，因为这是相当多的代码。首先，我们将实现框架：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method is called to allow the agent to execute some actions. What it executes
    is based on the contents of the `ActionBuffers` passed in.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法被调用以允许代理执行一些动作。它执行的操作基于传入的`ActionBuffers`的内容。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `ActionBuffers` bits of the `Agent` system come specifically from the `Unity.MLAgents.Actuators`
    component that we imported earlier.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Agent`系统中的`ActionBuffers`位元特别来自我们之前导入的`Unity.MLAgents.Actuators`组件的连续部分。'
- en: The code we’ve implemented so far creates some temporary variables holding z-axis
    and x-axis actions for our agent. Specifically, we use `Clamp`, and pass in the
    contents of each of the components of the continuous actions component of the
    `ActionBuffers`, clamping between `-1` and `1`, then we multiply the result by
    2 to magnify the effect a bit.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们实现了一些临时变量来保存我们代理的z轴和x轴动作。具体来说，我们使用了`Clamp`，并传入了连续动作组件的每个部分的内容，将其限制在`-1`到`1`之间，然后将结果乘以2以增强效果。
- en: Note
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `Clamp` function we use here, which we’ve done a few times in the past,
    takes a value (in this case something from the `ActionBuffers` array), and returns
    that value if it is between the subsequent two values (in this case, `-1` and
    `1`). Otherwise, it returns the smaller value if the initial value is less than
    it, or the larger value if the initial value is greater than it.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里使用的`Clamp`函数，在过去的几次使用中，接受一个值（在本例中来自`ActionBuffers`数组），如果它在后续的两个值之间（在本例中为`-1`和`1`），则返回该值。否则，如果初始值小于它，则返回较小的值；如果初始值大于它，则返回较大的值。
- en: 'Next, below this initial code but still within `OnActionReceived()`, add:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在这个初始代码下方但仍在`OnActionReceived()`内，添加：
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code checks whether the z-axis of our agent’s rotation is less than `0.25`
    and the passed-in z-axis action is greater than `0`, or whether the z-axis of
    our agent’s rotation is greater than `-0.25` and the passed-in z-axis action is
    less than `0`. If either of those is true, it calls [`Rotate`](https://oreil.ly/VpVXb),
    asking for a rotation on the z-axis of the amount specified in the `action_z`
    variable we created earlier (which contains the passed-in z-axis action).
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码检查我们代理的旋转的 z 轴是否小于`0.25`，并且传入的 z 轴动作是否大于`0`，或者我们代理的旋转的 z 轴是否大于`-0.25`，并且传入的
    z 轴动作是否小于`0`。如果其中任一条件为真，则调用[`Rotate`](https://oreil.ly/VpVXb)，请求按照我们早些时候创建的`action_z`变量中指定的数量在
    z 轴上旋转。
- en: Then we do the same thing again, but for the x-axis.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们对 x 轴执行相同的操作。
- en: 'Next, still within the method, and below the code you just wrote, add the following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在方法内部，在刚刚编写的代码下面，添加以下内容：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code checks if the difference between the position of the ball on the y-axis
    and the position of the agent on the y-axis is less than `-2`, or similarly on
    the x- and z-axes, checks if the difference is greater than `3`. Why? Any of these
    things might indicate the ball has left the top of the agent and fallen off or
    done something else strange. And that means the simulation should end the episode,
    and the agent should receive a penalty (in this case, of `-1`).
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码检查球在 y 轴上的位置与代理在 y 轴上的位置之差是否小于`-2`，或者类似地在 x 和 z 轴上检查差值是否大于`3`。为什么？任何这些情况可能表明球已经离开了代理的顶部并掉下去或者做了其他奇怪的事情。这意味着模拟应该结束本轮，并且代理应该收到处罚（在这种情况下是`-1`）。
- en: Otherwise, a small reward of `0.1` is provided, as the ball is probably still
    on the top surface of the agent, and all is well in the world.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则，作为小奖励，球很可能仍然在代理的顶部表面，一切都很顺利，提供了`0.1`的奖励。
- en: That’s all the code! Don’t forget to save before you switch back to the Unity
    Editor.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些代码！在切换回 Unity 编辑器之前别忘了保存。
- en: Adding a New Camera for the Agent
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为代理添加新摄像头
- en: Next we need to add an additional camera for the agent to use as its observations.
    We’ll do this by adding objects to the world in our scene, in the Unity Editor.
    Cameras are, by default, not coded by you, and are physical but invisible things
    that we add to the Unity world.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为代理添加一个额外的摄像头，用作其观察。我们将通过在 Unity 编辑器中向场景中添加对象来实现这一点。摄像头默认情况下不是由您编写的，它们是我们向
    Unity 世界添加的物理但不可见的东西。
- en: Cameras do have coordinates (i.e., they have a `transform`), and we can see
    them in the Unity Editor (which helps us position them, and where they point),
    but if you had two cameras looking at each other in a scene, they wouldn’t “see”
    each other. There’s nothing physical present.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像头确实有坐标（即它们有一个`transform`），我们可以在 Unity 编辑器中看到它们（这帮助我们定位它们和它们的朝向），但是如果在场景中有两个相互对视的摄像头，它们不会“看见”对方。这并不存在实体物理。
- en: 'To add a camera, follow these steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加摄像头，请按照以下步骤进行：
- en: Use the Hierarchy, and create a new camera as a child of the Balancing Ball
    object (the parent of Agent and Ball), as shown in [Figure 10-2](#fig:anewcamera).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级视图中使用，将一个新摄像头创建为平衡球对象（代理和球的父级）的子对象，如[图 10-2](#fig:anewcamera)所示。
- en: '![psml 1002](assets/psml_1002.png)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1002](assets/psml_1002.png)'
- en: Figure 10-2\. Adding a new camera
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-2\. 添加新摄像头
- en: Rename the new camera something sensible, like “Agent Camera.”
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新摄像头重命名为合适的名称，比如“代理摄像头”。
- en: Position the new agent camera so that it’s pointing down toward the agent and
    the ball, as shown in [Figure 10-3](#fig:Visual-agentcam).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的代理摄像头定位，使其朝向代理和球，如[图 10-3](#fig:Visual-agentcam)所示。
- en: Note
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There will already be a camera in the scene, because every scene comes with
    one. Don’t remove that one. It’s the one you, a human, will use to view the simulation
    as it runs.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 场景中已经有一个摄像头，因为每个场景都会有一个。不要移除它。这是您作为人类观看模拟运行的摄像头。
- en: '![psml 1003](assets/psml_1003.png)'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1003](assets/psml_1003.png)'
- en: Figure 10-3\. Aligning the new agent camera
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-3\. 调整新代理摄像头的位置
- en: Select the agent in the Hierarchy, and use the Add Component button to add a
    Camera Sensor component.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级视图中选择代理，并使用“添加组件”按钮添加一个摄像机传感器组件。
- en: Now, use the Inspector to assign the new agent camera to the Camera field in
    the Camera Sensor component, as shown in [Figure 10-4](#fig:Visual-camassigned).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用检视面板将新代理摄像头分配给摄像机传感器组件中的摄像机字段，如[图 10-4](#fig:Visual-camassigned)所示。
- en: '![psml 1004](assets/psml_1004.png)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1004](assets/psml_1004.png)'
- en: Figure 10-4\. Assigning the camera
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-4\. 分配摄像头
- en: Assign the ball object, from the Hierarchy, to the Ball field in the agent’s
    Inspector, as shown in [Figure 10-5](#fig:Visual-ballagentscript).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代理检视器中的“球体”字段中分配层级中的球体对象，如[图 10-5](#fig:Visual-ballagentscript)所示。
- en: '![psml 1005](assets/psml_1005.png)'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1005](assets/psml_1005.png)'
- en: Figure 10-5\. Assigning the ball in the script
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-5\. 在脚本中分配球
- en: Use the Add Component button to make sure you have Decision Requester and Behavior
    Parameters components attached to the agent.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“添加组件”按钮，确保已将决策请求器和行为参数组件附加到代理上。
- en: Make sure your Behavior Parameters component has a space size of `0` for Vector
    Observations (in that there are none), and `2` Continuous Actions.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的行为参数组件在向量观察中具有`0`的空间大小（即没有观察），并具有`2`个连续动作。
- en: You’ll also want to give the behavior a name. We suggest “BalancingBall” or
    something similar.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要为这个行为命名。我们建议使用“平衡球”或类似的名称。
- en: That’s all we need to do to add a camera. Save your scene before continuing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加相机的全部操作都已完成。在继续之前保存你的场景。
- en: Seeing What the Agent’s Camera Sees
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看代理相机所见内容
- en: 'There are a few ways you can see what the agent’s camera sees. The first is
    quite obvious, and you probably already did it in order to position the camera
    suitably:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以查看代理相机的视图。第一种方法非常明显，你可能已经通过它来适当地定位相机：
- en: Select the agent’s camera in the Hierarchy.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级中选择代理相机。
- en: The Scene view will show a preview of what the camera sees in the bottom righthand
    corner, as shown in [Figure 10-6](#fig:Visual-showingagentcam).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 场景视图将在右下角显示相机所见的预览，如[图 10-6](#fig:Visual-showingagentcam)所示。
- en: '![psml 1006](assets/psml_1006.png)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1006](assets/psml_1006.png)'
- en: Figure 10-6\. Showing what the agent’s camera sees
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-6\. 显示代理相机视图
- en: You can also create a view, showing the special agent camera’s view, and display
    that on top of the Game view, as shown in [Figure 10-7](#fig:seeing_what_cam_sees).
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还可以创建一个视图，展示特殊代理相机的视图，并在游戏视图的顶部显示，如[图 10-7](#fig:seeing_what_cam_sees)所示。
- en: '![psml 1007](assets/psml_1007.png)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1007](assets/psml_1007.png)'
- en: Figure 10-7\. A special view to show the new camera’s view
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-7\. 特殊视图显示新相机的视图
- en: To create this view in your scene in the Unity Editor, create a new Custom Render
    Texture asset in the Project view, as shown in [Figure 10-8](#fig:Visual-custom).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中创建此视图，可以在项目视图中创建一个新的自定义渲染纹理资源，如[图 10-8](#fig:Visual-custom)所示。
- en: '![psml 1008](assets/psml_1008.png)'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1008](assets/psml_1008.png)'
- en: Figure 10-8\. Creating a Custom Render Texture asset
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-8\. 创建一个自定义渲染纹理资源
- en: Set it up as shown in [Figure 10-9](#fig:Visual-camerarendertexture). The defaults
    should be correct.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置如[图 10-9](#fig:Visual-camerarendertexture)所示。默认设置应该是正确的。
- en: '![psml 1009](assets/psml_1009.png)'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1009](assets/psml_1009.png)'
- en: Figure 10-9\. The new render texture asset
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-9\. 新的渲染纹理资源
- en: Name it something sensible, like “cameraRenderTexture.”
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给它一个合理的名称，比如“cameraRenderTexture”。
- en: Select the agent’s camera in the Hierarchy, and in the Target Texture field
    of its Inspector, assign the render texture asset that you just created to it,
    as shown in [Figure 10-10](#fig:Visual-rendertex).
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级中选择代理相机，在其检视器中的目标纹理字段中，分配刚刚创建的渲染纹理资源，如[图 10-10](#fig:Visual-rendertex)所示。
- en: '![psml 1010](assets/psml_1010.png)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1010](assets/psml_1010.png)'
- en: Figure 10-10\. The render texture asset assigned to the agent camera
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-10\. 分配给代理相机的渲染纹理资源
- en: Tip
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Render texture is a game development term, common across all game engines,
    that is created by the engine and updated at runtime. Accordingly, a render texture
    is useful when you want to put the view of a camera in the scene onto something
    that’s shown in the scene or on top of the scene. Render textures are commonly
    used in video games, for example, to display the contents of in-game screens:
    the screen’s view is a render texture, showing what a camera somewhere else (out
    of the player’s view) sees. Learn more about render textures [in the Unity documentation](https://oreil.ly/HkqTA).'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 渲染纹理是一个游戏开发术语，在所有游戏引擎中都很常见，由引擎创建并在运行时更新。因此，渲染纹理在你希望将场景中相机的视图放置在场景中或在场景顶部显示时非常有用。例如，在视频游戏中，常用于显示游戏内屏幕的内容：屏幕视图是一个渲染纹理，显示了摄像机在场景其他位置（玩家视角之外）看到的内容。了解更多关于渲染纹理的内容，可以参考[Unity文档](https://oreil.ly/HkqTA)。
- en: Next, create a canvas in the Hierarchy, as shown in [Figure 10-11](#fig:canvas),
    leaving everything at the defaults.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在层级中创建一个画布，如[图 10-11](#fig:canvas)所示，保持所有默认设置。
- en: '![psml 1011](assets/psml_1011.png)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1011](assets/psml_1011.png)'
- en: Figure 10-11\. Creating a canvas in the Hierarchy
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-11. 在层次结构中创建画布
- en: 'A [canvas](https://oreil.ly/OtlT6) is an object provided by Unity for screen
    rendering; this means it’s typically used for displaying things that go on top
    of the scene (screen versus scene), like the user interface. We’re going to use
    it for a rudimentary noninteractive interface: showing what a camera sees.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[画布](https://oreil.ly/OtlT6)是Unity提供的用于屏幕渲染的对象；这意味着它通常用于显示位于场景顶部的事物（屏幕与场景），如用户界面。我们将使用它来制作一个简易的非交互界面：显示摄像机所见的内容。'
- en: As a child of the canvas, in the Hierarchy, add an empty object and name it
    “Camera View” or something similar, as shown in [Figure 10-12](#fig:Visual-hier)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为画布的子对象，在层次结构中添加一个空对象并命名为“摄像机视图”或类似的名称，如[图10-12](#fig:Visual-hier)所示。
- en: '![psml 1012](assets/psml_1012.png)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1012](assets/psml_1012.png)'
- en: Figure 10-12\. The Hierarchy, showing the new canvas and camera view
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-12. 层次结构，显示新画布和摄像机视图
- en: In this new object’s Inspector, use the Add Component button and add a Raw Image
    component.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此新对象的检视器中，使用“添加组件”按钮并添加一个原始图像组件。
- en: Then, assign the Render Texture asset (from the Project view) that you created
    earlier to the Texture field of the Raw Image component, as shown in [Figure 10-13](#fig:Visual-rendertex2).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将您之前创建的渲染纹理资产（从项目视图中）分配给原始图像组件的纹理字段，如[图10-13](#fig:Visual-rendertex2)所示。
- en: '![psml 1013](assets/psml_1013.png)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1013](assets/psml_1013.png)'
- en: Figure 10-13\. Assigning the texture to the Raw Image component
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-13. 将纹理分配给原始图像组件
- en: Now, using the Rectangle tool (shown in [Figure 10-14](#fig:Visual-rectangletool)),
    resize the Raw Image component in the Scene view and put it in a corner, as shown
    in [Figure 10-15](#fig:Visual-aligning).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用矩形工具（如[图10-14](#fig:Visual-rectangletool)所示），在场景视图中调整原始图像组件的大小并将其放置在角落里，如[图10-15](#fig:Visual-aligning)所示。
- en: '![psml 1014](assets/psml_1014.png)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1014](assets/psml_1014.png)'
- en: Figure 10-14\. The rectangle tool
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-14. 矩形工具
- en: '![psml 1015](assets/psml_1015.png)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 1015](assets/psml_1015.png)'
- en: Figure 10-15\. Putting the Raw Image component into the corner
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-15. 将原始图像组件放置在角落里
- en: Now when you run the simulation, you’ll see the main camera’s view as normal,
    as well as a small view of the agent’s camera. You can use this technique to add
    views for your own consumption to any of the simulations you make. Even if the
    agent doesn’t use a camera, there’s nothing stopping you from adding cameras to
    capture different perspectives.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您运行模拟时，您将会看到主摄像机的视图和代理摄像机的小视图，就像往常一样。您可以使用此技术为您自己对任何您创建的模拟添加视图。即使代理不使用摄像机，也没有阻止您添加摄像机以捕捉不同的视角。
- en: Training the Camera-Based Agent
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练基于摄像机的代理
- en: 'To train the agent, you’ll need a YAML file for your hyperparameters, as usual
    (what a huge surprise, you say!). Here’s the one we recommend using, but feel
    free to experiment:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要训练代理，您通常需要一个用于超参数的YAML文件（你会说：“这真是个巨大的惊喜！”）。这是我们建议使用的文件，但请随意尝试：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the YAML file ready to go, run the training by executing `mlagents-learn`
    on the command line:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用准备好的YAML文件后，通过在命令行上执行`mlagents-learn`来运行训练：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Warning
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Your behavior name on the Behavior Parameters component of the agent will need
    to match the behavior name in the YAML file, as usual.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您在代理的行为参数组件上的行为名称需要像往常一样与YAML文件中的行为名称匹配。
- en: Training using only visual observations will take a lot longer than training
    using vector observations. Our training process, using the preceding YAML file,
    took about two hours on a recent MacBook Pro.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用视觉观察进行训练将比使用向量观察进行训练需要更长的时间。我们的训练过程，使用前述的YAML文件，在最近的MacBook Pro上大约花费了两个小时。
- en: When the training is complete, run your agent with the *.onnx* file that’s been
    output, and see how it goes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当训练完成时，使用生成的*.onnx*文件来运行您的代理，看看效果如何。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Explore combining visual observations with vector and other observation types.
    See if you can combine them to produce an agent that can be trained more quickly.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 探索将视觉观察与向量和其他观察类型结合使用。看看是否可以将它们结合起来以快速训练代理。
- en: Cameras and You
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄像机和您
- en: It’s very tempting to use cameras constantly and for everything. We get it!
    They’re exciting, and it’s kind of magical to give your agent virtual eyes and
    just let them loose to solve whatever problem you might need them to address.
    But it’s rarely the best approach.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一直使用摄像机并把它们用于所有事情非常诱人。我们明白！它们很令人兴奋，给您的代理虚拟眼睛并让它们解决您可能需要解决的任何问题，这种感觉有点神奇。但这很少是最佳的方法。
- en: Cameras are at their most obviously useful when you’re building a simulation
    that represents *something* you might then build in the real world, and when that
    *something* will actually have cameras. If you’re building a simulation of a complex
    self-driving car, or a drone, or a pick-and-place robot, and plan to use part
    or all of the model that you generate in a real-world version of the same, and
    it has cameras, then of course it makes sense to use cameras in your simulation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在构建一个模拟仿真，这个仿真代表*某个*你随后可能在现实世界中建造的东西时，摄像头显然是最有用的。当那*某个*东西实际上会使用摄像头时，比如构建一个复杂的自动驾驶汽车、无人机或者拾取放置机器人的仿真，并且计划在实际中使用你生成的模型的一部分或全部时，使用摄像头当然是有道理的。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Giving an agent *just* a camera is about the same as a human that only has sight—only
    receiving visual information about our environment is a very complex proposition.
    It’s much better paired with or complementary to other sensory inputs. Agents
    often have objectives that are performing some action, but not necessarily physically
    changing an environment. There are quite often actions an agent can take that
    won’t change camera input, which means they might not get any feedback about it
    because there wasn’t a *visible* state change to the environment. An agent needs
    its actions to have a measurable impact on the environment (beyond its rewards)
    if it’s only got visual observations coming in, as it needs to know *something*
    has happened in the environment as a result of its actions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个代理程序**仅仅**配备了摄像头，那就像一个只有视觉信息的人类一样——只能接收到我们环境的视觉信息是一个非常复杂的问题。它更好地与其他感官输入配对或互补。代理程序通常有一些动作的目标，但不一定会在物理上改变环境。经常有一些代理程序可以执行的动作不会改变摄像头的输入，这意味着它们可能不会因为环境中没有**可见**的状态变化而得到任何反馈。如果代理程序仅仅接收视觉观察结果，那么它需要知道由于它的动作而环境发生了*某种*变化（除了其奖励以外）。
- en: 'If you’re building something that’s purely destined to live in a simulation,
    you should be judicious in your use of cameras. It’s relatively unusual to use
    cameras and vector observations together to observe the same elements of the simulation,
    but there are scenarios in which it makes sense: vectors might add context to
    the camera, or give additional environmental information about what’s going on
    that can’t be gleaned from the camera alone.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在建造一个纯粹用于模拟的东西，那么在使用摄像头时应该要审慎选择。通常情况下，同时使用摄像头和矢量观察来观察模拟中的相同元素是比较不寻常的，但也有一些情况是合理的：矢量可能会为摄像头增加背景信息，或者提供关于环境的额外信息，这些信息仅从摄像头中无法获取。
- en: For example, if you were building a pick-and-place robot, and it could see,
    for example, a bag of pasta sitting in front of it via its camera, it might be
    strange to also use a raycast observation that detects a tagged bag of pasta,
    and identifies it as such. The image recognition system alone could deal with
    identifying a bag of pasta and the additional information from the raycast is,
    at best superfluous, and at its worst, an impediment to the training process.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在建造一个拾取放置机器人，它通过摄像头可以看到放在它前面的一袋面条，那么同时使用一个射线投射观察来检测并识别被标记的面条袋，似乎有些奇怪。仅仅图像识别系统就足以处理识别面条袋的任务，而来自射线投射的额外信息，在最好的情况下是多余的，在最坏的情况下，会妨碍训练过程。
- en: Basically, if you’re using your agent out of engine (in the real world), you
    should try and mimic the inputs it really will have as best as possible, and if
    you’re doing something that’s solely virtual, you can give it a camera if you
    want a computer vision model as a result.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，如果你的代理程序在引擎之外（在现实世界中）使用，你应尽可能地模仿它实际上会有的输入；如果你在进行的是纯虚拟的活动，你可以给它一个摄像头，这样可以得到计算机视觉模型作为结果。
- en: You could give any agent a camera. But that doesn’t mean it would be useful.
    Any observations that don’t give an agent more information about how to fulfill
    its objectives is just muddying the waters, making the resulting neural network
    more complex and making training slower and more difficult. You should always
    have as few observations as possible.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以给任何代理程序配备摄像头。但这并不意味着它一定会有用。任何不能为代理程序提供更多关于如何实现其目标的信息的观察结果只会让事情变得复杂，导致神经网络的训练变得更慢更困难。你应该尽可能地减少观察结果。
- en: Cameras are great fun, and you should definitely play with them as you explore
    making your own simulations. But when it gets down to business, you want to be
    careful not to use too many, or not to only use cameras if there is a better option.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 相机非常有趣，当你探索制作自己的模拟时，你绝对应该和它们玩耍。但是当事情变得严肃时，你要小心不要使用过多的相机，或者不要仅仅依赖相机，如果有更好的选择的话。
