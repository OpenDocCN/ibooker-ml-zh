- en: Chapter 10\. Evaluating, Deploying, and Supporting Edge AI Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。评估、部署和支持边缘 AI 应用
- en: This is the final theory chapter of this book, and we’ll be covering the processes
    of evaluating, deploying, and supporting edge AI applications. These three things
    are intimately connected—and in an iterative project they happen in parallel throughout
    the course of the development workflow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一个理论章节，我们将涵盖评估、部署和支持边缘 AI 应用的过程。这三件事密切相关，并且在迭代项目中它们在整个开发工作流程中同时进行。
- en: Evaluating Edge AI Systems
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估边缘 AI 系统
- en: Evaluation is the key to a successful project. In fact, without evaluation you
    have no real way of knowing whether your project is successful or not. While it
    happens to be featured at the end of this book, it’s something that occurs all
    the way through the development process. It may even start before development,
    when you’re quantifying the performance of an existing process you aim to improve
    with edge AI.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 评估是成功项目的关键。事实上，没有评估，您无法真正知道您的项目是否成功。虽然它恰好在本书的末尾出现，但它是开发过程中始终存在的事物。甚至可能在开发之前就开始，当您量化希望通过边缘
    AI 改进的现有流程的性能时。
- en: Remember that throughout the process, evaluation needs to be conducted with
    participation from stakeholders and end users. It’s very possible that different
    stakeholders may have conflicting criteria for evaluation, depending on their
    individual perspectives. Figuring out how to resolve these conflicts is an important
    part of evaluation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在整个过程中，评估需要与利益相关者和最终用户的参与进行。不同的利益相关者可能具有冲突的评估标准，这取决于他们的个人视角。解决这些冲突的方法是评估的重要部分。
- en: 'Here are some of the stages where evaluation needs to occur:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要进行评估的一些阶段：
- en: Examining an existing solution
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 检查现有解决方案
- en: Much of the time, we’re developing edge AI systems to replace legacy systems
    that we think could be better. This makes it very important to understand the
    actual performance of the existing system at the beginning of the process. The
    goal of our development process will be to beat it, and we can’t beat something
    that we haven’t measured.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们正在开发边缘 AI 系统来取代我们认为可以更好的传统系统。这使得在流程开始阶段了解现有系统的实际表现非常重要。我们的开发过程的目标将是超越它，而我们无法超越我们没有测量过的东西。
- en: Even if there’s no existing solution, it’s a great idea to come up with a simple
    baseline that we can aim to outperform (as we saw in [“Developing a baseline algorithm”](ch09.html#developing_a_baseline_algorithm)).
    This brings direction and perspective to our work—and sometimes, the simple baseline
    ends up being the best choice.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有现有解决方案，构思一个简单的基准也是一个好主意，我们可以力求超越它（正如我们在[“开发基准算法”](ch09.html#developing_a_baseline_algorithm)中所见）。这为我们的工作带来了方向和视角，有时，简单的基准最终成为最佳选择。
- en: Exploring potential algorithms
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 探索潜在算法
- en: Evaluation is vital during the exploration stages of a project, while we’re
    getting to know the dataset and experimenting with different types of algorithms.
    It’s how we start to home in on the approaches that look promising. During this
    stage, quick and convenient evaluation is helpful in being able to move fast.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目探索阶段，评估是至关重要的，当我们开始了解数据集并尝试不同类型的算法时。这是我们开始专注于看起来有前途的方法的方式。在此阶段，快速方便的评估有助于我们快速进展。
- en: During iterative development
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代开发期间
- en: 'The iterative development process is driven by evaluation: we create a solution,
    evaluate it, and use the results of evaluation to course-correct so that our next
    iteration is better. There are many different ways to evaluate a system under
    development, and we’ll meet some of them in [“Ways to Evaluate a System”](#ways_to_evaluate_a_system).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代开发过程由评估驱动：我们创建一个解决方案，评估它，并使用评估结果进行调整，以便我们的下一个迭代更好。有许多不同的评估系统正在开发中，我们将在[“评估系统的方法”](#ways_to_evaluate_a_system)中了解其中一些。
- en: Before and after optimization
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 优化前后
- en: When we’re deploying to edge devices, we often have to apply lossy optimization
    techniques that allow us to fit algorithms within our memory or latency constraints
    (see [“Compression and optimization”](ch04.html#compression_and_optimization)).
    It’s important to evaluate performance before and after optimization to determine
    how much loss has occurred. You should always evaluate, even if you are applying
    an optimization technique that you think is not lossy—just in case a bug in the
    process causes some kind of degradation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们部署到边缘设备时，通常需要应用丢失优化技术，以使算法适应我们的内存或延迟约束（见[“压缩与优化”](ch04.html#compression_and_optimization)）。在优化之前和之后评估性能非常重要，以确定发生了多少损失。即使您认为应用的优化技术不会丢失数据，也应该进行评估——以防优化过程中出现错误导致某种程度的降级。
- en: On real hardware
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实硬件上
- en: There are many reasons why your application might perform differently once deployed
    to real hardware. For example, there may be some difference between the production
    hardware’s sensors and those that the original dataset was collected from. Alternately,
    there could be some difference in the way your program runs when built for real
    hardware versus on your development machine. It’s important to evaluate before
    and after deployment so you can understand if there’s any impact.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因会导致您的应用在部署到真实硬件后表现不同。例如，生产硬件的传感器与最初收集数据集时的传感器可能有所不同。或者，在构建用于真实硬件的程序时，与在开发机器上运行时可能有所不同。在部署之前和之后进行评估非常重要，这样您就可以了解是否有任何影响。
- en: During limited deployment
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在有限的部署期间
- en: It’s always a great idea to do a staged deployment, where you roll out your
    system incrementally so you can catch any issues before you scale up. This is
    another key moment for evaluation, since you’ll need some way to measure whether
    your system is performing as expected.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分阶段部署您的系统总是一个好主意，这样您可以逐步推出系统，以便在扩展之前发现任何问题。这是另一个评估的关键时刻，因为您需要一种方法来衡量系统是否如预期运行。
- en: Ongoing postdeployment
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 持续的部署后期
- en: Performance should be monitored continually after you have deployed, which naturally
    requires evaluation. There’ll be more detail on this stage in [“Postdeployment
    Monitoring”](#post_deployment_monitoring).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署后应持续监控性能，这自然需要进行评估。有关此阶段的更多详细信息，请参阅[“部署后监控”](#post_deployment_monitoring)。
- en: Evaluation and Responsible Design
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估与负责任的设计
- en: Ethical AI depends heavily on evaluation. For example, to detect bias, it’s
    vital to understand how your system is performing on different types of input.
    By evaluating at every stage, you’re giving your team visibility into the places
    where ethical concerns might creep in.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 道德AI严重依赖于评估。例如，要检测偏见，理解系统在不同类型输入上的表现至关重要。通过在每个阶段进行评估，可以使您的团队了解到道德关注点可能出现的地方。
- en: Ways to Evaluate a System
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估系统的方法
- en: There are many ways to evaluate an edge AI system, and different mechanisms
    will be important during different stages of the development process. They all
    require varying amounts of time and investment—which may make them appropriate
    for either short, tight feedback loops or longer, broader ones.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 评估边缘AI系统有许多方法，在开发过程的不同阶段，不同的机制都会显得重要。它们都需要不同的时间和投入，这可能适用于短期、紧密的反馈循环，也可能适用于更长、更广泛的循环。
- en: Following are some of the key approaches.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关键方法。
- en: Evaluating individual components
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估各个单独的组件
- en: 'A system is made up of many smaller components, and there are different ways
    to evaluate each. For example, your algorithmic pipeline may include the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 系统由许多较小的组件组成，评估每个组件的方式各不相同。例如，您的算法流水线可能包括以下内容：
- en: Windowing
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口化
- en: Downsampling
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降采样
- en: Digital signal processing
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字信号处理
- en: Machine learning
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习
- en: Postprocessing
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后处理
- en: Rule-based algorithms
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于规则的算法
- en: Each of these moving parts will have its own tools for evaluation, and experts
    in the relevant fields will understand how to use them. This type of evaluation
    is essential when building a pipeline of steps that work together to deliver a
    result. If you set up mechanisms for evaluating the individual components of your
    system, you will more easily be able to identify the cause of any systemic issues.
    It will also help you iterate individually on specific components in isolation,
    since they may be owned by different teams.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些运动部件都会有自己的评估工具，相关领域的专家会了解如何使用它们。在构建一系列共同工作以提供结果的步骤流水线时，这种评估至关重要。如果你设置了评估系统中各个组件的机制，你将更容易找出任何系统问题的原因。这也将帮助你单独迭代特定组件，因为它们可能由不同的团队拥有。
- en: Evaluating integrated systems
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估集成系统
- en: 'It’s not enough to know that all the individual pieces of a system work together:
    you also need to understand that they function correctly as a whole. Otherwise,
    emergent systemic problems may prevent your application from performing well.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 光知道系统的各个部分能够共同工作还不够，你还需要了解它们作为一个整体是否能够正确运行。否则，新出现的系统性问题可能会影响你的应用表现良好。
- en: For example, you may have a machine learning model and postprocessing algorithm
    that seem to function well when tested individually. However, on linking them
    together you may find that they do not perform adequately.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能有一个机器学习模型和后处理算法，当单独测试时似乎运行良好。然而，当它们链接在一起时，你可能会发现它们表现不佳。
- en: A combination of component-level tests and systemic tests is required to really
    understand the performance of a system. Testing an integrated system will tell
    you whether a system is underperforming, but it won’t provide much explanation
    on its own.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 真正理解系统性能需要结合组件级测试和系统性测试。测试集成系统将告诉你系统是否表现不佳，但单独测试是不会提供太多解释的。
- en: Simulated real-world testing
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟真实世界的测试
- en: 'In many cases, the datasets available for training are not realistic: they
    might represent an ideal set of conditions, having been collected in a lab or
    carefully cleaned up in order to present the best possible dataset for training.
    Evaluation on a dataset such as this may provide misleading results. To really
    understand performance, it’s necessary to test things out in the real world.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，用于训练的数据集并不真实：它们可能代表一组理想的条件，可能是在实验室中收集的，或者经过精心清理，以呈现最佳的训练数据集。在这样的数据集上进行评估可能会导致误导性的结果。要真正了解性能，有必要在真实世界中测试这些东西。
- en: It would be great if we could test all of our work in production at the click
    of a button, but the realities of embedded development make this impossible. Compared
    to software engineering on the web, it’s a lot more time consuming, expensive,
    and risky to push an embedded application live. This means that in this respect,
    embedded development has a less effective feedback loop between development and
    real-world performance.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够在点击按钮的同时将所有工作都投入生产中进行测试，那将是很好的。但嵌入式开发的现实情况使这一点不可能。与网络软件工程相比，推送嵌入式应用程序上线需要更多的时间、金钱和风险。这意味着在这方面，嵌入式开发在开发和真实世界性能之间的反馈循环效果不佳。
- en: One solution to this problem is to simulate real-world conditions as closely
    as possible during development, so that changes to an algorithm or an application
    can be tested in close to real time. This might involve collecting a dataset that
    reflects the type of real-world conditions you expect to see, then running it
    through a fully integrated build of your application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个方法是在开发过程中尽可能地模拟真实世界的条件，以便能够在接近实时的环境中测试算法或应用的变更。这可能涉及收集反映你预期见到的真实世界条件类型的数据集，然后通过完全集成的应用程序构建来运行它。
- en: For example, imagine you are building a fitness tracking wearable. It could
    be tested using streams of data that have been captured from genuine users wearing
    dummy devices containing only sensors. The data would need to be labeled by an
    expert so that it can be used for evaluation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象你正在开发一款健身追踪可穿戴设备。可以使用从真实用户身上捕获的数据流进行测试，这些用户戴着只含有传感器的虚拟设备。数据需要由专家进行标记，以便用于评估。
- en: If real-world data is too difficult to obtain, it’s also possible to use synthetic
    data. Realistic streams of data can be constructed by layering samples from conventional
    training datasets on top of samples of background noise, applying augmentation
    to increase the variance of the data. This is an option available in Edge Impulse’s
    performance calibration feature, described in [“Performance Calibration”](#performance_calibration).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果真实世界数据难以获取，也可以使用合成数据。可以通过将传统训练数据集的样本层叠在背景噪声样本上，并应用增强来增加数据的差异性，来构建逼真的数据流。这是Edge
    Impulse性能校准功能的一个选项，详见[“性能校准”](#performance_calibration)。
- en: A prominent example of the use of simulated real-world testing is in Amazon’s
    [Alexa certification process](https://oreil.ly/Pvi5L). Hardware products that
    integrate Alexa must meet minimum standards for the performance of their keyword-spotting
    systems. Performance is evaluated by playing a number of clips of audio from a
    speaker that is a certain distance from the device, under varying conditions.
    To pass, the device has to successfully identify when a clip contains a keyword—and
    avoid activating when it does not.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Amazon的[Alexa认证过程](https://oreil.ly/Pvi5L)中，模拟真实世界测试的一个显著例子是硬件产品集成Alexa必须符合其关键词识别系统性能的最低标准。性能评估是通过播放来自距离设备一定距离的扬声器的音频剪辑来进行的，且在不同条件下进行。设备必须成功识别包含关键词的剪辑并在不包含关键词时避免激活才能通过。
- en: Real-world testing
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真实世界测试
- en: 'It’s best to start testing your system in the real world as early as possible:
    as soon as you have hardware, if not before.^([1](ch10.html#idm45988812876272))
    There are two main types of real-world testing:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽早在真实世界中开始测试系统是最佳选择：尽早拥有硬件时，如果可能的话，甚至在此之前。^([1](ch10.html#idm45988812876272))
    真实世界测试主要有两种类型：
- en: Quality assurance testing, where you deliberately put a product through its
    paces to try to identify any problems
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 质量保证测试，您故意让产品进行测试以试图识别任何问题
- en: Usability testing, where you allow users to interact naturally with a product
    in order to understand how well it works
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可用性测试，允许用户自然地与产品进行交互，以了解其工作效果如何
- en: Real-world testing is slower and more expensive than some types of evaluation,
    but it’s essential to product development. It’s also a lot cheaper than bringing
    your product to market and then realizing it doesn’t work.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 真实世界测试比某些评估类型更慢更昂贵，但对产品开发至关重要。这也比将产品推向市场然后意识到其无法工作要便宜得多。
- en: Quality assurance testing
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 质量保证测试
- en: Quality assurance (QA) is a systematic way of exploring a product and understanding
    whether it meets the appropriate level of quality—typically based on the product’s
    design goals (see [“Setting Design Goals”](ch08.html#setting_design_goals)). During
    development, QA engineers design and implement strategies for exercising the features
    of a product and trying to understand its effectiveness and overall fit for purpose.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 质量保证（QA）是一种系统性的方法，用于探索产品并理解其是否达到适当的质量水平——通常基于产品的设计目标（参见[“设置设计目标”](ch08.html#setting_design_goals)）。在开发过程中，QA工程师设计并实施策略，以行使产品的功能，并试图理解其效果和整体适用性。
- en: 'QA is a major field with its own domain experts, and it’s absolutely critical
    to the process of building a good product. It’s too big an area to explore within
    the confines of this book, but here are some of the ways that QA professionals
    can be important in edge AI projects:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: QA是一个拥有自己领域专家的重要领域，对于构建良好产品的过程至关重要。这是一个超出本书范围探讨的大领域，但以下是QA专业人员在边缘AI项目中的一些重要作用方式：
- en: Getting hands-on with a prototype and trying to find problems
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取原型并尝试发现问题
- en: Testing individual components during development (for example, a keyword-spotting
    algorithm)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中测试单独的组件（例如，关键词识别算法）
- en: Designing systems and procedures for testing products throughout the workflow
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计系统和流程，用于在整个工作流程中测试产品
- en: Certifying whether a product meets its design goals
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证产品是否达到其设计目标
- en: The QA process begins as soon as you have design goals, since the person in
    a QA role will have to come up with a system for testing them. Ideally, QA will
    happen throughout the development process as part of the procedure of evaluating
    each iteration’s work.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定设计目标，QA过程就会开始，因为负责QA角色的人需要为其设计测试系统。理想情况下，QA将在开发过程中作为评估每个迭代工作的一部分的程序的一部分进行。
- en: Usability testing
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户可用性测试
- en: While QA testing is focused on deliberately trying to find problems, usability
    testing is about observing natural usage of your product and using your observations
    to guide improvements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然质量保证（QA）测试专注于有意识地尝试寻找问题，但可用性测试则是观察产品的自然使用，并利用观察结果指导改进。
- en: Usability testing happens with real users. They could be members of the public,
    potential customers, or people from inside your own team or organization. The
    key is that they are interacting with your product in a realistic way.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性测试与真实用户一起进行。他们可以是公众成员、潜在客户，或者是您团队或组织内部的人员。关键是他们以一种真实的方式与您的产品互动。
- en: 'Some usability testing is done in studies, where people are brought in to a
    controlled environment and encouraged to interact with the product in certain
    ways. Other types of testing are more natural: for example, beta testing involves
    providing users with early versions of a product that they can take away, use
    for a while, and provide feedback on.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可用性测试是在研究中进行的，这些研究会引入人员到一个受控环境，并鼓励他们以特定方式与产品进行交互。其他类型的测试则更自然：例如，测试版测试涉及向用户提供产品的早期版本，让他们可以带走使用一段时间，并提供反馈意见。
- en: The best plan will vary depending on your situation, but typically usability
    studies are done earlier in the development process, where focused input is required
    to help steer the project, and beta testing is done later, when the product is
    nearing completion and a more general overview is needed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳计划会因情况而异，但通常可用性研究会在开发过程的早期进行，需要集中的输入以帮助引导项目，而测试则会在稍后进行，当产品接近完成并需要更一般的概述时。
- en: An interesting variety of usability testing is known as *dogfooding* (from the
    concept of [“eating your own dogfood”](https://oreil.ly/tVnyZ)). This is when
    members of an organization use their own prerelease hardware in order to understand
    its usability and generate feedback.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一种有趣的可用性测试类型被称为“dogfooding”（源自“吃自家的狗粮”概念）。这是指组织成员使用他们自己的预发布硬件来理解其可用性并生成反馈。
- en: 'Usability testing is also an area with its own domain experts. It’s the most
    expensive type of testing, but it’s also the most valuable: you get to see how
    your system is performing in something close to reality.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性测试也是一个拥有自己领域专家的领域。这是最昂贵的测试类型，但也是最有价值的：你可以看到你的系统在接近现实情况下的表现。
- en: Monitoring a deployed system
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控已部署系统
- en: It’s critical to understand the performance of a system once it’s been deployed.
    As we’ll see in [“Postdeployment Monitoring”](#post_deployment_monitoring), this
    can be extremely challenging.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦系统部署后，了解其性能至关重要。正如我们将在[“部署后监控”](#post_deployment_monitoring)中看到的，这可能极具挑战性。
- en: Useful Metrics
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的度量指标
- en: 'Any kind of quantitative evaluation will result in metrics: key numbers that
    represent some aspect of the performance of a product or component. Collecting
    the right metrics is extremely important: as the saying goes, “you are what you
    measure,” and if you choose the wrong values to focus on, your iterative process
    will go in the wrong direction.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的定量评估都会产生度量指标：代表产品或组件性能某一方面的关键数字。收集正确的度量非常重要：俗话说，“你衡量的就是你的成果”，如果你选择了错误的价值观，你的迭代过程将朝错误的方向发展。
- en: Fortunately there are lots of standard metrics that are relevant to edge AI
    systems; they’ll likely be familiar to anyone who works in a connected field.
    Following are some of the most important ones.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有很多标准的度量指标与边缘AI系统相关；它们对于在连接领域工作的人来说可能很熟悉。以下是一些最重要的指标。
- en: Algorithmic performance
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法性能
- en: These metrics are useful in understanding the performance of AI algorithms.
    They typically vary depending on the algorithm type (as described in [“Algorithm
    Types by Functionality”](ch04.html#algo_types_by_functionality)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些度量在理解AI算法性能方面非常有用。它们通常根据算法类型而变化（如[“功能算法类型”](ch04.html#algo_types_by_functionality)所述）。
- en: Loss
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 损失
- en: Loss is a way of measuring the correctness of a model’s predictions. The higher
    the loss score, the more inaccurate the predictions are. The exact meaning of
    a loss metric is determined by a *loss function*. Standard loss functions exist
    for different types of problems, or you can come up with your own. Loss is calculated
    and used in the training process for some types of machine learning models, such
    as deep learning.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 损失是衡量模型预测正确性的一种方式。损失分数越高，预测越不准确。损失指标的确切含义由*损失函数*决定。不同类型问题有标准的损失函数，或者您可以自行设计。损失在某些机器学习模型（如深度学习）的训练过程中被计算和使用。
- en: Loss can be computed for a single prediction, but it is common to calculate
    the mean loss for a whole dataset. For example, you might compute the mean loss
    over your validation dataset.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以计算单个预测的损失，但通常会计算整个数据集的平均损失。例如，您可以计算验证数据集上的平均损失。
- en: Loss doesn’t have units, so it only means anything relative to itself. This
    makes it a good measure of how a model’s performance changes over time during
    training, but not a particularly helpful metric if you’re trying to understand
    how the model will work in the real world.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 损失没有单位，因此只能相对于自身而言。这使得它成为衡量模型在训练过程中性能变化的好指标，但如果您试图了解模型在现实世界中的工作原理，则不是特别有帮助的度量标准。
- en: Where loss functions are used in the process of optimizing machine learning
    models, it’s important that an improvement to the optimization loss corresponds
    to an improvement in other metrics. The loss function should be selected based
    on the problem you are trying to solve (most common problems have standard loss
    functions), and your metrics should be selected based on the same problem. Without
    agreement between the two, you’ll end up with a model that does not solve the
    right problem.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化机器学习模型的过程中使用损失函数时，重要的是优化损失的改进对应于其他指标的改进。损失函数应根据您尝试解决的问题选择（大多数常见问题有标准损失函数），您的指标应基于相同的问题选择。如果两者不一致，您将得到一个无法解决正确问题的模型。
- en: Accuracy
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 准确率
- en: 'Classification is a common task, and there are a few different metrics used
    to express how well a classifier is performing. Accuracy is the simplest and best
    known of these: it’s just the percentage of classifications that were correct
    across a given dataset.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 分类是一种常见任务，有几种不同的指标用于表达分类器的性能。准确率是其中最简单且最为人熟知的：它只是在给定数据集上正确分类的百分比。
- en: Accuracy is a reasonable way to understand the performance of a model at a glance,
    but as a single value it obscures a lot of context. For example, a single accuracy
    number can’t tell us anything about how the individual classes in a dataset performed.
    A 90% accuracy metric on a balanced dataset might sound impressive, but on an
    unbalanced dataset (perhaps consisting 90% of one class and 10% of another) it
    could mean the model is terrible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 准确率是一种快速了解模型性能的合理方式，但作为单一数值，它掩盖了很多背景信息。例如，单一准确率数值无法告诉我们数据集中各个类别的表现如何。在平衡数据集上的90%准确率指标听起来令人印象深刻，但在非平衡数据集上（可能包含90%的一个类别和10%的另一个类别）可能意味着模型很差劲。
- en: Because of this limitation, it’s best to use accuracy in conjunction with other
    metrics that capture more nuance—or at least calculate it for each class individually.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好将准确率与捕捉更多细微差别的其他指标结合使用，或者至少为每个类别单独计算准确率。
- en: Confusion matrix
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 混淆矩阵
- en: A confusion matrix is a powerful tool for understanding how a model is performing.
    It’s a simple table that shows the ways that individual samples were classified.
    An example is shown in [Figure 10-1](#confusion_matrix_figure), a screenshot from
    Edge Impulse.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆矩阵是理解模型表现的强大工具。它是一个简单的表格，显示了如何分类个体样本的方式。例如，[图10-1](#confusion_matrix_figure)显示了来自Edge
    Impulse的截图。
- en: '![A table with three rows titled ''no'', ''noise'', and ''yes'', and three
    columns with the same titles.](assets/aiae_1001.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含标题为''no''、''noise''和''yes''的表格，以及三列相同标题的表格。](assets/aiae_1001.png)'
- en: Figure 10-1\. A confusion matrix showing results for a keyword-spotting model
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-1\. 显示关键词检测模型结果的混淆矩阵
- en: In [Figure 10-1](#confusion_matrix_figure), the row headers NO, NOISE, and YES
    represent three classes of samples in a dataset. They correspond with the similarly
    named column headers, which represent three classes identified by a classifier.
    The percentage in each cell indicates the proportion of samples from the dataset
    class (indicated by the row header) that were identified by the classifier as
    fitting into a particular class (indicated by the column header).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图10-1](#confusion_matrix_figure)中，行标题“NO”、“NOISE”和“YES”代表数据集中三类样本。它们与同名的列标题对应，后者表示分类器识别出的三类。每个单元格中的百分比表示数据集类别（由行标题指示）被分类器识别为特定类别（由列标题指示）的样本比例。
- en: For example, we can see that 96.3% of the instances of NO were correctly classified
    as NO, while 3.7% of them were incorrectly classified as YES. This breakdown allows
    us to understand how our classifier is performing between classes. This is much
    more interesting than a single accuracy metric, since it helps us begin to understand
    exactly where our model is struggling.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以看到，96.3%的“NO”的实例被正确分类为“NO”，而其中3.7%被错误分类为“YES”。这种分类结果能帮助我们了解我们的分类器在不同类别间的表现。这比单一的准确度指标更有趣，因为它帮助我们开始了解我们的模型在哪些地方存在问题。
- en: Precision and recall
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 精度和召回率
- en: From the point of view of a single class in the confusion matrix, there are
    two different types of mistakes a classifier can make. Both of them are cases
    of mistaken identity.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从混淆矩阵中单个类的角度来看，分类器可能犯的错误有两种不同类型。这两种都是误认身份的情况。
- en: In the first case, a genuine member of the class is misidentified as belonging
    to a different one. For example, a smart camera for bird spotting might mistake
    a bird for leaf, missing the bird entirely.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，一个真正属于该类的成员被误认为属于另一个类。例如，一个用于鸟类识别的智能摄像头可能会误将一只鸟误认为叶子，完全错过了鸟类。
- en: In the second case, a member of a *different* class is misidentified as belonging
    to the one we care about. For example, we might mistake a leaf for a bird.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，一个属于*不同*类别的成员被误认为属于我们关心的类别。例如，我们可能会将一片叶子误认为鸟类。
- en: 'Precision and recall provide ways to describe how often these mistakes occur.
    Precision tells us how frequently our model mistakes a boring old leaf for a lovely
    bird, while recall describes how often our model misses a bird it should have
    spotted:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 精度和召回率提供了描述这些错误发生频率的方法。精度告诉我们，我们的模型多频繁地将一片无趣的叶子误认为可爱的鸟类，而召回率描述了我们的模型多频繁地错过本应该识别的鸟类：
- en: <math alttext="Precision equals StartFraction number of birds we got right Over
    number of inputs we thought were birds EndFraction" display="block"><mrow><mtext>Precision</mtext>
    <mo>=</mo> <mfrac><mrow><mtext>number</mtext><mtext>of</mtext><mtext>birds</mtext><mtext>we</mtext><mtext>got</mtext><mtext>right</mtext></mrow>
    <mrow><mtext>number</mtext><mtext>of</mtext><mtext>inputs</mtext><mtext>we</mtext><mtext>thought</mtext><mtext>were</mtext><mtext>birds</mtext></mrow></mfrac></mrow></math><math
    alttext="Recall equals StartFraction number of birds we got right Over actual
    number of birds in the dataset EndFraction" display="block"><mrow><mtext>Recall</mtext>
    <mo>=</mo> <mfrac><mrow><mtext>number</mtext><mtext>of</mtext><mtext>birds</mtext><mtext>we</mtext><mtext>got</mtext><mtext>right</mtext></mrow>
    <mrow><mtext>actual</mtext><mtext>number</mtext><mtext>of</mtext><mtext>birds</mtext><mtext>in</mtext><mtext>the</mtext><mtext>dataset</mtext></mrow></mfrac></mrow></math>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="精度等于正确识别的鸟的数量 除以 我们认为是鸟的输入总数" display="block"><mrow><mtext>精度</mtext>
    <mo>=</mo> <mfrac><mrow><mtext>正确识别的鸟的数量</mtext></mrow> <mrow><mtext>我们认为是鸟的输入总数</mtext></mrow></mfrac></mrow></math><math
    alttext="召回率等于正确识别的鸟的数量 除以 数据集中实际鸟类的数量" display="block"><mrow><mtext>召回率</mtext>
    <mo>=</mo> <mfrac><mrow><mtext>正确识别的鸟的数量</mtext></mrow> <mrow><mtext>数据集中实际鸟类的数量</mtext></mrow></mfrac></mrow></math>
- en: Each of a dataset’s classes will have its own precision and recall, but they
    can also be expressed as a mean over all of the classes. It’s a great metric because
    it lets us characterize the types of mistakes made by a model.^([2](ch10.html#idm45988812780896))
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据集类别都有自己的精度和召回率，但它们也可以表示为所有类别的平均值。这是一个很好的指标，因为它能让我们了解模型犯了哪些类型的错误。（参见[2](ch10.html#idm45988812780896)）
- en: 'Precision and recall are both expressed as numbers between 0 and 1, with 1
    being perfect and 0 being completely wrong. There’s typically a trade-off between
    them: you can reduce one by increasing the other. This makes them important metrics
    for tuning.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 精确率和召回率都表示为介于 0 和 1 之间的数字，其中 1 表示完美，0 表示完全错误。它们通常存在权衡：通过增加一个可以减少另一个。这使它们成为调整的重要指标。
- en: Positive and negative rates
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 正负率
- en: Another name for recall is the *true positive rate*, or TPR. It’s the rate at
    which true positives—meaning correct positive identifications—are expected to
    occur. There are three other acronyms that cover the other possibilities of errors
    within a classifier’s confusion matrix. *False positive rate* (FPR) represents
    how often negative examples (items outside of our class of concern) were falsely
    identified as being things we care about.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '-   召回率的另一个名称是*真正率*，或者TPR。它是正确识别正例的速率。还有另外三个缩写，涵盖分类器混淆矩阵中的其他错误可能性。*假正率*（FPR）表示负例（不属于我们关注类别的项目）被错误地标识为我们关心的事物的频率。'
- en: <math alttext="True positive rate equals StartFraction true positives Over total
    positives in dataset EndFraction" display="block"><mrow><mtext>True</mtext> <mtext>positive</mtext>
    <mtext>rate</mtext> <mo>=</mo> <mfrac><mrow><mtext>true</mtext><mtext>positives</mtext></mrow>
    <mrow><mtext>total</mtext><mtext>positives</mtext><mtext>in</mtext><mtext>dataset</mtext></mrow></mfrac></mrow></math><math
    alttext="False positive rate equals StartFraction false positives Over total negatives
    in dataset EndFraction" display="block"><mrow><mtext>False</mtext> <mtext>positive</mtext>
    <mtext>rate</mtext> <mo>=</mo> <mfrac><mrow><mtext>false</mtext><mtext>positives</mtext></mrow>
    <mrow><mtext>total</mtext><mtext>negatives</mtext><mtext>in</mtext><mtext>dataset</mtext></mrow></mfrac></mrow></math>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="真正率等于真正例占数据集中总正例的比率" display="block"><mrow><mtext>真正率</mtext>
    <mo>=</mo> <mfrac><mrow><mtext>真正例</mtext></mrow> <mrow><mtext>数据集中总正例</mtext></mrow></mfrac></mrow></math><math
    alttext="假正率等于假正例占数据集中总负例的比率" display="block"><mrow><mtext>假正率</mtext> <mo>=</mo>
    <mfrac><mrow><mtext>假正例</mtext></mrow> <mrow><mtext>数据集中总负例</mtext></mrow></mfrac></mrow></math>
- en: Inversely, *true negative rate* (TNR) describes how often those negative examples
    were correctly ignored. Finally, *false negative rate* (FNR) describes how often
    a sample belonging to the class we care about is incorrectly ignored.^([3](ch10.html#idm45988812732656))
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，*真负率*（TNR）描述了正确忽略负例的频率。最后，*假负率*（FNR）描述了属于我们关心的类别的样本被错误地忽略的频率。^([3](ch10.html#idm45988812732656))
- en: <math alttext="True negative rate equals StartFraction true negatives Over total
    negatives in dataset EndFraction" display="block"><mrow><mtext>True</mtext> <mtext>negative</mtext>
    <mtext>rate</mtext> <mo>=</mo> <mfrac><mrow><mtext>true</mtext><mtext>negatives</mtext></mrow>
    <mrow><mtext>total</mtext><mtext>negatives</mtext><mtext>in</mtext><mtext>dataset</mtext></mrow></mfrac></mrow></math><math
    alttext="False negative rate equals StartFraction false negatives Over total positives
    in dataset EndFraction" display="block"><mrow><mtext>False</mtext> <mtext>negative</mtext>
    <mtext>rate</mtext> <mo>=</mo> <mfrac><mrow><mtext>false</mtext><mtext>negatives</mtext></mrow>
    <mrow><mtext>total</mtext><mtext>positives</mtext><mtext>in</mtext><mtext>dataset</mtext></mrow></mfrac></mrow></math>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="真负率等于真负例占数据集中总负例的比率" display="block"><mrow><mtext>真负率</mtext>
    <mo>=</mo> <mfrac><mrow><mtext>真负例</mtext></mrow> <mrow><mtext>数据集中总负例</mtext></mrow></mfrac></mrow></math><math
    alttext="假负率等于假负例占数据集中总正例的比率" display="block"><mrow><mtext>假负率</mtext> <mo>=</mo>
    <mfrac><mrow><mtext>假负例</mtext></mrow> <mrow><mtext>数据集中总正例</mtext></mrow></mfrac></mrow></math>
- en: These rates are all different ways of expressing how well your system is able
    to distinguish between classes. They can be traded off to determine performance
    in the same way we described in [“Confidence Thresholds”](#confidence_thresholds).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些率都是表达系统区分类别能力的不同方式。它们可以进行折衷以确定与 [“置信阈值”](#confidence_thresholds) 中描述的方式相同的性能。
- en: F1 score and MCC
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: F1 分数和 MCC
- en: 'It’s sometimes useful to have a single statistic to describe the performance
    of a classifier: for example, when comparing similar models. One such statistic
    is the *F1 score*, a single number that is derived from the precision and recall
    scores (by taking their harmonic mean):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，使用单一统计量来描述分类器的性能是很有用的：例如，当比较类似的模型时。这样一个统计量是*F1分数*，它是通过精确率和召回率分数的调和平均值得到的单一数字：
- en: <math alttext="upper F 1 equals 2 StartFraction normal p normal r normal e normal
    c normal i normal s normal i normal o normal n dot normal r normal e normal c
    normal a normal l normal l Over normal p normal r normal e normal c normal i normal
    s normal i normal o normal n plus normal r normal e normal c normal a normal l
    normal l EndFraction" display="block"><mrow><msub><mi>F</mi> <mn>1</mn></msub>
    <mo>=</mo> <mn>2</mn> <mfrac><mrow><mi>precision</mi> <mo>·</mo> <mi>recall</mi></mrow>
    <mrow><mi>precision</mi> <mo>+</mo> <mi>recall</mi></mrow></mfrac></mrow></math>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F 1 equals 2 StartFraction normal p normal r normal e normal
    c normal i normal s normal i normal o normal n dot normal r normal e normal c
    normal a normal l normal l Over normal p normal r normal e normal c normal i normal
    s normal i normal o normal n plus normal r normal e normal c normal a normal l
    normal l EndFraction" display="block"><mrow><msub><mi>F</mi> <mn>1</mn></msub>
    <mo>=</mo> <mn>2</mn> <mfrac><mrow><mi>precision</mi> <mo>·</mo> <mi>recall</mi></mrow>
    <mrow><mi>precision</mi> <mo>+</mo> <mi>recall</mi></mrow></mfrac></mrow></math>
- en: While convenient, the F1 score has some limitations. It doesn’t include any
    information about true negatives—meaning it isn’t suitable for use with unbalanced
    classes, since if there are different numbers of items in each class the F1 scores
    between classes will be incomparable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管方便，F1分数也有一些局限性。它不包含有关真负例的任何信息——这意味着它不适合用于不平衡的类，因为如果每个类中的项目数量不同，各类之间的F1分数将无法比较。
- en: For this reason, a different metric known as [*Matthews correlation coefficient*
    (MCC)](https://oreil.ly/dtn0y) can be a better choice. It includes all of the
    squares in the confusion matrix, so it’s a better overall indicator of model quality.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，另一个被称为[*马修斯相关系数* (MCC)](https://oreil.ly/dtn0y)的指标可能是更好的选择。它包含混淆矩阵中的所有方格，因此是模型质量的更好整体指标。
- en: Although the MCC is better, it’s still limited by nature. Rolling an entire
    confusion matrix into a single number removes our ability to consider each cell
    individually. As we saw in [“Confidence Thresholds”](#confidence_thresholds),
    every application has a slightly different ideal balance between precision and
    recall. The F1 and MCC scores prevent us from considering them individually—so
    if we’re comparing multiple models we will be blind to some of the differences
    between them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管MCC更好，但它仍然有其局限性。将整个混淆矩阵转换为单个数字会削弱我们考虑每个单元格的能力。正如我们在[“置信阈值”](#confidence_thresholds)中看到的，每个应用在精确率和召回率之间都有稍微不同的理想平衡。F1和MCC分数使我们无法单独考虑它们——因此，如果我们比较多个模型，我们将无法看到它们之间的某些差异。
- en: ROC and AUC
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ROC和AUC
- en: As we’ve learned, it’s possible to change the performance of a classifier by
    varying the confidence threshold. The impact of doing this can be visualized using
    a chart known as the *receiver operating characteristic curve*, or *ROC curve*,
    as shown in [Figure 10-2](#roc_curve_graph).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学到的，通过改变置信阈值可以改变分类器的性能。可以使用*接收者操作特征曲线*或*ROC曲线*来可视化这种影响，如[图 10-2](#roc_curve_graph)所示。
- en: Since the confidence threshold can be used to trade off between the TPR and
    FPR, the ROC curve plots one of them on either axis. To compute the curve, the
    TPR and FPR are calculated for a range of different confidence thresholds.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于置信阈值可以用来在真正率（TPR）和假正率（FPR）之间进行权衡，ROC曲线在任一轴上绘制它们之一。为了计算曲线，需要计算一系列不同置信阈值的TPR和FPR。
- en: This chart is extremely useful since it describes all of our options for tuning
    the classifier. We can pick a point on the curve that represents the trade-off
    we desire based on the needs of our application. We’d then use the corresponding
    confidence threshold to gate the output of our model.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表非常有用，因为它描述了调整分类器所有选项的情况。我们可以选择曲线上的一个点，该点代表基于我们应用程序需求的权衡。然后，我们将使用相应的置信阈值来控制模型的输出。
- en: '![The plot of an ROC curve.](assets/aiae_1002.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![ROC曲线的绘图。](assets/aiae_1002.png)'
- en: Figure 10-2\. An ROC curve plotted using Matplotlib
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-2\. 使用Matplotlib绘制的ROC曲线
- en: We can also use the ROC curve to create a single metric that describes the performance
    of our model based on the probability that it gets a particular answer right.
    It’s obtained by calculating the *area under the curve* (AUC, visible in [Figure 10-2](#roc_curve_graph)),
    and it has a value from 0 to 1\. A model with an AUC of 1 gets every single prediction
    right, while a model with an AUC of 0.5 has a 50/50 chance of predicting the right
    class.^([4](ch10.html#idm45988812680608))
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用ROC曲线来创建一个单一的度量，描述基于模型获得特定答案正确的概率。它通过计算*曲线下面积*（AUC，在[图 10-2](#roc_curve_graph)中可见）获得，并且其值从0到1。AUC为1的模型完全正确地预测每个预测结果，而AUC为0.5的模型有50/50的几率预测正确类别。^([4](ch10.html#idm45988812680608))
- en: The ROC is useful, but it’s still a single statistic representing a complex
    set of behaviors. As such, it still isn’t helpful if we’re trying to understand
    how our model will perform in different circumstances. In that case, a combination
    of ROC curve and confusion matrix will give us a lot of helpful insight.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ROC是有用的，但它仍然是一个单一统计量，代表一组复杂的行为。因此，如果我们试图了解我们的模型在不同情况下的表现，它仍然没有帮助。在这种情况下，ROC曲线和混淆矩阵的组合将为我们提供许多有用的见解。
- en: Error metrics
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 错误度量标准
- en: Classifiers are only one type of model. Another major category, regression models,
    have their own set of common metrics. Since a regression model is designed to
    predict a numeric value, the best way to understand its performance is with a
    metric that compares the difference between its output value and the value that
    a data sample is labeled with.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 分类器只是一种模型类型。另一种主要类别，回归模型，有其自己的一组常见度量标准。由于回归模型旨在预测数值，因此理解其性能的最佳方法是使用度量标准，比较其输出值与数据样本标记的值之间的差异。
- en: 'Here are some of the top error metrics used for regression models:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于回归模型的一些顶级错误度量标准：
- en: Mean absolute error (MAE)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 平均绝对误差（MAE）
- en: 'This simple metric consists of the mean of the errors, where error is defined
    as the difference between a predicted and actual value. It’s calculated for a
    dataset as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的度量标准由误差的平均值组成，其中误差定义为预测值与实际值之间的差异。其计算方法如下：
- en: <math alttext="MAE equals StartFraction sum left-parenthesis error right-parenthesis
    Over number of samples EndFraction" display="block"><mrow><mtext>MAE</mtext> <mo>=</mo>
    <mfrac><mtext>sum(error)</mtext> <mrow><mtext>number</mtext><mtext>of</mtext><mtext>samples</mtext></mrow></mfrac></mrow></math>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="MAE equals StartFraction sum left-parenthesis error right-parenthesis
    Over number of samples EndFraction" display="block"><mrow><mtext>MAE</mtext> <mo>=</mo>
    <mfrac><mtext>sum(error)</mtext> <mrow><mtext>number</mtext><mtext>of</mtext><mtext>samples</mtext></mrow></mfrac></mrow></math>
- en: For example, imagine we’ve trained a regression model to predict the weights
    of apples from photographs. Let’s assume the apples are weighed in grams. After
    testing the model, we calculate an MAE of 10\. This means that, on average, the
    predicted weight is off the actual weight by 10 grams.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们已经训练了一个回归模型，用于预测从照片中的苹果的重量。假设苹果的重量以克为单位。在测试模型后，我们计算出一个MAE为10。这意味着平均而言，预测的重量与实际重量相差10克。
- en: This simplicity makes the MAE very useful. However, there are some alternatives
    that can help shed light on different types of error.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单性使得MAE非常有用。但是，还有一些替代方法可以帮助揭示不同类型的误差。
- en: Mean squared error (MSE)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 均方误差（MSE）
- en: 'The MSE is very similar to the MAE—except that the errors are squared before
    summation:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 均方误差（MSE）与MAE非常相似——只是在求和之前将误差平方化：
- en: <math alttext="MSE equals StartFraction sum left-parenthesis squared errors
    right-parenthesis Over number of samples EndFraction" display="block"><mrow><mtext>MSE</mtext>
    <mo>=</mo> <mfrac><mrow><mtext>sum(squared</mtext><mtext>errors)</mtext></mrow>
    <mrow><mtext>number</mtext><mtext>of</mtext><mtext>samples</mtext></mrow></mfrac></mrow></math>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="MSE equals StartFraction sum left-parenthesis squared errors
    right-parenthesis Over number of samples EndFraction" display="block"><mrow><mtext>MSE</mtext>
    <mo>=</mo> <mfrac><mrow><mtext>sum(squared</mtext><mtext>errors)</mtext></mrow>
    <mrow><mtext>number</mtext><mtext>of</mtext><mtext>samples</mtext></mrow></mfrac></mrow></math>
- en: Since we square the errors, the MSE will always either be positive or zero—and
    large errors will make a bigger difference to its value. This can be helpful,
    since large errors are often worse than small ones but may be deceptively flattened
    out by the simple calculation of MAE.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对误差进行了平方处理，MSE将始终为正值或零——而大误差将会对其值产生更大影响。这是有帮助的，因为大误差通常比小误差更糟糕，但可能会因MAE的简单计算而被欺骗性地抹平。
- en: Root mean squared error (RMSE)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 根均方误差（RMSE）
- en: 'The downside of MSE is that since it’s based on squared values, it is harder
    to interpret than the MAE, which is provided in the original units. By calculating
    the square root of the MSE, known as the RMSE, we can express it in the same terms
    as the labels:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: MSE的缺点在于，由于它基于平方值，因此比MAE更难以解释，后者是以原始单位提供的。通过计算MSE的平方根，即RMSE，我们可以用与标签相同的术语表达它：
- en: <math alttext="RMSE equals StartRoot StartFraction sum left-parenthesis squared
    errors right-parenthesis Over number of samples EndFraction EndRoot" display="block"><mrow><mtext>RMSE</mtext>
    <mo>=</mo> <mroot><mfrac><mrow><mtext>sum(squared</mtext><mtext>errors)</mtext></mrow>
    <mrow><mtext>number</mtext><mtext>of</mtext><mtext>samples</mtext></mrow></mfrac></mroot></mrow></math>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="RMSE equals StartRoot StartFraction sum left-parenthesis squared
    errors right-parenthesis Over number of samples EndFraction EndRoot" display="block"><mrow><mtext>RMSE</mtext>
    <mo>=</mo> <mroot><mfrac><mrow><mtext>sum(squared</mtext><mtext>errors)</mtext></mrow>
    <mrow><mtext>number</mtext><mtext>of</mtext><mtext>samples</mtext></mrow></mfrac></mroot></mrow></math>
- en: The RMSE has the same benefits as the MSE, but it’s easier to interpret. The
    downside is that it’s slightly more complicated to think about.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: RMSE具有与MSE相同的好处，但更容易解释。不足之处在于，它稍微更复杂一些。
- en: As with classification metrics, expressing the performance of a model as a single
    value can be risky. Your dataset may contain different subgroups that experience
    different performance. We’ll cover some strategies for dealing with this issue
    in [“Techniques for Evaluation”](#techniques).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与分类度量标准一样，将模型的性能表达为单一值可能存在风险。您的数据集可能包含不同子群体，它们的性能不同。我们将在[“评估技术”](#techniques)中讨论处理此问题的一些策略。
- en: Mean average precision
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 均值平均精度
- en: '*Mean average precision*, or mAP, is a fairly complex metric that is used to
    express the performance of an object-detection model. Object-detection models
    attempt to draw bounding boxes around any objects in the image; the mAP looks
    at how well the predicted bounding boxes overlap with the real boxes—either within
    a given image or across a dataset. It combines this with something like a confidence
    interval in order to come up with a score.^([5](ch10.html#idm45988812631232))'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*均值平均精度*，或mAP，是用于表达目标检测模型性能的一个相当复杂的度量标准。目标检测模型试图在图像中绘制围绕任何对象的边界框；mAP考虑了预测边界框与实际边界框的重叠程度——无论是在给定图像内还是跨数据集。它将这一情况与置信区间之类的东西结合起来，以得出一个分数。^([5](ch10.html#idm45988812631232))'
- en: The major downside of mAP is that while it’s based on the area of the boxes,
    it doesn’t take into account the number of boxes. This means a model can score
    well on mAP even if it predicts multiple boxes where a single box should be. That
    said, it’s become the standard way of rating object detection models.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: mAP 的主要缺点是，虽然它基于框的区域，但它不考虑框的数量。 这意味着即使模型预测了多个框，而实际上只需要一个框，它也可以在 mAP 上得分良好。 尽管如此，它已经成为评估对象检测模型的标准方法。
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The [`sklearn.metrics` library](https://oreil.ly/zq0CD) contains implementations
    for most of the above metrics—along with many more. It’s worth exploring the literature
    around metrics to determine the ideal ones to use for your task.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sklearn.metrics` 库](https://oreil.ly/zq0CD)包含大多数上述指标的实现，以及更多。 探索与指标相关的文献，以确定用于您任务的理想指标是值得的。'
- en: Computational and hardware performance
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算性能和硬件性能
- en: Edge AI almost always involves managing the balance between algorithmic and
    computational performance. While algorithmic performance metrics tell us how well
    an algorithm is doing its job, computational and hardware performance metrics
    tell us how quickly the algorithm is running, and what resources are being consumed
    in the process.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘人工智能几乎总是涉及管理算法性能和计算性能之间的平衡。 虽然算法性能指标告诉我们算法执行工作的效果如何，但计算和硬件性能指标告诉我们算法运行的速度以及在过程中消耗了哪些资源。
- en: Informed by these metrics, we can make an educated trade-off between algorithmic
    complexity and computational resources. For example, the latency required for
    a particular application on given hardware may inform the size of the deep learning
    model that can be used.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些指标的指导下，我们可以在算法复杂性和计算资源之间进行明智的权衡。 例如，给定硬件上特定应用程序所需的延迟可能会影响可以使用的深度学习模型的大小。
- en: The following metrics help us understand the size of the computational task
    and the burden that it places on our hardware.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指标帮助我们了解计算任务的规模以及它对我们硬件的负担。
- en: Memory
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 记忆
- en: Memory use includes both RAM and ROM, which have fairly different properties.
    ROM is where your algorithms are stored long term, including the parameters of
    any machine learning models. RAM is the working memory of your program while it
    is running. There are hard limits on RAM and ROM (or disk space) for any edge
    device, so it’s important that your algorithms fit what is available.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 内存使用包括 RAM 和 ROM，它们具有相当不同的属性。 ROM 是长期存储算法的地方，包括任何机器学习模型的参数。 RAM 是程序在运行时的工作内存。
    任何边缘设备的 RAM 和 ROM（或磁盘空间）都有硬性限制，因此重要的是确保您的算法适合所提供的资源。
- en: An algorithm can’t run in isolation; it has to exist inside some kind of program.
    The rest of the program also takes up memory—so when you’re thinking about RAM
    and ROM usage, you’ll need to factor the rest of your application in, too. In
    most cases, you’ll end up with a RAM and ROM budget that you need your algorithm
    to stick to in order to fit within the rest of your application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 算法无法孤立运行； 它必须存在于某种程序中。 程序的其余部分也占用内存 - 因此在考虑 RAM 和 ROM 使用时，您也需要考虑应用程序的其余部分。 在大多数情况下，您最终将得到一个需要您的算法遵循的
    RAM 和 ROM 预算，以使其适合应用程序的其余部分。
- en: For example, imagine you’re adding edge AI to a brownfield system. You can analyze
    the memory being used by the existing application and decide what is left over
    for your new algorithms. Similarly, in a greenfield system you will have to decide
    how much of your ROM and RAM is budgeted for algorithms versus the other parts
    of your application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您正在将边缘人工智能添加到一个旧系统中。 您可以分析现有应用程序使用的内存，并决定剩余多少用于新算法。 类似地，在新系统中，您将不得不决定您的
    ROM 和 RAM 中有多少预算用于算法与应用程序其他部分。
- en: 'Measuring the RAM and ROM usage of an application is nontrivial. ROM seems
    relatively easy: in theory, an embedded engineer can compile a simple program
    that contains your algorithms and then look at the output to determine how large
    it is. In practice, however, there may be some overlap between the dependencies
    required for your application and for your algorithms. This means that your algorithms
    could end up making less impact on your firmware’s ROM usage than it might seem.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 测量应用程序的 RAM 和 ROM 使用情况并不简单。 在理论上，ROM 看起来相对容易：理论上，嵌入式工程师可以编译一个包含您的算法的简单程序，然后查看输出以确定其大小。
    但实际上，您的应用程序所需的依赖项与您的算法所需的依赖项可能会有重叠。 这意味着您的算法在固件的 ROM 使用上可能比看起来少得多。
- en: This means that the most reliable way of estimating your algorithms’ ROM usage
    is to build your entire application both with and without them. The difference
    tells you how much ROM is being used.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着估计算法ROM使用的最可靠方法是构建完整的应用程序，分别带有和不带有它们。差异告诉你使用了多少ROM。
- en: Deep learning models tend to be big, so you may find yourself having to reduce
    the size of your model in order to fit within a ROM budget. It’s always a good
    idea to try quantizing your model before spending a lot of time on optimizing
    the rest of your application—the resulting reduction in accuracy is usually very
    minor.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习模型往往很大，因此你可能需要缩小模型的大小以适应ROM预算。在花费大量时间优化应用程序的其余部分之前，尝试量化你的模型总是一个好主意——由此导致的精度降低通常非常小。
- en: Measuring RAM usage is a bit more challenging. First, you typically have to
    run the algorithm in order to determine it. Second, if your program uses too much
    RAM it may not actually be able to run. Third, determining RAM usage on a running
    device will require some kind of test program or debugger.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 测量RAM使用情况要更具挑战性。首先，通常你需要运行算法来确定它。其次，如果你的程序使用的RAM过多，可能实际上无法运行。第三，在运行设备上确定RAM使用情况将需要某种测试程序或调试器。
- en: A good approach to measuring RAM usage for a specific algorithm is to use a
    test program. The program should first fill the entire memory with a specific
    marker value. You can then run your algorithm. After running it, you should iterate
    through the device’s memory and check how much of it is still filled with the
    marker value. This “high watermark” will give you an estimate of memory usage—although
    it won’t tell you the worst-case memory usage, which may be higher.^([6](ch10.html#idm45988812608960))
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 测量特定算法RAM使用的一个好方法是使用测试程序。该程序首先应该用特定的标记值填充整个内存。然后你可以运行你的算法。运行后，你应该迭代设备的内存并检查其中多少仍然填充有标记值。这个“高水位线”将为你提供内存使用的估计——尽管它不会告诉你最坏情况下的内存使用情况，这可能更高。^([6](ch10.html#idm45988812608960))
- en: You can potentially use this technique with a simulator to estimate RAM use
    without having to deploy to an actual device. This can be convenient during development,
    and is the approach used within some end-to-end platforms (such as Edge Impulse).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以潜在地使用这种技术与模拟器估计RAM使用，而无需部署到实际设备上。这在开发过程中很方便，并且是某些端到端平台（如Edge Impulse）中使用的方法。
- en: Measuring RAM and ROM usage is much easier on devices with an operating system,
    since you can directly query the operating system for metrics.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在带操作系统的设备上，测量RAM和ROM的使用情况要容易得多，因为你可以直接查询操作系统获取指标。
- en: Floating-point operations (FLOPs)
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 浮点运算（FLOPs）
- en: A floating-point operation is a single computation involving two floating-point
    numbers, and FLOPS—or *floating-point operations per second*—is used as a measure
    of computing power.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点运算是涉及两个浮点数的单个计算，而FLOPS——或*每秒浮点运算次数*——被用作计算能力的度量。
- en: The total number of FLOPs is sometimes used to describe the amount of work required
    to compute one inference of a deep learning model. This makes sense for server-side
    models, since computation is typically done in floating-point arithmetic.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 总的FLOPs数量有时用来描述计算一个深度学习模型推断所需的工作量。对于服务器端模型来说，这是有道理的，因为计算通常在浮点算术中进行。
- en: Given the FLOPs of a model and the FLOPS of a processor (and looking past the
    confusing acronyms) it should, in theory, be possible to estimate the latency
    of a model. However, many edge models are quantized and therefore use integer
    math, making the FLOPs of the original model less relevant. In addition, the makers
    of embedded processors do not typically report FLOPS (or IOPS, the integer equivalent).
    Lastly, calculating FLOPs for a model is not always straightforward.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于模型的FLOPs和处理器的FLOPS（并忽略令人困惑的缩写），理论上应该能够估计模型的延迟。然而，许多边缘模型是量化的，因此使用整数运算，使得原始模型的FLOPs变得不那么相关。此外，嵌入式处理器的制造商通常不报告FLOPS（或IOPS，整数等效）。最后，计算模型的FLOPs并不总是直截了当的。
- en: In combination, all of this makes FLOPs of limited use for determining edge
    AI performance. That said, it’s worth mentioning in case you happen to encounter
    it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，所有这些使得FLOPs在确定边缘AI性能方面的用途有限。尽管如此，在遇到时还是值得一提。
- en: Latency
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 延迟
- en: In the context of edge AI, latency is the amount of time that it takes to run
    all of the parts of an algorithm, end to end. For example, it might take 100 milliseconds
    to capture a window of audio, downsample it, run it through a DSP algorithm, feed
    the result into a deep learning model, execute the model, and process the output.
    Latency is typically specified in milliseconds or as frames per second, the latter
    mostly for vision applications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在边缘AI的背景下，延迟是运行算法所有部分的总时间。例如，捕获音频窗口、降低采样率、运行DSP算法、将结果输入深度学习模型、执行模型并处理输出可能需要100毫秒。延迟通常以毫秒或每秒帧数来指定，后者主要用于视觉应用。
- en: Latency depends on the algorithms used, the optimizations available, and the
    hardware itself. Faster hardware and better optimizations (for example, those
    provided in the libraries described in [“Math and DSP libraries”](ch05.html#math_and_dsp_libraries))
    lead to lower latency—and generally, the smaller and simpler a machine learning
    model is, the lower latency it has.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟取决于所使用的算法、可用的优化以及硬件本身。更快的硬件和更好的优化（例如，描述在[“数学和DSP库”](ch05.html#math_and_dsp_libraries)中的库中提供的优化）会导致较低的延迟——一般来说，机器学习模型越小、越简单，延迟越低。
- en: 'Some applications require low latency. For example, if an application needs
    to respond in real time to user input, then it needs to operate with low latency.
    In other cases, latency is not as important: perhaps the application’s response
    can be asynchronous and does not have to happen quickly.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序需要低延迟。例如，如果一个应用程序需要实时响应用户输入，则需要以低延迟运行。在其他情况下，延迟并不那么重要：也许应用程序的响应可以是异步的，不必快速发生。
- en: In some situations, lower latency means better algorithmic performance. For
    instance, a keyword-spotting model running many times per second has more opportunity
    to detect a keyword than one running once per second.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，低延迟意味着更好的算法性能。例如，一个关键词检测模型每秒运行多次比每秒运行一次更有机会检测到关键词。
- en: Measuring latency usually requires access to a device, unless cycle-accurate
    simulation is available (see [“Emulators and simulators”](ch05.html#emulators_and_simulators)).
    However, there are some methods for estimating the performance of deep learning
    models based on benchmarking similar workloads on hardware.^([7](ch10.html#idm45988812592912))
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 测量延迟通常需要访问设备，除非有周期精确的模拟可用（参见[“仿真器和模拟器”](ch05.html#emulators_and_simulators)）。然而，有一些方法可以通过在硬件上对类似工作负载进行基准测试来估算深度学习模型的性能。^([7](ch10.html#idm45988812592912))
- en: Duty cycle
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 占空比
- en: Embedded applications are often required to limit energy usage in order to preserve
    battery life. They do so by performing computation periodically, as they receive
    new data, and then going into a low-power sleep mode while they wait for the next
    data to arrive.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式应用通常需要限制能源使用，以保护电池寿命。它们通过在接收新数据时定期执行计算，然后在等待下一批数据到达时进入低功耗睡眠模式来实现这一点。
- en: The processor’s wake/sleep pattern is known as its duty cycle. For example,
    a processor may wake up every 200 milliseconds to read some sensor data, taking
    10 milliseconds to do so. It might then spend 50 milliseconds processing the data
    using an edge AI algorithm before going back to sleep.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的唤醒/睡眠模式称为其占空比。例如，处理器可能每200毫秒唤醒一次以读取某些传感器数据，花费10毫秒这样做。然后它可能花费50毫秒使用边缘AI算法处理数据，然后回到睡眠状态。
- en: In this case, the processor wakes up for 60 milliseconds every 200 milliseconds.
    Out of every second, it would spend 350 milliseconds awake and processing data.
    This would give it a duty cycle, expressed as a percentage, of 35%.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，处理器每200毫秒唤醒60毫秒。在每秒钟中，它将花费350毫秒唤醒和处理数据。这将给它一个以百分比表示的占空比，为35%。
- en: Duty cycle is important for determining the power consumption of an embedded
    system, since it determines how much energy the processor consumes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 占空比对于确定嵌入式系统的功耗非常重要，因为它决定了处理器消耗的能量。
- en: Energy
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 能源
- en: Battery life is a common concern in embedded applications, so determining the
    energy consumption of a device is very important. It is measured in terms of current,
    and typically expressed in milliamperes (abbreviated mA, and also known as milliamps).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 电池寿命是嵌入式应用中的一个常见问题，因此确定设备的能耗非常重要。它以电流来衡量，通常用毫安（缩写为 mA，也称为毫安）来表示。
- en: Each component in an embedded system has a different current draw, and it depends
    heavily on how it is being used. For example, a processor uses more or less current
    depending on which of its features are currently enabled, and a sensor may use
    more current while it is actively making measurements.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统中的每个组件的电流消耗各不相同，这取决于其使用方式。例如，处理器根据当前启用的功能使用的电流多少不等，而传感器在进行测量时可能会消耗更多电流。
- en: For this reason, it’s important to measure energy consumption during typical
    usage. It may make sense to monitor a device for an extended period of time to
    determine its actual energy usage. This can be done with a special tool such as
    a current monitor or data logger.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在典型使用情况下测量能耗是非常重要的。可能需要长时间监控设备以确定其实际能耗，这可以通过特殊工具如电流监控器或数据记录器来完成。
- en: Battery capacity is measured in milliamp hours (mAh), which indicates the number
    of hours the battery can sustain a 1 mA current. For example, a 2,000 mAh battery
    will power a 100 mA device for 20 hours.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 电池容量以毫安时（mAh）来衡量，表示电池可以支持1毫安电流的时间。例如，一块2,000mAh的电池可以为100mA的设备供电20小时。
- en: For a processor, energy consumption is intimately connected with duty cycle,
    which is a function of latency. This means low latency algorithms save energy,
    so it’s important to factor in energy usage when designing your algorithms and
    application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理器来说，能耗与工作周期紧密相关，后者是延迟的函数。这意味着低延迟算法可以节省能量，因此在设计算法和应用程序时考虑能量使用是非常重要的。
- en: Thermal
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 热量
- en: 'Electronic components produce heat as waste, and this can be relevant in some
    applications: processors can become hot during computation, and if there’s nowhere
    for the heat to go they may have problems. In addition, some components have minimum
    operating temperatures.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 电子元件会产生热量作为废热，这在某些应用中很重要：处理器在计算过程中可能会变热，如果热量无处释放，可能会出现问题。此外，一些元件有最低操作温度要求。
- en: Thermal energy is measured in degrees Celsius. Most components’ datasheets will
    provide their operating ranges. Some processors, mostly SOCs, have built-in temperature
    sensors and can throttle their own performance if they start to get hot. MCUs
    don’t typically have this functionality, so if you want to monitor their temperatures
    it is up to you to install a sensor.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 热能以摄氏度来衡量。大多数元件的数据表将提供其操作范围。一些处理器，主要是SOC，具有内置温度传感器，并且如果它们开始变热可以自动调节性能。MCU通常没有这种功能，因此如果要监测它们的温度，则需要自行安装传感器。
- en: The lower the duty cycle of a processor, the less waste thermal energy it will
    produce. This means that latency is a tool for limiting thermal emissions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的工作周期越低，产生的废热能量就越少。这意味着延迟是限制热量排放的工具。
- en: Techniques for Evaluation
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估技术
- en: 'Evaluation makes use of a toolbox of techniques, some of which we’ve seen before
    and others that are new. Here are the most important items:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 评估使用了一套技术工具，其中一些我们之前见过，另一些是新的。以下是最重要的项目：
- en: Training, validation, and testing splits
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 训练、验证和测试数据集分割
- en: As we learned in [“Splitting Your Data”](ch07.html#splitting_your_data), it’s
    absolutely critical to divide your dataset into parts in order to prove that your
    model can perform on previously unseen data. The bulk of your evaluation should
    be done on your validation dataset.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[“数据分割”](ch07.html#splitting_your_data)中学到的，将数据集划分成部分来证明模型在以前未见数据上的表现是至关重要的。大部分评估工作应在验证数据集上完成。
- en: 'To preserve its value, you should only use your testing dataset when you think
    that you are done. If you test on your testing dataset and determine that your
    model doesn’t work, you’ll have to throw it out and start from scratch: otherwise,
    you’ll risk overfitting your model by adjusting it until it works great on your
    testing dataset but doesn’t work well on real data.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持其价值，只有当你认为已经完成时才应使用你的测试数据集。如果在测试你的测试数据集时发现模型不起作用，你将不得不放弃并从头开始：否则，你会因为调整模型直到在测试数据集上表现良好而在真实数据上表现不佳而面临过拟合的风险。
- en: Of course, you can potentially capture more data at any point during the development
    process. You should try to do this wherever possible, continually augmenting your
    entire dataset with new samples to improve your ability to train and evaluate
    models.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在开发过程的任何时候捕获更多数据。在可能的情况下，应尽量不断增加整个数据集的样本，以提高训练和评估模型的能力。
- en: Cross-validation
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉验证
- en: One of the downsides of splitting data for evaluation is that the model will
    only be as good as whatever data was in its training dataset. Cross-validation,
    which we previously encountered in [“Cross-Validation”](ch07.html#cross_validation),
    attempts to work around this, allowing a practitioner to train multiple models
    on the same dataset and compare their performance.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据拆分用于评估的一个缺点是，模型的表现只能与其训练数据集中的数据一样好。我们之前在[“交叉验证”](ch07.html#cross_validation)中遇到的交叉验证试图解决这个问题，允许从业者在同一数据集上训练多个模型并比较它们的性能。
- en: To begin, a training dataset is split into training and validation parts. A
    model is trained using the training part and tested on the validation part. The
    metrics are logged, and then the data is recombined and split again at random.
    A second model is trained on the new training split, then evaluated on the new
    validation split. This process is continued any number of times—potentially dozens.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，将训练数据集分成训练部分和验证部分。使用训练部分训练模型，然后在验证部分上进行测试。记录度量标准，然后重新组合数据并随机拆分。在新的训练拆分上训练第二个模型，然后在新的验证拆分上评估。这个过程可以任意次数重复——可能是数十次。
- en: The result of the process is a series of models, each trained and validated
    on different subsets of the data. The metrics for the models can be analyzed to
    understand whether the model’s quality is heavily dependent on the data’s composition.
    The hope is that each of the models has similar performance. If so, the best-performing
    model can be selected and scrutinized in a final test against the testing dataset.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的结果是一系列模型，每个模型都在数据的不同子集上进行了训练和验证。可以分析这些模型的度量标准，以了解模型质量是否严重依赖于数据的组成。希望每个模型的表现相似。如果是这样，可以选择表现最佳的模型，并在最终测试中针对测试数据集进行审查。
- en: The most common type of cross-validation is known as k-fold cross-validation.
    Information on the process is provided in the [scikit-learn documentation](https://oreil.ly/5uy5t).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的交叉验证类型被称为 k 折交叉验证。有关该过程的信息可以在[scikit-learn文档](https://oreil.ly/5uy5t)中找到。
- en: Analyzing subgroups
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 分析子组
- en: The metrics we learned about in [“Algorithmic performance”](#algorithmic_performance)
    can be calculated for an entire dataset, or a split—or they can be calculated
    for any arbitrary subgroup of your data. This can be an extremely powerful tool,
    especially useful for understanding the fairness of your algorithms.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“算法性能”](#algorithmic_performance)中学到的度量标准可以针对整个数据集、一个拆分或任意数据子组进行计算。这是一个非常强大的工具，特别适用于理解算法公平性。
- en: 'Imagine you are building a computer vision application to identify different
    classes of vehicles: cars, trucks, and SUVs. You can calculate algorithmic performance
    metrics for each class, which will tell you how good the algorithm is at identifying
    each type of vehicle.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您正在构建一个计算机视觉应用程序来识别不同类型的车辆：汽车、卡车和SUV。您可以为每个类别计算算法性能度量，这些度量将告诉您该算法在识别每种类型车辆时的表现如何。
- en: 'However, with a little extra information you can go beyond this. For example,
    if your dataset includes metadata about the make of a vehicle in each photograph,
    you can calculate the metrics for each of those subgroups. You can then conduct
    an analysis to make sure that your model performs equally well for each subgroup:
    for example, you might find that your model underperforms on a specific make of
    car, in which case you could try to collect more photographs of it for your training
    dataset.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，通过一些额外信息，您可以超越这一点。例如，如果您的数据集包含每张照片中车辆制造商的元数据，您可以计算每个子组的度量标准。然后，您可以进行分析，确保您的模型对每个子组的表现都同样出色：例如，您可能会发现您的模型在特定品牌的汽车上表现不佳，此时您可以尝试收集更多该品牌的照片以扩充训练数据集。
- en: The model itself doesn’t care about the make of the vehicle, only the high-level
    type (car, truck, or SUV). Regardless, you can still use information about the
    make in order to better evaluate your system. You can imagine how useful this
    type of technique is when investigating ML fairness using almost any dataset.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 模型本身并不关心车辆的制造商，只关心高级类型（汽车、卡车或SUV）。尽管如此，您仍然可以使用关于制造商的信息来更好地评估您的系统。您可以想象，当使用几乎任何数据集进行机器学习公平性研究时，这种类型的技术是多么有用。
- en: Metrics and distribution
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 度量和分布
- en: It’s common for subgroups in datasets to be unevenly distributed. For example,
    imagine you are training a classifier to distinguish between classes A, B, and
    C. Your dataset may have 60% of samples in class A, 20% in class B, and 20% in
    class C.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集中的子群体通常分布不均匀。 例如，假设您正在训练一个分类器以区分类别A、B和C。 您的数据集可能有60%的样本属于类A，20%属于类B，20%属于类C。
- en: The metrics you use for evaluation should be sensitive to problems in all of
    these classes. For example, the accuracy metric might be 60% across all classes.
    However, this single number won’t tell you if the model is getting all of class
    A correct, but none of B or C.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您用于评估的指标应对所有这些类别中的问题都敏感。 例如，准确性指标可能在所有类别中都为60%。 但是，这个单一数字不能告诉您模型是否正确地获取了所有A类，而未获取B或C类的任何一个。
- en: One way to understand whether your metrics are adequate is by “evaluating” a
    fake model that returns deliberately bad results that fit the underlying distribution
    of the data. For example, you could create a random classifier that classifies
    a random 60% of examples as A, 20% as B, and 20% as C. By evaluating the output
    of this random classifier, you can understand how well your chosen metrics communicate
    the model’s lack of performance.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 理解您的指标是否合适的一种方法是通过“评估”一个返回故意糟糕结果且符合数据底层分布的虚假模型。 例如，您可以创建一个随机分类器，将随机的60%的示例分类为A，20%为B，20%为C。
    通过评估这个随机分类器的输出，您可以了解您选择的指标如何传达模型性能的不足。
- en: Using multiple metrics
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多种指标
- en: Many different metrics can be measured for a single project. For example, you
    may determine numbers that represent accuracy on a testing dataset, computational
    latency, and memory usage. Building an effective solution often means balancing
    constraints between multiple metrics. For example, we might choose to reduce latency
    by using a simpler model—but this could result in a drop in accuracy.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个项目，可以测量许多不同的指标。 例如，您可以确定在测试数据集上的准确性、计算延迟和内存使用的数字。 构建有效解决方案通常意味着在多个指标之间取得平衡。
    例如，我们可以选择使用一个更简单的模型来减少延迟，但这可能会导致准确性下降。
- en: These individual metrics may all be important, but they don’t always matter
    *equally*. For example, for a project that needs to work at high speed, you may
    place a higher priority on latency than accuracy. In a dataset with multiple subsets,
    you may care about performance on one subset more than another.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些个别指标可能都很重要，但并不总是同等重要。 例如，对于需要高速运行的项目，您可能会将延迟放在准确性之上。 在具有多个子集的数据集中，您可能更关心一个子集的性能而不是另一个。
- en: The overall weighting of different metrics—how much you care about them individually—is
    something you’ll need to determine along with your stakeholders.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 不同指标的总体权重——您对它们的个别关注程度——是您需要与利益相关者一起确定的事情。
- en: Synthetic testing data
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 合成测试数据
- en: Data is often hard to come by, especially if you’re looking to test your system
    on rare and unusual inputs. For example, an anomaly detection system may be designed
    to catch catastrophic failures that have never actually been recorded in the real
    world.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通常难以获得，特别是如果您希望在罕见和不寻常的输入上测试系统。 例如，异常检测系统可能被设计用于捕获实际世界中从未记录过的灾难性故障。
- en: One way to get around this problem is to generate synthetic data. Synthetic
    data is any kind of data that is created artificially. This could mean taking
    a real dataset and distorting its samples to create new ones, or it may mean generating
    entirely new inputs using some kind of algorithmic process. For instance, we could
    generate a set of inputs designed to simulate catastrophic failures in order to
    test our anomaly detection system.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这个问题的一种方法是生成合成数据。 合成数据是任何一种人工创建的数据。 这可能意味着取一个真实数据集并扭曲其样本以创建新的数据，或者可能意味着使用某种算法过程生成全新的输入。
    例如，我们可以生成一组旨在模拟灾难性故障的输入，以测试我们的异常检测系统。
- en: Synthetic data can be a helpful concept. It potentially gives you access to
    an unlimited amount of labeled data that can be used for testing—or even for training
    models. However, not all data can be faked, and it’s risky to depend entirely
    on synthetic data, especially for evaluation.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 合成数据可能是一个有用的概念。 它潜在地使您能够获得大量可用于测试或甚至训练模型的标记数据。 但是，并非所有数据都可以伪造，完全依赖合成数据是有风险的，特别是对于评估。
- en: Evaluation and Responsible AI
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估与负责任人工智能
- en: Proper evaluation is one of our core tools for developing AI applications responsibly.
    If you evaluate your applications well, you’ll understand how they are likely
    to perform in the field—and across different subpopulations represented in your
    dataset. The better your evaluation, the less risk that you’ll run into an issue
    in production.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的评估是我们负责任地开发AI应用的核心工具之一。如果您能够对应用进行良好评估，就能了解它们在现场和数据集中不同子群体中的表现可能如何。评估得越好，将来在生产中遇到问题的风险就越小。
- en: Responsible design involves evaluating the problem-solution fit within its environmental
    context. Any evaluation is only as good as your understanding of the problem and
    the operating environment. This is what makes it so important to involve domain
    experts and stakeholders in the evaluation process.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 负责任的设计涉及评估问题解决方案在其环境背景中的匹配性。任何评估的效果取决于您对问题及其操作环境的理解。这就是为什么在评估过程中引入领域专家和利益相关者如此重要的原因。
- en: Evaluation is also at the core of the iterative development workflow. This pretty
    much guarantees that if you don’t do a good job of evaluation, you won’t have
    a good product. You should make sure that you put a good deal of weight on evaluation,
    and it’s worth having your stakeholders, domain experts, and advisory board give
    the process a lot of attention to make sure it will capture every detail possible.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 评估也是迭代开发工作流程的核心。这几乎可以保证，如果您的评估工作不好，您将得不到一个好的产品。您应确保充分重视评估，值得让您的利益相关者、领域专家和咨询委员会多加关注，以确保捕捉尽可能多的细节。
- en: You may have noticed that many evaluation techniques depend entirely on your
    dataset. This makes the construction of your dataset essential to ethical AI development
    (see [“Data, Ethics, and Responsible AI”](ch07.html#data_ethics_and_responsible_ai)).
    Evaluation in the field is slow and costly, so datasets are a vital tool.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，许多评估技术完全依赖于您的数据集。这使得构建您的数据集对于道德AI开发至关重要（参见[“数据、伦理与负责任AI”](ch07.html#data_ethics_and_responsible_ai)）。在现场进行评估是缓慢且成本高昂的，因此数据集是一种至关重要的工具。
- en: That said, there is no way to avoid the need for evaluation in a real-world
    environment, with real users. Quantifying the performance of your algorithms using
    test data is not enough. It’s critical to understand the way your entire system
    works in context, and with the people who are going to be using it. You will need
    to find opportunities to weave this into the workflow as early as possible.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在真实环境中、与真实用户交互时，评估的需求是不可避免的。仅仅通过测试数据来量化算法性能是不够的。关键是要理解整个系统在实际情况下以及与将要使用它的人群之间的工作方式。您需要尽早将这些内容融入工作流程中。
- en: We’ve now covered the predeployment parts of evaluating a model. We’ll look
    at tools for postdeployment evaluation in [“Postdeployment Monitoring”](#post_deployment_monitoring).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了评估模型前部署的部分内容。接下来我们将在[“后部署监控”](#post_deployment_monitoring)中探讨后部署评估的工具。
- en: Deploying Edge AI Applications
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署边缘AI应用
- en: As we mentioned in [“Deployment”](ch09.html#deployment), deployment is best
    considered an ongoing process rather than a single event at the end of a project.
    However, each time a new iteration of your system is put in contact with the real
    world there is the potential for major risk—along with valuable new learning.
    It’s important to have a process set up to account for this.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[“部署”](ch09.html#deployment)中提到的，部署最好被视为项目结束时的一个持续过程，而不是单一事件。然而，每次将您的系统的新迭代与现实世界接触时，都存在潜在的重大风险——以及宝贵的新学习。重要的是建立一个能够考虑到这一点的流程。
- en: For example, imagine you are deploying a new version of your sheep activity
    classification model. There’s a chance it might produce incorrect predictions,
    which could have a negative impact on the agricultural operation if they are not
    quickly identified as such. It may also reveal new insights that can be applied
    to the next iteration of the design—but only if they are captured.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下您正在部署一款新版本的羊活动分类模型。它可能会产生错误的预测，如果不能迅速识别出来，可能会对农业操作造成负面影响。但这也可能揭示出可以应用到下一轮设计中的新见解——前提是能够捕捉到这些见解。
- en: To make sure deployment goes smoothly, minimizes risk, and maximizes benefits,
    you should develop and document a deliberate process that you can follow each
    time. Ownership for these tasks is important; they should be tracked by members
    of your team, typically those who are responsible for product development and
    operations.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保部署顺利进行、最小化风险并最大化利益，您应该开发并记录一个有意识的过程，以便每次都能遵循。这些任务的所有权很重要；它们应该由您团队的成员跟踪，通常是负责产品开发和运营的人员。
- en: Next, we will look at some of the key tasks you might include.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一些您可能包括的关键任务。
- en: Predeployment Tasks
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署前任务
- en: 'These are tasks you should consider performing before a deployment happens.
    They should be guided by technical expertise, insight from stakeholders, and domain
    expertise from a subject matter expert:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署之前应考虑执行的任务。这些任务应由技术专家的指导、利益相关者的见解以及领域专家的专业知识指导：
- en: Decide on the objectives
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 确定目标
- en: Each deployment should have clear, written objectives. For example, you might
    be deploying more devices in order to scale a system up, or you might be deploying
    the latest iteration of software to a set of hardware that is already in the field.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 每次部署都应有清晰的书面目标。例如，您可能会部署更多设备以扩展系统，或者将最新版本的软件部署到已经部署在现场的硬件集。
- en: To better manage risk and improve your ability to measure performance, you should
    try to limit the number of objectives for a given deployment. Like any experiment,
    the more input variables you adjust, the more difficult it is to understand what
    caused changes in the output.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地管理风险并提高您测量性能的能力，您应该尽量限制每次部署的目标数量。像任何实验一样，您调整的输入变量越多，就越难理解导致输出变化的原因。
- en: Identify key metrics
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 识别关键指标
- en: To understand the impact of a deployment, you’ll need to keep track of metrics
    that describe what your system is doing. These should include performance metrics,
    if available, in addition to general numbers that will highlight any changes—such
    as the distribution of inputs and outputs.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解部署的影响，您需要跟踪描述系统操作的指标。这些指标应包括性能指标（如果可用），以及能够突出任何变化的一般数字—例如输入和输出的分布。
- en: You’ll use these metrics to understand both the changes made by whatever you
    have deployed, and whether your objectives have been met.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用这些指标来理解您部署的任何变化，并确定您的目标是否已经达到。
- en: Performance analysis
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析
- en: Before deploying a new iteration of your software or hardware, you need to have
    a good understanding of how it is likely to perform—and whether this performance
    is acceptable for a system that will be running in production. There are various
    methods of estimating performance in the lab (one such method is discussed in
    [“Performance Calibration”](#performance_calibration))—you should make use of
    them wherever possible before deploying to the field.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署软件或硬件的新迭代之前，您需要充分了解其可能的性能表现，并且这种性能是否对运行在生产环境中的系统可接受。在实验室中有各种方法来估算性能（其中一种方法在[“性能校准”](#performance_calibration)中讨论）—在部署到实地之前，您应该尽可能利用这些方法。
- en: If an iteration doesn’t perform well in the lab, it’s definitely not likely
    to perform well in the field. What’s more, measuring performance can be *much*
    harder in a real-world context, since labeled data is rare, so you should take
    advantage of every mechanism for predeployment testing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个迭代在实验室中表现不佳，那么在实地环境中也不太可能表现良好。此外，在真实世界的背景下，由于标记数据稀缺，测量性能可能会更加困难，因此您应该充分利用每一种预部署测试机制。
- en: Document possible risks
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 记录可能的风险
- en: Each time you take a new iteration into production, you’re introducing some
    risk. Before you deploy, it’s important to try to identify any possible risks,
    understand their impact, and think about how you might mitigate or recover from
    them.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您将新迭代推向生产环境，都存在一定的风险。在部署之前，重要的是尝试识别可能的风险，了解它们的影响，并考虑如何减轻或恢复这些风险。
- en: If things go badly enough, you may need to halt the deployment or shut down
    the project to avoid causing harm. Based on the risks, you should put together
    a set of termination criteria (see [“Termination Criteria”](#termination_criteria))
    that will help you know when to make the call.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果情况变得糟糕，您可能需要暂停部署或关闭项目以避免造成损害。基于风险，您应该制定一套终止标准（参见[“终止标准”](#termination_criteria)），这将帮助您确定何时作出决策。
- en: Determine recovery plan
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 确定恢复计划
- en: If something bad does happen as a result of deployment, you’ll need a plan for
    recovering from it. This might mean rolling back to an earlier version of the
    system, or it could mean repairing some harm that has been caused to the processes
    you are interacting with.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于部署而发生了不良后果，您需要制定一个恢复计划。这可能意味着回滚到系统的早期版本，或者修复由您正在交互的过程中造成的一些损害。
- en: Being prepared ahead of time will allow you to take more calculated risks without
    fear of disaster. You should have a plan for dealing with the consequences of
    all of the possible risks you have identified.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 提前准备将使您能够更冒险而不担心灾难。您应该为应对所有已识别可能风险的后果制定计划。
- en: This may involve making use of the strategies for graceful degradation that
    you have designed into your application (see [“Graceful Degradation”](ch08.html#graceful_degradation)).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能涉及利用您设计的应用程序中的优雅降级策略（参见[“优雅降级”](ch08.html#graceful_degradation)）。
- en: Deployment design
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 部署设计
- en: Based on your objectives, you’ll need to design a strategy for deploying your
    work. For example, you may have to decide what version of your software and hardware
    to deploy, how many devices to deploy to, and to which specific places to deploy.
    You’ll also need to figure out any automation that is necessary to reduce the
    time taken for deployment and to ensure consistency across devices. IoT device
    management platforms may help here.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的目标，您需要设计一个部署工作的策略。例如，您可能需要决定部署哪个软件和硬件版本，部署多少设备以及部署到哪些具体位置。您还需要找出任何必要的自动化措施，以减少部署时间并确保设备间的一致性。IoT设备管理平台可能在这方面有所帮助。
- en: For example, if you have devices located in multiple factories around the world,
    you might decide to deploy your latest software to a single factory for testing
    in order to isolate any risk. Alternatively, you could deploy to a few devices
    in each factory in order to get a cross-section view of how it performs across
    a diverse set of contexts. The best strategy depends on your particular situation,
    and figuring it out will require business and domain expertise.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您在世界各地的多个工厂中有设备，您可能会决定将最新软件部署到一个工厂进行测试，以隔离任何风险。或者，您可以在每个工厂部署几台设备，以获取在各种背景下性能表现的横截面视图。最佳策略取决于您的具体情况，找到答案将需要商业和领域专业知识。
- en: 'If planning a widespread deployment, it’s always a good idea to perform a staged
    rollout: start with a small subset of devices, see how it goes, and then deploy
    the remainder in waves. This will keep risk to a minimum and allow you to more
    easily recover if something goes wrong.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计划进行广泛部署，进行分阶段的推出总是个好主意：从小部分设备开始，看看情况如何，然后分批次部署其余设备。这将使风险降到最低，并在出现问题时更容易恢复。
- en: Review alignment with values
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 检查与价值观的一致性
- en: Any software or hardware that you ship must go through a detailed review for
    potential ethical issues. It’s important to analyze any changes that have been
    made since the last deployment, in case they introduce novel concerns. In addition,
    your deployment plan itself should be subject to ethical analysis that incorporates
    domain expertise.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 任何您发布的软件或硬件都必须经过详细审查，以发现潜在的道德问题。分析自上次部署以来所做的任何更改非常重要，以防引入新的问题。此外，您的部署计划本身也应该经过道德分析，并结合领域专业知识。
- en: For example, if planning a staged rollout, it is worth considering whether the
    rollout is being done over a representative population of users. You may miss
    issues affecting some groups of users if they are not represented in the initial
    stages of the rollout.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果计划进行分阶段推出，值得考虑的是推出是否正在代表用户的典型群体进行。如果在推出的初始阶段没有代表某些用户群体的情况，您可能会错过影响这些群体的问题。
- en: Communication plan
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 沟通计划
- en: It’s critical to communicate any changes to a production system before, during,
    and after the deployment. By creating a plan for communication, you can ensure
    that this happens effectively. Your goal should be to make sure that anyone who
    might be affected by the deployment, including by any potential unintended issues
    captured in your risk documentation, is aware of the planned action, its risks,
    and any role they may have to play. This includes stakeholders and members of
    your development team.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署之前、期间和之后，向生产系统通报任何变更至关重要。通过创建沟通计划，您可以确保这一点有效实施。您的目标应该是确保所有可能受到部署影响的人，包括在风险文档中捕捉到的任何潜在意外问题，都知道计划行动、其风险以及可能需要扮演的任何角色。这包括利益相关者和您开发团队的成员。
- en: Communication should go in both directions, since there may be factors you are
    unaware of that might affect your deployment plan. For example, you may find out
    about scheduled activities that might overlap with your planned deployment and
    influence the metrics you are trying to measure.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通信应该是双向的，因为您可能不了解可能影响部署计划的因素。例如，您可能会发现与计划部署时间重叠并影响您试图测量的指标的预定活动。
- en: Go/no-go decision
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 决策是否前进
- en: Once all of the appropriate documentation has been assembled, the final step
    is to review it and make a go/no-go decision. You may determine that the level
    of risk is too high, or that some confounding factor means that the deployment
    should be delayed. Otherwise, you may make the call to go ahead.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有适当的文档都被汇编好，最后一步是审查并做出是否前进的决策。您可能会确定风险水平过高，或者某些混淆因素意味着应该延迟部署。否则，您可能会决定继续前进。
- en: It’s important that the go/no-go decision involves input from stakeholders,
    domain experts, and your technical team, since all of them have insight into potential
    issues that are important not to overlook.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 决策是否前进的重要性在于需要来自利益相关者、领域专家以及您的技术团队的输入，因为他们都对可能被忽视的潜在问题有深入了解。
- en: Mid-Deployment Tasks
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署中期任务
- en: 'These are tasks you should consider while the deployment happens, in addition
    to the mechanics of the deployment itself:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署过程中，除了部署机制本身，您还应考虑以下任务：
- en: Two-way communication
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 双向沟通
- en: You should communicate clearly with anyone who might be affected by the deployment,
    according to the plan created in your predeployment tasks. This includes listening
    out for any potential issues that might happen during the deployment and be noticed
    by people working adjacent to it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您应根据预部署任务中制定的计划，与可能受部署影响的任何人进行清晰沟通。这包括倾听部署期间可能发生并被旁边工作人员注意到的任何潜在问题。
- en: Staged rollout
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 分阶段推出
- en: To keep risk to a minimum, deployment should be conducted in stages rather than
    all at once. Coordinating this staged rollout is a major task. The most important
    aspects are keeping track of what has been deployed where, and monitoring how
    each stage might be impacting the metrics you are tracking.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将风险降至最低，部署应该分阶段进行，而不是一次性全部完成。协调这种分阶段推出是一项重要任务。最重要的方面是跟踪在哪里部署了什么，并监控每个阶段可能如何影响您正在跟踪的指标。
- en: In some cases, you may already have devices in the field that can’t be updated.
    For example, they might not be capable of firmware updates. If this is the case,
    you need to be very careful about keeping track of which devices have which version
    of the firmware and your algorithms.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能已经在现场使用无法更新的设备。例如，它们可能无法进行固件更新。如果是这种情况，您需要非常小心地跟踪哪些设备使用了哪个固件版本和算法。
- en: Monitor metrics
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 监控指标
- en: You’ll need to keep track of all your key metrics during deployment—and be prepared
    to halt or roll back the process if things are not going well. Based on your predeployment
    work, you should have an understanding of your expectations regarding how the
    metrics you are monitoring will change. If you observe something different, it’s
    a good idea to pause the deployment and investigate what is happening. If it looks
    like something harmful has occurred, you should roll back to an earlier state
    and fix the issue.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在部署期间跟踪所有关键指标，并准备在事情进展不顺利时停止或回滚流程。根据预部署工作，您应该了解您所监测的指标预期会如何变化。如果观察到不同的情况，暂停部署并调查发生了什么是一个好主意。如果看起来发生了有害事件，您应该回滚到之前的状态并修复问题。
- en: Tip
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: One of the core goals of a responsible AI workflow is to prevent any harm from
    being caused. One of your jobs is to anticipate the potential for harm in advance
    and create a design that prevents it from happening. While unexpected things may
    happen, an unanticipated instance of harm means that your ethical review process
    is broken.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 负责任的人工智能工作流程的核心目标之一是防止造成任何伤害。您的工作之一是预见可能的伤害，并创建一个设计来防止其发生。虽然可能会发生意外事件，但未预料到的伤害事件意味着您的伦理审查流程存在缺陷。
- en: Postdeployment Tasks
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后部署任务
- en: 'The work doesn’t end immediately after completing a staged deployment. Here
    are some tasks that you may need to attend to afterward:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成分阶段部署后工作并不会立即结束。以下是之后可能需要处理的一些任务：
- en: Communicate status
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 沟通状态
- en: In line with your communication plan, you should make sure that everyone affected
    is updated with the status of the deployment after it has happened. They should
    also have a clear, continuously open channel via which to alert you of any unexpected
    changes they observe in the system.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的沟通计划，您应确保所有受影响者在部署完成后得到更新的状态。他们还应该有一个清晰、持续开放的渠道，通过该渠道可以提醒您观察到系统中的任何意外变化。
- en: Postdeployment monitoring
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后监控
- en: It’s wise to keep monitoring a system for some time after deployment has concluded.
    There may be effects that show up with some delay. Ideally, these types of risks
    will have been identified during your risk documentation process with the help
    of a domain expert. There’ll be more information about monitoring in [“Postdeployment
    Monitoring”](#post_deployment_monitoring).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署结束后一段时间内继续监控系统是明智的。可能会有一些延迟出现的效果。理想情况下，这些类型的风险在风险文档过程中已经得到了识别，并得到了领域专家的帮助。关于监控的更多信息将在[“部署后监控”](#post_deployment_monitoring)中提供。
- en: Deployment report
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 部署报告
- en: After deployment, you should create a written summary report that includes your
    original plans, what actually happened, and any actions that were taken. This
    report will help guide future deployments, and can be shared with your stakeholders.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后，您应该编写一份总结报告，其中包括您的原始计划、实际发生的事情以及所采取的任何行动。这份报告将有助于指导未来的部署，并可以与您的利益相关者共享。
- en: This may all sound like a lot of activity—but by being systematic about deployments
    and documenting everything you do, you are less likely to suffer from unexpected
    issues. Over multiple deployments of the same project, you will begin to develop
    an efficient system that requires minimal work and is described by a solid set
    of documentation. This system will be an important part of the ongoing support
    of the project.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很繁忙，但通过系统化地进行部署并记录所做的每一步，您将更少遭受意外问题的困扰。通过多次部署同一项目，您将开始发展出一个需要最少工作并由一套坚实文档描述的高效系统。这个系统将是项目持续支持的重要组成部分。
- en: Supporting Edge AI Applications
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持边缘人工智能应用程序
- en: Deployment marks the beginning of the support phase of your project. All technology
    projects require long-term support. From an edge AI perspective, support involves
    keeping track of the performance of the system over time. If you see performance
    change, you can take action—ranging from updating your algorithms to terminating
    the deployment.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 部署标志着项目支持阶段的开始。所有技术项目都需要长期支持。从边缘人工智能的角度来看，支持包括随时间跟踪系统的性能。如果发现性能变化，可以采取行动，从更新算法到终止部署。
- en: It’s important from an ethical perspective that projects are well supported.
    If a project is abandoned, or left to limp along without proper monitoring, it
    may end up causing harm. Drift (as seen in [“Drift and Shift”](ch07.html#drift_and_shift))
    can transform a convenient gadget into a dangerous trap. If you aren’t able to
    commit to proper long-term support of your project, you shouldn’t launch it in
    the first place.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 从伦理角度来看，项目得到良好支持是很重要的。如果一个项目被放弃，或者没有得到适当的监控而被随意进行，可能会造成伤害。漂移（如在[“漂移和变化”](ch07.html#drift_and_shift)中看到的）可以将一个方便的小工具变成一个危险的陷阱。如果您不能承诺对项目进行适当的长期支持，那么最好不要首先启动它。
- en: Since edge AI hasn’t existed for very long, support is the least developed component
    of the workflow in terms of tools and best practices. Some of the best practices
    from server-side AI can be applied to edge problems, but many of them can’t. The
    remainder of this chapter will explore the challenges and opportunities in this
    space.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于边缘人工智能存在时间不长，支持是工作流程中工具和最佳实践方面最不发达的组成部分。一些来自服务器端人工智能的最佳实践可以应用于边缘问题，但其中许多则不行。本章的其余部分将探讨这一领域的挑战和机遇。
- en: Postdeployment Monitoring
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署后的监控
- en: The first part of long-term support is monitoring. As soon as the first prototypes
    of your hardware are deployed, you’ll need to begin collecting data on how they
    are operating. This can be a big challenge, since sometimes you won’t even have
    connectivity with devices.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 长期支持的第一步是监控。一旦您的硬件原型被部署，您就需要开始收集它们操作情况的数据。这可能是一个巨大的挑战，因为有时甚至与设备没有连接。
- en: 'Here are some possible scenarios:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可能的情景：
- en: There’s good internet connectivity with deployed devices, so it’s possible to
    gather statistics and data samples from the field. For example, a connected appliance
    may be able to use home WiFi to send back large amounts of data.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署设备具有良好的互联网连接，因此可以从现场收集统计数据和数据样本。例如，连接的家用电器可以使用家庭WiFi发送大量数据。
- en: There is enough limited connectivity to obtain basic statistics and metrics,
    but not enough to sample data. For example, a smart sensor deployed on a remote
    oil well may be able to send a few bytes of data via LoRaWAN, a technology for
    long range, low power wireless communication.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有足够的有限连接性以获取基本统计数据和指标，但不足以对数据进行采样。例如，部署在偏远油井上的智能传感器可以通过LoRaWAN发送少量数据字节，LoRaWAN是一种用于远距离、低功耗无线通信的技术。
- en: There’s no connectivity, but user feedback is available. For example, the user
    of a smart wildlife camera can provide feedback on whether it photographs the
    correct animals.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有互联网连接，但用户反馈是可用的。例如，智能野生动物摄像机的用户可以提供有关其是否拍摄到正确动物的反馈。
- en: There is no connectivity and user feedback is not available.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有互联网连接，也没有用户反馈可用。
- en: 'As you can see, connectivity and the ability to obtain feedback can vary a
    lot between applications. Ideally, there’s at least some connectivity: you should
    think twice about deploying in a context where there is no way to gather feedback
    whatsoever, since it means you’ll have literally no idea how your system is performing.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，各种应用程序之间的连接性和获取反馈的能力可能有很大差异。理想情况下，至少应有一定的连接性：在根本无法收集任何反馈的情境中部署，您应该三思，因为这意味着您将完全不知道系统的表现如何。
- en: Assuming you have some mechanism for feedback, the goal should be to collect
    as much information as possible about what is going on.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一些反馈机制，目标应该是收集关于正在发生的情况尽可能多的信息。
- en: Types of feedback from deployed systems
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署系统的反馈类型
- en: Server-side ML applications have it easy. Since all of their input data is available
    on the server, it can be logged and stored for later analysis. For example, imagine
    a server-side application that uses computer vision to identify specific products
    from photographs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端机器学习应用程序相对容易。由于它们的所有输入数据都在服务器上可用，因此可以将其记录和存储以供以后分析。例如，想象一个服务器端应用程序，使用计算机视觉从照片中识别特定产品。
- en: Since it is on a server, it has effectively unlimited storage to keep records
    of the photographs people upload. This means that the developers can go through
    and analyze the model’s predictions, determine whether they are effective, and
    even label the data and use it for training.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它位于服务器上，拥有有效的无限存储空间来保留人们上传的照片记录。这意味着开发人员可以浏览和分析模型的预测，确定其是否有效，甚至标记数据并用于训练。
- en: 'Some applications have it even easier: there’s a built-in measure of success.
    For example, if you build an algorithm to recommend products that users might
    like, you can measure its effectiveness by counting how often a recommended product
    was bought.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 有些应用程序甚至更容易：这些应用程序内置了成功的度量标准。例如，如果您开发了一个推荐用户可能喜欢的产品的算法，您可以通过统计推荐产品被购买的频率来衡量其效果。
- en: These tight feedback loops allow for iteration and rapid improvement on algorithm
    and application design. But things are not so easy on the edge. We typically lack
    direct insight into outcomes—although not always. We also have less ability to
    keep a record of the model’s inputs. Due to this lack of immediate feedback, we
    have to come up with some clever ways to understand what is going on.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这些紧密的反馈循环允许在算法和应用设计上进行迭代和快速改进。但在边缘上并非如此简单。我们通常缺乏对结果的直接洞察力——尽管并非总是如此。我们还没有能力记录模型的输入。由于缺乏即时反馈，我们必须想出一些聪明的方法来理解发生了什么。
- en: Data samples
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据样本
- en: 'In an ideal situation, we can collect samples of raw inputs and send them back
    to a server for storage. This is only possible when the stars align: we need a
    perfect combination of energy availability, connectivity and bandwidth, and a
    use case where privacy is not important.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，我们可以收集原始输入的样本并将其发送回服务器进行存储。这仅在星星完美对齐时才可能：我们需要能源可用性、连接性和带宽的完美组合，以及隐私不重要的用例。
- en: For example, imagine we’ve built a low-power sensor that is designed to monitor
    how packages are treated during shipment. To save energy and cost, it may lack
    the ability to store or transmit data during transit. This means it has no way
    to send samples of raw inputs back for analysis.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下，我们构建了一个低功耗传感器，设计用于监测货物在运输过程中的处理方式。为了节省能量和成本，它可能缺乏在运输过程中存储或传输数据的能力。这意味着它无法发送原始输入的样本进行分析。
- en: As another example, imagine we’ve built a home security camera that uses a deep
    learning model for person detection. If the product is marketed as using edge
    AI to preserve privacy, it won’t be feasible for us to capture samples of its
    input.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子，想象一下，我们构建了一个家庭安全摄像头，它使用深度学习模型进行人员检测。如果产品被市场宣传为使用边缘人工智能来保护隐私，那么捕获其输入的样本将是不可行的。
- en: However, there are certainly situations where enough energy and connectivity
    are available for sending samples of data. And even if resources are scarce, there
    are still ways you can make it work.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，肯定存在足够的能量和连接性的情况，可以发送数据样本。即使资源稀缺，您仍然可以找到方法使其发挥作用。
- en: Some applications are able to create a feedback loop by sampling limited amounts
    of data. Rather than try to send every input to a server, they pick specific instances.
    This could be at random (e.g., every one in a thousand), it could be periodic
    (e.g., once per day), or it could be based on some intelligent criteria. An interesting
    way to approach this is to identify when your algorithm is uncertain about an
    input—for example, when none of a classifier’s classes meet the confidence threshold—and
    send those inputs. Since they’re the ones the model appears to be struggling with,
    they may be the most useful to analyze.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 有些应用程序可以通过采样有限数量的数据创建反馈循环。与其尝试将每个输入都发送到服务器，它们会选择特定的实例。这可以是随机的（例如，每千个中的一个），也可以是周期性的（例如，每天一次），或者可以基于一些智能标准。一个有趣的方法是识别算法对输入感到不确定的时候，例如分类器的类别都不满足置信阈值时，并发送这些输入。因为它们是模型似乎在努力处理的部分，它们可能是最有用的进行分析的部分。
- en: For example, a successful edge AI–powered trail camera sends thumbnail images
    of animals back to a server via a satellite connection. It would be too expensive
    to send full images, but thumbnails can still give valuable insight into what
    is going on in the field.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个成功的边缘人工智能驱动的追踪摄像机通过卫星连接将动物的缩略图发送回服务器。发送完整图像将会太昂贵，但缩略图仍然可以提供有价值的场地信息。
- en: 'If downsampled data is still too heavy, you might choose to send only parts
    of the data. For example, you could send grayscale images instead of color. It
    can also be interesting to send aggregate statistics about inputs: for example,
    you might send a periodic moving average of a time series rather than the entire
    thing. This can help with detecting drift.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果降采样后的数据仍然太重，您可能会选择只发送数据的部分。例如，您可以发送灰度图像而不是彩色图像。发送输入的聚合统计数据也可能很有趣：例如，您可以发送时间序列的周期移动平均值而不是整个时间序列。这有助于检测漂移。
- en: Often, your algorithm will use a fixed pipeline of signal processing algorithms
    before feeding the data into a model. In this case, since you know how the signal
    processing algorithms will behave, it’s likely to be perfectly fine to send the
    processed data rather than the raw input. The processed data is typically smaller
    and therefore easier to transmit.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您的算法会在将数据馈送到模型之前使用一系列固定的信号处理算法。在这种情况下，由于您了解信号处理算法的行为方式，直接发送处理后的数据通常是可以接受的。处理后的数据通常更小，因此更容易传输。
- en: You may not be able to transmit much data once you’re fully in production, but
    you shouldn’t let this stop you from accessing real-world data during the initial
    stages of your deployment. For example, you might decide that it’s worthwhile
    to pay for some expensive connectivity (via cellular or satellite modem, for instance)
    for the first couple of months of deployment so that you can gather feedback and
    use it to improve your system.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完全投入生产，您可能无法传输大量数据，但这不应妨碍您在部署的初始阶段访问真实世界的数据。例如，您可能决定在部署的头几个月内支付一些昂贵的连接费用（例如通过蜂窝或卫星调制解调器），以便收集反馈并用于改进系统。
- en: Another alternative way to obtain data is via [sneakernet](https://oreil.ly/Bby0S)—have
    devices log data to local storage, then walk out and pick them up every so often.
    Like paying for expensive connectivity, this might not be scalable across an entire
    deployment—but it’s certainly doable for some devices, or during a specific period
    of time.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种获取数据的替代方法是通过[sneakernet](https://oreil.ly/Bby0S)——让设备将数据记录到本地存储，然后定期出去取回。与支付昂贵的连接费用一样，这可能无法在整个部署中扩展使用，但对于某些设备或特定时间段来说，这是可行的。
- en: Distribution changes
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分布变化
- en: As we learned in [“Drift and Shift”](ch07.html#drift_and_shift), the real world
    changes over time—but our dataset only represents a snapshot. If it turns out
    our dataset is no longer representative, we have a problem and we need to know
    about it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[“漂移和变化”](ch07.html#drift_and_shift)中所学到的，真实世界随时间变化——但我们的数据集只代表一个快照。如果我们的数据集不再代表性，我们就有问题，需要及时了解。
- en: The best way to do this is to collect a new dataset that represents current
    conditions, then compare it to our existing one. Unfortunately, collecting and
    labeling a dataset is extremely labor intensive, and—as we’ve seen—it’s not often
    feasible to send actual data samples back from the field.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳方法是收集一个代表当前条件的新数据集，然后将其与我们现有的数据集进行比较。不幸的是，收集和标记数据集非常费时，正如我们所见，从现场发送实际数据样本并不常见。
- en: 'Instead, we need some mechanism for understanding whether the real-world data
    still resembles our dataset: whether its *distribution* has changed. If we see
    the distribution change more than a little, chances are that there has been some
    drift and we will need to account for it.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要某种机制来理解真实世界的数据是否仍然类似于我们的数据集：是否其*分布*已经改变。如果我们看到分布变化超过一点点，很可能发生了一些漂移，我们需要加以考虑。
- en: The simplest way of identifying drift is to calculate [summary statistics](https://oreil.ly/SbIKi)
    for our dataset, compute the same statistics on-device, and compare them. *Summary
    statistics* are numbers that represent a group of measurements in aggregate. For
    example, you might calculate the mean, median, standard deviation, kurtosis, or
    skew of readings for a particular sensor.^([8](ch10.html#idm45988812384736)) You
    can even look at the amount of correlation between readings from multiple sensors.
    If the values are different between your dataset and what the device collects
    in the field, you may have a problem.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 识别漂移的最简单方法是计算我们数据集的[摘要统计信息](https://oreil.ly/SbIKi)，在设备上计算相同的统计信息，然后进行比较。*摘要统计信息*是代表一组测量值的数值总结。例如，您可以计算特定传感器读数的均值、中位数、标准偏差、峰度或偏度。^([8](ch10.html#idm45988812384736))
    您甚至可以查看多个传感器读数之间的相关性程度。如果您的数据集与设备在现场收集的数据值不同，可能存在问题。
- en: Summary statistics can only identify the simplest of changes in distribution.
    There are also some more sophisticated statistical tests that can analyze samples
    from two populations and determine how much they differ. Examples of some of these
    algorithms can be found in the documentation for [Alibi Detect](https://oreil.ly/bSlZu),
    which is an open source library for drift detection (among other things). Unfortunately,
    many of these methods struggle with high-dimensional data such as images and audio
    spectrograms.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要统计只能识别分布中最简单的变化。还有一些更复杂的统计测试可以分析来自两个群体的样本，并确定它们之间的差异程度。这些算法的一些示例可以在[Alibi
    Detect](https://oreil.ly/bSlZu)的文档中找到，这是一个用于漂移检测（以及其他用途）的开源库。不幸的是，许多这些方法在处理诸如图像和音频频谱图等高维数据时存在困难。
- en: At the time of writing, there is still a great deal of work that needs to be
    done to understand the best drift detection approaches for use on edge devices.
    Today, drift detection is most commonly achieved by the use of anomaly detection
    algorithms (as seen in [“Anomaly detection”](ch04.html#anomaly_detection)). An
    anomaly detection model is trained on the training dataset, then run on-device
    on every new input. If a high proportion of inputs are classified as anomalous,
    there may be drift occurring. End-to-end platforms typically have some features
    that can help with this.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在撰写本文时仍需大量工作来了解在边缘设备上使用最佳漂移检测方法。如今，漂移检测通常通过异常检测算法实现（如在[“异常检测”](ch04.html#anomaly_detection)中所见）。异常检测模型在训练数据集上进行训练，然后在每个新输入上设备上运行。如果大部分输入被分类为异常，可能存在漂移。端到端平台通常具有一些功能，可以帮助处理这些情况。
- en: It can be interesting to monitor distribution changes in both the input data—for
    example, images, time series, or audio collected from sensors—and the output of
    algorithms, such as the probability distributions produced by a classifier. Distribution
    changes in the output can be a downstream sign of drift. For example, maybe the
    balance of classes is different in real-world data. This may be a sign that you
    should improve your dataset.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 监控输入数据（例如传感器收集的图像、时间序列或音频）和分类器生成的概率分布等算法输出的分布变化可能是有趣的。输出中的分布变化可能是漂移的下游迹象。例如，实际数据中的类别平衡可能不同。这可能是您应该改进数据集的迹象。
- en: In addition, output distribution changes can notify you of bugs and errors in
    your algorithms or application code. For example, if you notice after an update
    that your model is always predicting the same class, perhaps a bug was introduced.
    Issues are usually more subtle than this, but it’s always good to track the distribution
    of both inputs and outputs.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，输出分布的变化可以通知您算法或应用代码中的错误和漏洞。例如，如果您注意到更新后您的模型始终预测相同的类别，可能是引入了错误。问题通常比这更为微妙，但跟踪输入和输出的分布总是明智的做法。
- en: There are two ways you can use information about potential distribution changes.
    If you have access to some connectivity, you may be able to transmit distribution
    data to a central server for monitoring and analysis. It will allow you to have
    at least somewhat of a feedback loop with what is going on in production.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以利用关于潜在分布变化的信息。如果您可以访问某些连接性，您可能能够将分布数据传输到中央服务器进行监控和分析。这将允许您至少在一定程度上与生产过程中发生的情况保持反馈循环。
- en: If you don’t have any connectivity at all, you can still potentially use measures
    of distribution change to control application logic. For example, you might choose
    to reject any inputs that fall outside of the expected distribution. This can
    help prevent your application from making decisions based on input that its algorithms
    were not designed or trained for.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您完全没有任何连接性，您仍然可能利用分布变化的措施来控制应用逻辑。例如，您可能选择拒绝任何不符合预期分布的输入。这可以帮助防止您的应用基于其算法未设计或训练的输入做出决策。
- en: If you are noticing distribution changes, the best course of action is typically
    to collect more training data and use it to improve your algorithms. We’ll learn
    more about this workflow in [“Improving a Live Application”](#improving_a_live_application).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到分布变化，通常最佳的做法是收集更多的训练数据，并用它来改进您的算法。我们将在[“改进现有应用”](#improving_a_live_application)中更深入地了解这个工作流程。
- en: Application metrics
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用指标
- en: 'Beyond the raw inputs and outputs of your model, it’s a great idea to keep
    track of what your application is doing by storing or transmitting some logs.
    This might include things like:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模型的原始输入和输出之外，通过存储或传输一些日志来跟踪应用程序的活动是一个好主意。这可能包括以下内容：
- en: System logs
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 系统日志
- en: For example, when the device was started, how long it has been running, power
    consumption, and battery life
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，设备启动时长、运行时间、功耗和电池寿命
- en: User activity
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 用户活动
- en: Includes actions taken by a user, buttons pressed, or data entered
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 包括用户执行的操作、按下的按钮或输入的数据
- en: Device actions
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 设备操作
- en: Things the device has done on its own, such as producing output as a result
    of an algorithmic decision
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 设备自动执行的操作，例如根据算法决策生成输出
- en: Back in [“Artificial Intelligence”](ch01.html#artificial_intelligence) we decided
    that the definition of intelligence is “knowing the right thing to do at the right
    time.” Application metrics help us understand if this statement applies to our
    system once it is deployed in the field. By examining the relationships between
    different types of events, we can try to determine if the device is being used
    in the ways we anticipated. If it is not, there may be a problem.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[“人工智能”](ch01.html#artificial_intelligence)，我们决定智能的定义是“在正确的时间做正确的事情”。应用指标帮助我们了解系统在部署后是否符合这一说法。通过检查不同类型事件之间的关系，我们可以尝试确定设备是否按照我们预期的方式使用。如果没有，则可能存在问题。
- en: For example, imagine we have built an edge AI microwave that can determine the
    best cooking time for a dish using computer vision. Our analysis of application
    logs might show that users are consistently running the microwave slightly longer
    than the estimated cooking time. This is a sign that our application may not be
    doing a good job and should be investigated further.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们建立了一台边缘AI微波炉，可以使用计算机视觉确定菜肴的最佳烹饪时间。我们对应用程序日志的分析可能显示，用户通常会比估计的烹饪时间略长地运行微波炉。这表明我们的应用程序可能表现不佳，需要进一步调查。
- en: If you’re able to access logs from multiple devices on a central server, you
    can do high-level analysis that looks across all of the devices. But depending
    on your level of connectivity, you may not be able to transmit full sets of logs—or
    even any logs at all. However, you may be able to send some form of summary statistics
    that describe what is occurring in your logs.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能够从中央服务器访问多台设备的日志，您可以进行跨设备的高级分析。但是根据您的连接级别，您可能无法传输完整的日志集，甚至根本无法传输任何日志。但是，您可能能够发送某种形式的摘要统计数据，描述日志中发生的情况。
- en: For instance, you might decide ahead of time that it is worth knowing whether
    the user is running the microwave longer than recommended. You could then send
    that specific information back for analysis without needing to upload an entire
    set of logs.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能提前决定是否值得知道用户是否超过推荐的微波使用时间。然后，您可以将该特定信息发送回进行分析，而无需上传整套日志。
- en: 'If you can’t upload any data, you can always log it on-device anyway: you may
    be able to obtain it by collecting the device and physically downloading it. It
    may be helpful to compress logs for storage on-device, or to make transmission
    easier.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法上传任何数据，您始终可以在设备上记录日志：通过收集设备并物理下载可能会获得它。压缩日志以便在设备上存储或使传输更容易可能会有所帮助。
- en: Outcomes
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: Most edge AI systems have goals that go beyond what happens on the device itself.
    For instance, a product may be designed to reduce the cost of an industrial process,
    encourage a user to stay fit, or improve the quality of an agricultural product.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数边缘AI系统的目标超出了设备本身的发生。例如，产品可能设计用于降低工业流程的成本，鼓励用户保持健康，或者提高农产品的质量。
- en: With this in mind, it’s essential to track the outcomes of whatever processes
    your system interacts with. This will help you understand whether your project
    is having a beneficial effect.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，跟踪系统与之交互的任何过程的结果是至关重要的。这将帮助您了解您的项目是否产生了有益的效果。
- en: 'Measuring and interpreting the impact on outcomes requires deep domain expertise.
    The process needs to start before the system has been deployed: you’ll need to
    measure the current outcomes of the system so that you have something to compare
    it to. This should already be part of the initial stages of your project.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 测量和解释结果对结果的影响需要深入的领域专业知识。该过程需要在系统部署之前开始：您需要测量系统当前的结果，以便有比较的对象。这应该已经是项目初始阶段的一部分。
- en: 'You can also monitor outcomes as part of a staged deployment. If you deploy
    in some places and not others, you’ll hopefully be able to measure the difference
    in results: the places where deployment has yet to happen will act as a control.
    That said, you should make sure that you account for any other factors that may
    cause differences between different locations.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 作为分阶段部署的一部分，您还可以监控结果。如果您在某些地方部署而在其他地方不部署，您希望能够测量结果的差异：还没有进行部署的地方将充当对照组。不过，您应确保考虑到可能导致不同位置之间差异的任何其他因素。
- en: The nice thing about outcomes is that you can measure them without needing any
    access to devices once they have been deployed. The downside is that there’s typically
    a delay between deployment and results, which can make for a less effective feedback
    loop. It’s also harder to account for the impact of external factors.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的好处在于，一旦部署后，您无需访问设备即可进行测量。不利之处在于，部署与结果之间通常存在延迟，这可能导致反馈循环效果较差。同时，更难考虑外部因素的影响。
- en: User reports
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户报告
- en: If users interact with your product, or the systems it impacts, you can potentially
    survey them for feedback. This can be a great source of feedback, since users
    are the first people who will notice any benefits or issues.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户与您的产品互动，或者它所影响的系统，您可以潜在地对他们进行调查以获取反馈。这可以是一个很好的反馈来源，因为用户通常是第一批注意到任何好处或问题的人。
- en: It’s important to collect user feedback in a structured way, and to acknowledge
    that there are many factors that can lead individuals to come to different conclusions
    about the same situation. As such, aggregate feedback from many individuals is
    likely to be more reliable and actionable than feedback from just a few. If you
    don’t have experience collecting user feedback, it’s a good idea to work with
    a domain expert who does.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是以结构化的方式收集用户反馈，并认识到有许多因素可能导致个人对同一情况得出不同结论。因此，来自许多人的汇总反馈可能比来自少数人的反馈更可靠且更具操作性。如果您没有收集用户反馈的经验，与具有该领域专业知识的专家合作是一个好主意。
- en: 'It’s worth noting that users are not always honest. Employees may feel uncomfortable
    providing negative feedback on a major project, or they may find themselves in
    a position where they have an incentive to resist the deployment: for example,
    if they feel like the project is impacting their job in an undesirable way. These
    are completely valid and understandable reasons, and it’s important to be sensitive
    to them.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，用户并不总是诚实的。员工可能会对重要项目提供负面反馈感到不适，或者他们可能会发现自己处于一种抵制部署的动机下：例如，如果他们觉得项目对他们的工作产生了不良影响。这些都是完全合理和可以理解的原因，因此敏感地对待这些情况至关重要。
- en: Improving a Live Application
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进实时应用
- en: The iterative development process doesn’t stop when you deploy, but it certainly
    changes. Once you have devices running in production, you lose some flexibility
    in making modifications. Depending on your project, there may be technical constraints
    that prevent you from updating your application once it has been deployed. And
    even with the ability to make changes, you may need to be conservative to avoid
    disrupting the user experience.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代开发过程在部署后并未结束，但肯定会发生变化。一旦您的设备投入生产使用，您在进行修改时将会失去一些灵活性。根据您的项目，可能会有技术约束阻止您在应用程序部署后更新。即使具备进行更改的能力，您可能也需要保守行事，以避免破坏用户体验。
- en: Solving problems using feedback
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用反馈解决问题
- en: 'The types of feedback collected during monitoring (see [“Postdeployment Monitoring”](#post_deployment_monitoring))
    can be put to good use in identifying and solving problems. There are multiple
    types of feedback, and they each focus on different aspects of the solution:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在监控期间收集的反馈类型（参见[“部署后监控”](#post_deployment_monitoring)）可以很好地用于识别和解决问题。反馈有多种类型，每种类型都专注于解决方案的不同方面：
- en: Data samples give us insight into the evolving state of real-world data.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据样本为我们提供了解实时数据演变状态的视角。
- en: Distribution changes also provide insight into real-world data, and they can
    also help us identify issues within our algorithmic pipeline (via monitoring output
    distribution).
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布变化还可以提供关于实际数据的洞察，并且它们还可以帮助我们识别算法流水线内部的问题（通过监控输出分布）。
- en: Application metrics give us a way to understand the high-level operation of
    our system at a technical level.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序指标为我们提供了在技术层面上理解系统高级运行情况的方式。
- en: Outcomes help us understand how the system is behaving holistically—and whether
    it is solving the problems it is intended to.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果帮助我们全面了解系统的行为方式——以及它是否在解决它旨在解决的问题。
- en: User reports provide further evidence of the overall health and utility of our
    product.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户报告进一步证明了我们产品的整体健康和实用性。
- en: By collecting feedback across all of these axes, you should be able to home
    in on the cause of any issues. For example, your outcomes data may indicate that
    the system is not making a positive impact on the problem it is trying to solve.
    To investigate, you might take a look at the change in input and output distributions.
    If the input distribution is the same as in your dataset but the output distribution
    is different from what you observed during development, there may be a problem
    with your algorithm’s implementation on the device.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 通过收集跨所有这些轴线的反馈，你应该能够追踪到任何问题的原因。例如，你的结果数据可能表明系统在试图解决的问题上没有产生积极影响。为了调查，你可以查看输入和输出分布的变化。如果输入分布与你的数据集中相同，但输出分布与开发过程中观察到的不同，可能是你的算法在设备上的实施存在问题。
- en: It’s important to observe changes in the aspects you are monitoring over time.
    You might find that there are cyclic changes in input distribution, due to seasonality
    (see [“Representation and Time”](ch07.html#representation_and_time)), which need
    to be factored into your application.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 观察你正在监测的方面随时间的变化非常重要。你可能会发现，由于季节性（见[“表达和时间”](ch07.html#representation_and_time)），输入分布存在周期性变化，这需要考虑到你的应用程序中。
- en: Refining an algorithm over time
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随着时间的推移优化算法
- en: All environments experience drift, and you’ll almost certainly have to improve
    your system over time in order to keep up. In addition, since the field of edge
    AI is still rapidly evolving, it’s very likely that new algorithmic approaches
    may become available over the course of your deployment.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 所有环境都会发生漂移，你几乎肯定需要随着时间的推移来改进你的系统以跟上。此外，由于边缘AI领域仍在快速发展，新的算法方法可能会在你的部署过程中变得可用。
- en: The task of improving your algorithms is just an extension of the workflow you’re
    familiar with from development. It’s an iterative process, driven by data. Hopefully,
    by deploying to the field you’ve developed a better understanding of the conditions
    that exist in the real world. For example, monitoring differences in model output
    distribution may have alerted you to the fact that a different class balance exists
    in the field than in your dataset.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 改进你的算法任务只是你熟悉的开发工作流程的延伸。这是一个由数据驱动的迭代过程。希望通过部署到现场，你已经对真实世界中存在的条件有了更好的理解。例如，监测模型输出分布的差异可能提醒你，在现场存在与你的数据集不同的类平衡。
- en: Even if you’ve gained no such information, your predeployment evaluation has
    hopefully informed you of the weak spots in your system’s performance. For example,
    perhaps your application is underperforming for some subgroups of the overall
    population.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你没有获得这样的信息，你的预部署评估也有望告诉你系统性能的薄弱点。例如，也许你的应用程序在整体人群的某些子群体中表现不佳。
- en: 'You can use this information to improve your dataset. If you’re lucky, you
    may be able to obtain data directly from the field—although this may be restricted
    by technical or legal obstacles.^([9](ch10.html#idm45988812320848)) At the very
    least, you hopefully have some awareness into the parts that need improving: maybe
    you could benefit from better diversity, or by increasing the number of examples
    of a particular class.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用这些信息来改善你的数据集。如果幸运的话，你可能能够直接从现场获取数据——尽管这可能受到技术或法律障碍的限制。^([9](ch10.html#idm45988812320848))
    至少，你希望能够意识到需要改进的部分：也许你可以从更好的多样性中获益，或者通过增加特定类别的示例数量来改进。
- en: The same applies to algorithms. If you think another algorithm might work better,
    you can explore its potential in much the same way you would in the initial development
    process. The difference is that you now have a live production system to compare
    against. You might even choose to deploy two different versions of algorithms
    on different devices in order to collect data on which seems to perform better.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于算法。如果你认为另一个算法可能效果更好，你可以像在初始开发过程中一样探索它的潜力。不同之处在于，你现在有一个实时的生产系统可以进行比较。你甚至可以选择在不同设备上部署两个不同版本的算法，以收集关于哪个算法表现更好的数据。
- en: Once you have an improved algorithm or application, you’ll need to deploy it.
    As with most things in edge AI, this isn’t always as simple as it sounds.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您拥有了改进的算法或应用，您就需要部署它。就像边缘人工智能中的大多数事物一样，这并不总是听起来那么简单。
- en: Supporting multiple deployed algorithms
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持多个部署的算法
- en: Deploying server-side code can be as simple as pressing a button, with the latest
    version being immediately available to all users. Edge deployments are—unfortunately—a
    lot more complicated.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 部署服务器端代码可能只需按下一个按钮，最新版本即可立即供所有用户使用。不幸的是，边缘部署要复杂得多。
- en: 'AI is often deployed to the edge as a way to work around challenges with connectivity
    and bandwidth. These challenges can make deployment tricky. In a multi-device
    deployment, it’s not necessarily possible to push the latest version of your application
    down to every edge device at the same time. Even if you have enough bandwidth,
    some devices may be unavailable: powered down or offline. And in some cases, by
    design or by accident, there’s simply no way to update a device once it has been
    placed in the field.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能通常被部署到边缘以解决连接性和带宽的挑战。这些挑战可能使部署变得棘手。在多设备部署中，可能不可能同时将应用程序的最新版本推送到每个边缘设备。即使有足够的带宽，某些设备可能不可用：已关机或离线。在某些情况下，出于设计或意外原因，没有办法更新已经部署在现场的设备。
- en: The situation is amplified by the way that edge AI applications are developed
    and deployed. A staged deployment within an iterative workflow will naturally
    result in many different combinations of hardware and software out in the field,
    and even after the initial rollout, new devices being placed in the field will
    likely feature newer versions of hardware and software than what is already there.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘人工智能应用程序的开发和部署方式加剧了情况。在迭代工作流程中的分阶段部署自然会导致在现场出现许多不同的硬件和软件组合，甚至在初始推出后，新设备进入现场时的硬件和软件版本可能比已有的更新。
- en: 'This means that at some point you are likely to end up with a range of application
    versions in production at the same time. In fact, there are several entities that
    may have different versions:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在某个时刻，您可能会在生产中拥有一系列应用程序版本。事实上，可能会有几个实体具有不同的版本：
- en: The device hardware itself
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备硬件本身
- en: The application firmware running on a device
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备上运行的应用固件
- en: The algorithm implementations or models within the firmware
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固件内的算法实现或模型
- en: The datasets used to train any machine learning models
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于训练任何机器学习模型的数据集
- en: Any backend web services that the device connects to
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备连接到的任何后端Web服务
- en: Since it’s unlikely you can update all of these at the same time, there’s a
    huge number of potential different combinations of artifacts that may be deployed
    in the field at any given moment. Keeping track of them is extremely important.
    If you don’t have a good record of what is deployed where, you’ll lose the ability
    to debug your system. If every device has a different mixture of components and
    you aren’t sure what they are, it’s very hard to figure out the root cause of
    a performance problem.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不太可能同时更新所有这些内容，因此在任何给定时刻可能在现场部署的工件组合数量巨大。跟踪它们非常重要。如果不清楚在哪里部署了什么，您将失去调试系统的能力。如果每个设备都具有不同的组件混合，而您不确定它们是什么，要找出性能问题的根本原因就非常困难。
- en: To permit debugging and traceability, you’ll need a system for tracking which
    versions of each component are deployed in a given place. For example, you might
    maintain a database that is kept up to date every time you update firmware or
    create a new hardware iteration. This functionality can be provided by IoT device
    management software.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行调试和追溯，您需要一个系统来跟踪每个组件在特定位置部署的版本。例如，您可以维护一个数据库，每次更新固件或创建新的硬件迭代时都保持最新。这种功能可以由物联网设备管理软件提供。
- en: When monitoring metrics, you’ll need to associate them with the records in your
    device management platform so that you can understand which components might be
    in need of attention.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在监控指标时，您需要将它们与设备管理平台中的记录关联起来，以便了解哪些组件可能需要关注。
- en: Managing many different versions concurrently can be a nightmare, so it’s in
    your interest to try to limit the combinations currently in use. If your devices
    connect to a backend, one way to enforce relative uniformity is to require a minimum
    firmware version. The drawback is that this may impact the robustness and usability
    of your system.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 同时管理多个不同版本可能是一场噩梦，因此，您有兴趣尝试限制当前使用的组合。如果您的设备连接到后端，强制实施相对统一的一种方法是要求最低固件版本。缺点是这可能会影响系统的稳健性和可用性。
- en: Ethics and Long-Term Support
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 道德与长期支持
- en: The world and our applications are continually evolving, so it’s important to
    continue to analyze our systems from an ethical perspective as long as they are
    still in use.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 世界和我们的应用程序不断发展，因此，长时间以来从道德角度分析我们的系统至关重要。
- en: Here are some of the ethical issues that can affect a deployment in the long
    term.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以长期影响部署的一些道德问题。
- en: Performance degradation
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能下降
- en: This chapter has introduced some techniques for monitoring and improving performance
    over time, which will naturally degrade as drift occurs. Unfortunately, the reality
    is that most deployments will have a finite useful life. At some point, either
    the drift will be too much to overcome, or the budget will not allow for the necessary
    maintenance.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些技术，用于随着时间的推移监控和改善性能，这些技术在漂移发生时自然会下降。不幸的是，现实是大多数部署都有有限的有用生命。在某一时刻，要么漂移过大无法克服，要么预算不允许必要的维护。
- en: For example, imagine a system designed to identify manufacturing defects. Over
    time, changes to the manufacturing process may produce different types of defects.
    If the system is not updated, the new defects won’t be caught—potentially resulting
    in safety hazards.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个旨在识别制造缺陷的系统。随着时间的推移，制造过程的变化可能会产生不同类型的缺陷。如果系统没有更新，新缺陷就不会被发现——可能导致安全隐患。
- en: A machine learning model doesn’t necessarily know when it is being fed inputs
    that it wasn’t trained to handle. Instead, it’ll continue to produce an output—which
    may be completely wrong. If someone is depending on your application to do the
    right thing, this can be disastrous. If you are no longer supporting the hardware,
    there may be no way for anybody to know that there is a problem—beyond the fact
    that some harm is being caused.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型并不一定知道是否输入了它未经过训练的处理输入。相反，它将继续产生可能完全错误的输出。如果有人依赖您的应用程序执行正确的操作，这可能是灾难性的。如果不再支持硬件，可能没有办法知道存在问题——除了造成一些伤害的事实。
- en: 'This raises the question: what happens to projects that have exceeded their
    useful lifespan? The truth is that it isn’t ethically acceptable to just abandon
    a project. Instead, you need to plan for what will happen in the event that it
    becomes unworkable. A responsible design covers the entire life cycle of your
    project, from cradle to grave.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个问题：那些已超过其有用寿命的项目会怎么样？事实是，仅仅放弃一个项目在伦理上是不可接受的。相反，您需要计划在项目变得不可行时将会发生什么。一个负责任的设计涵盖了项目的整个生命周期，从摇篮到坟墓。
- en: For edge AI projects, this includes the hardware component. For example, you
    may need to have a plan to deal with harmful materials contained within hardware
    devices, such as lithium batteries. Is your hardware sustainable, or will it create
    problems of its own?
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 对于边缘AI项目，这包括硬件组件。例如，您可能需要计划处理硬件设备中包含的有害材料，如锂电池。您的硬件可持续吗，还是会带来自身的问题？
- en: New information
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新信息
- en: 'After deployment, new facts may come to light that may result in an ethical
    re-evaluation of a project. Here are some examples:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后，可能会出现新的事实，这可能导致对项目进行道德重新评估。以下是一些例子：
- en: The discovery of algorithmic limitations that could be detrimental to fairness
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现可能对公平性有害的算法限制
- en: The discovery of security vulnerabilities that could be exploited
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现可能被利用的安全漏洞
- en: Improvements in the understanding of the problem that expose flaws in an application
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对问题理解的改进揭示了应用程序中的缺陷
- en: Improvements in edge AI techniques that make the current application obsolete
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘AI技术的改进使得当前应用过时
- en: Changes in the problem domain that make the current application obsolete
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题领域的变化使当前应用程序过时
- en: Artificial intelligence is a rapidly moving field, and it’s common for issues
    to be discovered with existing algorithms and techniques. For example, [adversarial
    attacks](https://oreil.ly/U4rq5) make it possible for attackers to manipulate
    machine learning models by feeding them carefully constructed inputs in order
    to obtain the output they desire. New adversarial attacks are often discovered,
    and there’s a minor arms race as defenses are invented and defeated.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能是一个快速发展的领域，发现现有算法和技术存在问题是很常见的。例如，[对抗攻击](https://oreil.ly/U4rq5)使攻击者能够通过精心构造的输入来操纵机器学习模型，以获得他们期望的输出。通常会发现新的对抗攻击，并且在防御措施被发明和打败之间存在一场小规模的武器竞赛。
- en: It’s also common to discover flaws in AI techniques that may lead to compromised
    performance. For example, [“What Do Compressed Deep Neural Networks Forget?”](https://oreil.ly/QlZng)
    (Hooker et al., 2021) showed how popular model compression techniques can lead
    to a loss of performance for minority classes. As we learn more about the limitations
    of our techniques, we may find that our currently deployed systems have flaws
    that make them unsuitable for continued use.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 还经常发现AI技术中的缺陷，可能导致性能受损。例如，《“压缩深度神经网络会忘记什么？”》（Hooker等人，2021）展示了流行的模型压缩技术如何导致少数类性能损失。随着我们对技术局限性的了解加深，我们可能会发现我们当前部署的系统存在缺陷，使其不适合继续使用。
- en: Sometimes, a new discovery will make an existing technique obsolete. In some
    contexts, continuing to use the old technique might be considered unethical. For
    example, imagine you have a medical diagnosis product that is able to detect a
    fatal illness with a false negative rate of 20%. If a competing team creates a
    system with a false negative rate of 10%, anyone using your system instead of
    theirs may have an increased risk of death since their illness is less likely
    to be caught. You may have to consider whether it is ethical to continue marketing
    your product.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，新的发现会使现有技术过时。在某些情境下，继续使用旧技术可能被视为不道德。例如，假设您有一种医学诊断产品，能以20%的假阴性率检测出致命疾病。如果竞争团队创建了一个假阴性率为10%的系统，那些使用您的系统而不是他们的系统的人可能面临更高的死亡风险，因为他们的疾病更不容易被检测到。您可能需要考虑是否继续推广您的产品是否符合伦理。
- en: In some cases, new domain expertise may come to light that shows a system is
    not fit for purpose. For example, an improved understanding of human physiology
    might show that a previously adequate fitness wearable is in fact delivering bad
    advice to athletes.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，新的领域专业知识可能会显露出系统不适用的情况。例如，对人体生理学有更深入的理解可能表明先前足够的健身可穿戴设备实际上给运动员提供了错误的建议。
- en: Evolving cultural norms
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文化规范的演变
- en: Society changes quickly, and you may find that a previously deployed application
    gradually moves outside of the standards of acceptability. For example, the expectations
    of consumers around privacy is changing over time. Today, consumers are accepting
    of smart speakers that send recorded conversational audio into the cloud for processing—since
    historically there’s been no other way to perform accurate speech recognition.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 社会变化迅速，您可能会发现先前部署的应用程序逐渐超出了可接受的标准。例如，消费者对隐私的期望随时间而变化。今天，消费者接受智能扬声器将录音的对话音频发送到云端进行处理，因为历史上没有其他方法能进行准确的语音识别。
- en: However, as on-device transcription becomes more widespread, it’s likely that
    consumers will come to expect it, and will consider the use of server-side transcription
    an outmoded concept that violates their expectation of privacy.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着设备上的转录变得更加普及，消费者可能会逐渐期待这种方式，并认为服务器端转录是一种过时的概念，违反了他们对隐私保护的期望。
- en: 'It’s worth noting that this phenomenon may also happen the other way around:
    previously unacceptable concepts, like smart cameras in private areas of the home,
    may become tolerated as we move toward systems where the image data never leaves
    the device.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这种现象也可能反向发生：先前不可接受的概念，如家庭私人区域内的智能摄像头，随着我们向图像数据永不离开设备的系统迈进，可能会变得被容忍。
- en: As the custodian of a project, you should work with domain experts to keep track
    of cultural norms and make sure that your application does not violate them.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 作为项目的管理者，您应该与领域专家合作，了解文化规范并确保您的应用程序不会违反这些规范。
- en: Changing legal standards
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 法律标准的变化
- en: Legal standards tend to follow in step with cultural norms. For example, as
    privacy expectations have evolved on the web, laws like the European Union’s [General
    Data Protection Regulation](https://oreil.ly/EBy2O) have been drawn up to regulate
    the way that companies handle private information.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 法律标准往往与文化规范同步。例如，随着网络隐私期望的发展，像欧盟的《通用数据保护条例》（[来源](https://oreil.ly/EBy2O)）等法律被制定出来，以规范公司处理私人信息的方式。
- en: Whatever area you are operating in, you should work with domain experts to understand
    your legal obligations and ensure that you are handling them ethically.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你所处的领域是什么，都应该与领域专家合作，了解你的法律义务，并确保你在处理时符合道德标准。
- en: Warning
  id: totrans-394
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Bear in mind that law and ethics are not necessarily the same thing. In some
    situations, you may be legally required to do things that are not compatible with
    your ethical standards. For example, some companies have been [pressured by governments](https://oreil.ly/dIEyE)
    to hand over the keys to encrypted user data. Bear this in mind when designing
    your application.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，法律和道德并不一定相同。在某些情况下，你可能在法律上被要求做与你的道德标准不兼容的事情。例如，一些公司受到政府的压力，要求交出加密用户数据的密钥（[来源](https://oreil.ly/dIEyE)）。设计应用程序时请牢记这一点。
- en: What Comes Next
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: What Comes Next
- en: Our discussion of long-term support concludes the final theory section of this
    book. Congratulations on making it this far!
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于长期支持的讨论结束了本书的最后理论部分。恭喜你走到了这一步！
- en: In the next three chapters, we’ll see everything we’ve learned in action. Each
    chapter provides an end-to-end application of the edge AI workflow to a practical
    use case, starting with an idea and ending with a product.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三章中，我们将看到我们学到的一切实际应用。每一章都提供了边缘AI工作流程在实际用例中的端到端应用，从一个想法开始，到最终产品。
- en: We hope these chapters are both informative and inspirational. By the end of
    the book, you’ll be ready to apply these principles on your own.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这些章节既具有信息性又富有启发性。通过本书的学习，你将准备好在实践中应用这些原则。
- en: ^([1](ch10.html#idm45988812876272-marker)) If you can get away with deploying
    to a development board before your official hardware is ready, you should go with
    it.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.html#idm45988812876272-marker)) 如果你可以在官方硬件准备好之前先部署到开发板，你应该这么做。
- en: ^([2](ch10.html#idm45988812780896-marker)) Google’s Machine Learning Crash Course
    has [a great explanation of precision and recall](https://oreil.ly/LLXBl).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.html#idm45988812780896-marker)) 谷歌的机器学习入门课程中对精确率和召回率有很好的解释（[来源](https://oreil.ly/LLXBl)）。
- en: ^([3](ch10.html#idm45988812732656-marker)) The word *positive* is often replaced
    with *acceptance*, and the word *negative* with *rejection*.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch10.html#idm45988812732656-marker)) *正面*一词通常用*接受*替代，*负面*则用*拒绝*替代。
- en: ^([4](ch10.html#idm45988812680608-marker)) An AUC of 0 means the model is—weirdly—getting
    every single prediction wrong, which for a binary classifier means you could just
    flip the predictions to get perfect performance. If this happens, it’s usually
    a sign that you have gotten your labels mixed up somewhere!
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch10.html#idm45988812680608-marker)) AUC为0意味着模型每次预测都是错误的，这对于二元分类器来说意味着你可以简单地翻转预测来获得完美的性能。如果这种情况发生，通常意味着你在某个地方搞错了标签！
- en: ^([5](ch10.html#idm45988812631232-marker)) There’s a good explanation of mAP
    in the article [“mAP (mean Average Precision) Might Confuse You!”](https://oreil.ly/aJ3Dy)
    by Shivy Yohanandan.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch10.html#idm45988812631232-marker)) 文章“mAP (mean Average Precision) Might
    Confuse You!”中对mAP有很好的解释（[来源](https://oreil.ly/aJ3Dy)），作者是Shivy Yohanandan。
- en: '^([6](ch10.html#idm45988812608960-marker)) There are actually three uses of
    RAM: data (or global), stack, and heap. Data RAM usage is set at compile time,
    while stack and heap usage can change while a program runs. Some embedded programs
    intentionally only use data, to avoid any surprises. Stack and heap both require
    separate high watermark tests.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch10.html#idm45988812608960-marker)) 实际上有三种RAM的用途：数据RAM（或全局RAM）、堆栈RAM和堆RAM。数据RAM的使用在编译时确定，而堆栈和堆的使用在程序运行时可以改变。一些嵌入式程序故意只使用数据RAM，以避免任何意外。堆栈和堆都需要单独的高水位测试。
- en: ^([7](ch10.html#idm45988812592912-marker)) This is used by Edge Impulse to provide
    latency estimates during model development.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch10.html#idm45988812592912-marker)) Edge Impulse使用这种方法在模型开发期间提供延迟估算。
- en: ^([8](ch10.html#idm45988812384736-marker)) These are just a few summary statistics;
    there are many more choose from.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch10.html#idm45988812384736-marker)) 这些只是一些摘要统计数据；还有更多选择。
- en: ^([9](ch10.html#idm45988812320848-marker)) If you anticipate wanting to collect
    data from the field, it needs to be part of the terms of service of your product,
    and you must verify that a customer has agreed to it.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch10.html#idm45988812320848-marker)) 如果你预期希望从现场收集数据，这需要成为你产品服务条款的一部分，并且你必须验证客户已同意此条款。
