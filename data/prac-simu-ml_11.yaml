- en: Chapter 9\. Cooperative Learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章\. 合作学习
- en: In this chapter, we’re going to take another step forward with our simulations
    and reinforcement learning, and create a simulation environment in which multiple
    agents must work together toward a common goal. These sorts of simulations involve
    *cooperative learning*, and agents will usually receive their rewards as a group,
    instead of individually—including agents that might not have contributed to the
    actions that resulted in the rewards.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步推进我们的仿真和强化学习，创建一个仿真环境，其中多个代理必须共同努力实现共同的目标。这些类型的仿真涉及*合作学习*，代理通常会作为一个组接收奖励，而不是个别地—包括可能没有为导致奖励的行动做出贡献的代理。
- en: In Unity ML-Agents, the preferred training algorithm and approach for cooperative
    learning is known as Multi-Agent POsthumous Credit Assignment (or MA-POCA, for
    short). MA-POCA involves the training of a centralized *critic* or *coach* for
    a group of agents. The MA-POCA approach means agents can still learn what they
    need to do, even though the group is the entity being rewarded.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity ML-Agents中，用于合作学习的首选训练算法和方法称为多代理后期信用分配（或简称MA-POCA）。MA-POCA涉及对一组代理进行集中的*评论*或*指导*训练。MA-POCA方法意味着代理仍然可以学习他们需要做什么，即使奖励是给整个组的。
- en: Tip
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In cooperative learning environments, you can still give rewards to individual
    agents if you want. We’ll briefly touch on this later. You can also use other
    algorithms, or just PPO like usual, but MA-POCA has specialized features to make
    cooperative learning better. You could *wire together* a collection of PPO-trained
    agents to get a similar result. We don’t recommend it, though.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在合作学习环境中，如果你愿意，仍然可以给个体代理人奖励。我们稍后会简要涉及这一点。你也可以使用其他算法，或者像通常一样使用PPO，但是MA-POCA具有特殊的功能，可以使合作学习更好。你可以*将一组经过PPO训练的代理人联合在一起*以获得类似的结果。不过我们不建议这样做。
- en: A Simulation for Cooperation
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合作模拟
- en: Let’s build a simulation environment with a collection of agents that need to
    work together. This environment has a lot of pieces, so take your time, step through
    slowly, and take notes if you need to.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们建立一个仿真环境，其中包含需要共同工作的一组代理人。这个环境有很多部分，所以请慢慢来，逐步进行，并在需要时做笔记。
- en: Our environment will involve three identical agents, and two of three different
    sizes of cube (totaling six cubes). The agents will need to work together to move
    the goals efficiently into a goal area, particularly the larger cubes, which will
    require the pushing force of more than one agent.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的环境将涉及三个相同大小的代理人，以及三种不同大小的方块（总共六个）。代理人需要共同努力将目标有效地移动到目标区域，特别是大的方块，它们需要多个代理的推力。
- en: Building the Environment in Unity
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Unity中构建环境
- en: Create a new Unity project, add the Unity ML-Agents package, and open a new
    scene in the editor. Our project is called “Coop.”
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Unity项目，添加Unity ML-Agents包，并在编辑器中打开一个新场景。我们的项目名为“Coop”。
- en: 'With the project read, the first thing we need to do is make the physical elements
    of our cooperative learning simulation, so we need:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读项目后，我们需要做的第一件事是创建合作学习仿真的物理元素，所以我们需要：
- en: A floor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个地板
- en: Some walls
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些墙壁
- en: A goal area
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个目标区域
- en: Some blocks, of differing sizes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些不同大小的方块
- en: The agents
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理人
- en: Let’s do that now.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来做这件事。
- en: Assembling the floor and walls
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组装地板和墙壁
- en: 'Our walls and floor will be scaled cubes, as usual. In your scene, in the Unity
    Editor do the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 和通常一样，我们的墙壁和地板将是缩放后的立方体。在Unity编辑器中，执行以下操作：
- en: Create a cube in the Hierarchy, name it “Floor,” and scale it to `(25, 0.35,
    25)`, so it’s a big square shape.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Hierarchy中创建一个立方体，命名为“Floor”，并将其缩放为 `(25, 0.35, 25)`，使其成为一个大的正方形。
- en: Create a new material in the Project pane, assign a color (ours is light brown),
    and assign this material to the floor.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中创建一个新的材质，指定一种颜色（我们的是浅棕色），并将该材质分配给地板。
- en: Create four cubes in the Hierarchy, name them name them “Wall1,” “Wall2,” “Wall3,”
    and “Wall4,” and scale them to `(25, 1, 0.25)`, so they’re long enough to run
    the length of each side of the floor.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Hierarchy中创建四个立方体，分别命名为“Wall1,” “Wall2,” “Wall3,” 和 “Wall4,” 并将它们缩放到 `(25,
    1, 0.25)`，以便足够长，覆盖每一侧的地板。
- en: Rotate and position walls to be on either side of the floor, as shown in [Figure 9-1](#fig:Coop-walls.png).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将墙壁旋转并定位到地板的两侧，如[图 9-1](#fig:Coop-walls.png)所示。
- en: '![psml 0901](assets/psml_0901.png)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0901](assets/psml_0901.png)'
- en: Figure 9-1\. The walls positioned on the floor
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. 地板上的墙壁位置
- en: Create a new material in the Project pane, assign a color (ours is light blue),
    and assign this material to all four wall objects.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中创建一个新材质，并分配一个颜色（我们使用的是浅蓝色）。将此材质分配给所有四个墙体对象。
- en: Create an empty `GameObject` in the Hierarchy, name it “Walls,” or something
    similar, and drag the four wall objects under it, as children.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中创建一个空的`GameObject`，命名为“墙壁”或类似名称，并将四个墙体对象作为子对象拖动到其中。
- en: Your world should look like [Figure 9-1](#fig:Coop-walls.png) at this point.
    You’re ready to continue after you save the scene.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此时你的世界应该看起来像[图 9-1](#fig:Coop-walls.png)。保存场景后，你可以继续操作。
- en: Adding the goal
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加目标
- en: 'Next we need a goal area. The goal area, as we saw earlier, will be a section
    of the floor where the agents must push the blocks. It will be brightly colored
    so that we as humans can tell where it is when we’re looking at it in Unity, and
    it will have a large Box Collider volume for the agents:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要一个目标区域。正如我们之前看到的，目标区域将是地板的一部分，代理器必须把块推到其中。它将被明亮地着色，以便我们作为人类在Unity中查看时能够看到它，并且将具有一个大的Box
    Collider体积用于代理器：
- en: Create a new plane in the Hierarchy, name it “Goal,” and scale it to `(0.5,
    1.16, 2.5)`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中创建一个新平面，命名为“目标”，并将其缩放到`(0.5, 1.16, 2.5)`。
- en: Create a new material in the Project pane, and assign a bright, distracting
    color (ours is red). Assign this material to the goal.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中创建一个新材质，并分配一个鲜明而分散注意力的颜色（我们使用的是红色）。将此材质分配给目标。
- en: Note
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Just a reminder that the agent in this case, doesn’t have any sensors that might
    reveal the color of the goal to it. It learns where the goal is based on the information
    it gets from sensors, which will be covered shortly. It does not see the color.
    The color is for the humans watching.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提醒一下，在这种情况下，代理器没有任何传感器可以告诉它目标的颜色。它根据传感器获得的信息来学习目标的位置，这部分内容将很快涵盖。它看不到颜色。颜色是给人类观察用的。
- en: Position the goal on the floor, against one edge of it, as shown in [Figure 9-2](#fig:goal).
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标放置在地板上的一侧，如[图 9-2](#fig:goal)所示。
- en: '![psml 0415](assets/psml_0415.png)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0415](assets/psml_0415.png)'
- en: Figure 9-2\. The goal area
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-2\. 目标区域
- en: In the goal’s Inspector, click on the Edit Collider button and resize the goal’s
    box collider so that it encompasses a large volume, as shown in [Figure 9-3](#fig:Coop-collider).
    This will be used to detect when the agent manages to push one of the blocks into
    the goal area.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标的检视器中，点击“编辑碰撞体”按钮，并调整目标的盒碰撞体，使其覆盖一个大的体积，如[图 9-3](#fig:Coop-collider)所示。这将用于检测当代理器成功将一块块推入目标区域时。
- en: '![psml 0414](assets/psml_0414.png)'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0414](assets/psml_0414.png)'
- en: Figure 9-3\. The goal’s collider
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-3\. 目标的碰撞体
- en: Likewise, in the goal’s Inspector, tick the Is Trigger button. We don’t want
    the agent or the blocks to actually collide with the goal’s volume, we just want
    to know they’re in the goal’s volume.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在目标的检视器中，勾选“是触发器”按钮。我们不希望代理器或块实际与目标的体积碰撞，我们只想知道它们是否在目标的体积内。
- en: That’s everything for the goal area. Yours should look like [Figure 9-4](#fig:Coop-areawithgoal)
    now. Save the scene before you continue.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于目标区域的所有内容。现在你的场景应该看起来像[图 9-4](#fig:Coop-areawithgoal)。在继续之前保存场景。
- en: '![psml 0904](assets/psml_0904.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0904](assets/psml_0904.png)'
- en: Figure 9-4\. The area with the goal in place
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-4\. 带有目标的区域
- en: Blocks of differing sizes
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同尺寸的块
- en: 'Now we’re going to create some blocks for the cooperative agents to push into
    the goal. We want to have three different types of blocks, as shown in [Figure 9-5](#fig:coopagentscene):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为合作代理器创建一些块，推动到目标中。我们希望有三种不同类型的块，如[图 9-5](#fig:coopagentscene)所示：
- en: Small blocks
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小块
- en: Medium blocks
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中等大小的块
- en: Large blocks
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大块
- en: We’ll create duplicates of each one we make so that there are two of each type.
    Each type will be worth a different reward amount, which the whole group of agents
    will receive when it pushes a block into the goal.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建每种块的副本，以便有两个每种类型的块。每种类型将获得不同的奖励金额，整个代理器组在将块推入目标时将获得这些奖励。
- en: Additionally, via the physics system, some of the blocks will be heavier than
    others, which means the agents will need to work together to push them into the
    goals, and thus the group of agents will get a higher score.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，通过物理系统，一些块会比其他块更重，这意味着代理器需要共同努力将它们推入目标，从而整个代理器组将获得更高的分数。
- en: '![psml 0905](assets/psml_0905.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0905](assets/psml_0905.png)'
- en: Figure 9-5\. The three kinds of blocks
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-5\. 三种类型的块
- en: 'Follow these steps to create the blocks:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建这些块：
- en: Add a new cube to the Hierarchy, and name it “Small Block 1” or something similar.
    We will leave it at the default scale.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向层级添加一个新的立方体，并命名为“小块1”或类似的名称。我们将保持默认比例。
- en: Add a Rigidbody component to it, using the Add Component button in its Inspector.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其检查器中的Add Component按钮添加一个刚体组件。
- en: Set up the Rigidbody component as per [Figure 9-6](#fig:Coop-rigidbodyonsmallblock).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照[图9-6](#fig:Coop-rigidbodyonsmallblock)的设置设置刚体组件。
- en: '![psml 0906](assets/psml_0906.png)'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0906](assets/psml_0906.png)'
- en: Figure 9-6\. The Rigidbody component on the small block
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-6\. 小块上的刚体组件
- en: Duplicate Small Block 1, and create (and name) Small Block 2.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制小块1，创建（并命名）小块2。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You might notice that we’ve added a canvas, displaying some text, to our blocks.
    You could do this too, if you wanted. It’s not connected to the ML components,
    and is just for human visibility.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能注意到我们已经为我们的块添加了一个显示一些文本的画布。如果你想的话，你也可以这样做。这不与ML组件连接，仅供人类可见。
- en: Position them both in the scene, as shown in [Figure 9-7](#fig:Coop-smallblock2).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们都放置在场景中，如[图9-7](#fig:Coop-smallblock2)所示。
- en: '![psml 0907](assets/psml_0907.png)'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0907](assets/psml_0907.png)'
- en: Figure 9-7\. Both small blocks
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-7\. 两个小块
- en: Next, duplicate one of the small blocks, and name it “Medium Block 1.”
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，复制其中一个小块，并命名为“中等块1”。
- en: Change the scale of Medium Block 1 to `(2, 1, 2)`, so it’s a bit bigger than
    Small Block 1.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将中等块1的比例改为`(2, 1, 2)`，使其比小块1稍大。
- en: Using the Inspector, set Medium Block 1’s mass in the Rigidbody component to
    `100`, making it quite heavy.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用检查器，将中等块1的质量在Rigidbody组件中设置为`100`，使其相当重。
- en: Duplicate Medium Block 1, and create (and name) Medium Block 2.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制中等块1，并创建（并命名）中等块2。
- en: Position both of the medium blocks in the scene, as shown in [Figure 9-8](#fig:Coop-medblocks),
    alongside the small blocks.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个中等块都放置在场景中，如[图9-8](#fig:Coop-medblocks)所示，与小块一起。
- en: '![psml 0908](assets/psml_0908.png)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0908](assets/psml_0908.png)'
- en: Figure 9-8\. The medium blocks added
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-8\. 添加了中等块
- en: Finally, duplicate one of the medium blocks, and name it Large Block 1.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，复制其中一个中等块，并命名为大块1。
- en: Change the scale of Large Block 1 to `(2.5, 1, 2.5)`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将大块1的比例改为`(2.5, 1, 2.5)`。
- en: Using the Inspector, set Large Block 1’s mass in the Rigidbody component to
    `150`, so it’s really heavy.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用检查器，将大块1的质量在Rigidbody组件中设置为`150`，这样它就非常重了。
- en: As with the small and medium blocks, duplicate Large Block 1, and create and
    name Large Block 2.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与小块和中等块一样，复制大块1，创建（并命名）大块2。
- en: Position the two large blocks in the scene, as shown in [Figure 9-9](#fig:Coop-largeblocks),
    alongside all the other blocks.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中将两个大块放置如[图9-9](#fig:Coop-largeblocks)所示，与所有其他块一起。
- en: '![psml 0909](assets/psml_0909.png)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0909](assets/psml_0909.png)'
- en: Figure 9-9\. The large blocks added
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-9\. 添加了大块
- en: That’s it for the blocks for now—we’ll come back to them in a bit to add some
    code. Save the scene.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关于块的部分就到这里了，稍后我们会回来添加一些代码。保存场景。
- en: The agents
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理
- en: 'The agents are quite simple, and all their cooperative behavior comes from
    the script we’ll write shortly, rather than anything special in their editor setup:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代理非常简单，它们所有的合作行为都来自我们马上要编写的脚本，而不是编辑器设置中的任何特殊内容：
- en: Create a new cube in the Hierarchy, and rename it “Agent 1.” Leave it at the
    default scale.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级中创建一个新的立方体，并将其重命名为“代理1”。保持默认比例。
- en: Add a Rigidbody component to it, with the settings as shown in [Figure 9-10](#fig:Coop-agentrb).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其添加一个刚体组件，设置如[图9-10](#fig:Coop-agentrb)所示。
- en: '![psml 0910](assets/psml_0910.png)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0910](assets/psml_0910.png)'
- en: Figure 9-10\. The agent’s Rigidbody component
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-10\. 代理的刚体组件
- en: Duplicate it twice, and rename the two new copies Agent 2 and Agent 3.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次复制一次，并将两个新副本重命名为代理2和代理3。
- en: Create three new materials—one for each agent—of differing colors, and assign
    them to the agents.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三种新的材料——每种代理一种——颜色不同，并分配给代理。
- en: Position them similarly to ours, as shown in [Figure 9-11](#fig:Coop-theagents).
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们放置得与我们的位置相似，如[图9-11](#fig:Coop-theagents)所示。
- en: '![psml 0911](assets/psml_0911.png)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0911](assets/psml_0911.png)'
- en: Figure 9-11\. The three agents
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-11\. 三个代理
- en: That’s it for now, for the agents. We’ll be adding some code next, and after
    that we’ll need to come back to the Unity scene to implement some more things.
    Don’t forget to save the scene.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于代理就是这些了。接下来我们将添加一些代码，然后需要回到Unity场景中实现更多功能。别忘了保存场景。
- en: Coding the Agents
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写代理
- en: With the majority of the scene constructed, it’s time to write the code for
    the agent. The code for this agent is actually quite simple, since a lot of the
    logic is moved elsewhere—we’ll get to that soon.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分场景已经构建完成，现在是为代理编写代码的时候了。实际上，这个代理的代码相当简单，因为很多逻辑都已经移到别的地方了——我们很快就会讲到。
- en: 'For the agent, we’ll only need to implement the following methods:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代理，我们只需要实现以下方法：
- en: '`Initialize()`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Initialize()`'
- en: '`MoveAgent()`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MoveAgent()`'
- en: '`OnActionReceived()`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnActionReceived()`'
- en: 'Let’s get going:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Make a new C# script asset in the Project pane, and name it “Cooperative Block
    Pusher” or something similar.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中创建一个新的C#脚本资源，并命名为“合作块推动者”或类似的名称。
- en: 'Open the new script in your code editor, delete the entirety of the boilerplate,
    and add the following imports:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码编辑器中打开新脚本，删除整个样板内容，然后添加以下导入项：
- en: '[PRE0]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, implement the skeleton of the class, making sure it descends from `Agent`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现类的框架，确保它是从`Agent`继承而来：
- en: '[PRE1]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add a member variable to hold a reference to the agent’s `Rigidbody`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个成员变量来保存对代理`Rigidbody`的引用：
- en: '[PRE2]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Override the agent’s `Initialize()` function to get a handle on that `Rigidbody`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖代理的`Initialize()`函数来获取对那个`Rigidbody`的引用：
- en: '[PRE3]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, create a `MoveAgent()` method:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个`MoveAgent()`方法：
- en: '[PRE4]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method takes an array as a parameter (`act`), using the ML-Agents `ActionSegment`
    data structure. This will be called in the `OnActionReceived()` that we’ll override
    shortly, passing in the array of discrete actions to move the agent.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法接受一个数组作为参数（`act`），使用ML-Agents的`ActionSegment`数据结构。我们很快将在`OnActionReceived()`中调用它，传入离散动作的数组以移动代理。
- en: Tip
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: There will only be one specific discrete action that comes through each time,
    so we’re only ever looking at the first entry of the array. This agent will have
    seven different possible actions (doing nothing, rotating one way, rotating the
    other way, going forward, going backward, going left, and going right).
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次只会传递一个具体的离散动作，因此我们只查看数组的第一个条目。这个代理将有七种不同的可能动作（什么也不做、向一边旋转、向另一边旋转、向前、向后、向左、向右）。
- en: 'Now, inside the new method, zero some temporary variables for a direction and
    a rotation:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在新方法中，将一些临时变量（用于方向和旋转）清零：
- en: '[PRE5]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Get a handle on the first (and only) entry of the array we’re working with,
    which represents the specific action of the moment:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取我们正在处理的数组的第一个（也是唯一一个）条目的引用，它表示此刻的具体动作：
- en: '[PRE6]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, `switch` on that `action`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在这个`action`上执行`switch`：
- en: '[PRE7]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This `switch` statement sets one of the temporary variables for either rotation
    or direction, depending on which action is passed through.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`switch`语句设置了旋转或方向的一个临时变量，具体取决于传递的动作。
- en: Note
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It’s entirely arbitrary which action maps to which actual action of the agent.
    We’ve just decided that in advance, and stuck to it. The machine learning system
    learns what’s applied to what, and deals with it.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到底哪个动作对应于代理的哪个实际动作，这完全是任意的。我们只是事先决定了，并坚持这样做。机器学习系统学习如何将应用于何处，并处理它。
- en: 'Next, actually implement whatever action has been set by rotating the agent’s
    `transform`, and applying a force to the agent’s `Rigidbody`, for the rotation
    and direction, respectively:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根据设置的动作实际实现旋转代理的`transform`，并为代理的`Rigidbody`施加力，分别用于旋转和方向：
- en: '[PRE8]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That’s all for the `MoveAgent()` method, so now we turn to `OnActionReceived()`,
    where we actually call it:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`MoveAgent()`方法来说就是这些了，现在我们转向`OnActionReceived()`，在那里实际调用它：
- en: '[PRE9]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All this does is take the discrete component of the `ActionBuffers` it receives
    and pass it to the separate `MoveAgent()` method we wrote a moment ago.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将它接收到的`ActionBuffers`的离散部分取出，并传递给我们刚刚编写的单独的`MoveAgent()`方法。
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: We could have just put the code that we wrote in `MoveAgent()` in `OnActionReceived()`
    instead, but because `OnActionReceived()` is technically about handling actions
    and not specifically about movement, it’s cleaner to call our `MoveAgent()` method
    even though the only possible actions are related to movement.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本来可以直接将`MoveAgent()`中的代码放在`OnActionReceived()`中，但因为`OnActionReceived()`技术上是处理动作而不是具体的移动，所以调用我们的`MoveAgent()`方法更清晰，即使唯一可能的动作都与移动相关。
- en: That’s everything for our agent’s code. Save the script, and return to the Unity
    Editor.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代理代码就这些了。保存脚本，然后返回Unity编辑器。
- en: Coding the Environment Manager
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写环境管理器
- en: 'Now we need to make a script that will be responsible for the environment itself.
    This script will do some of the heavy lifting to allow us to have cooperative
    agents:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要制作一个脚本，该脚本将负责环境本身。这个脚本将执行一些重要的工作，以便我们可以拥有协作代理：
- en: Create a new C# script asset in the Project pane, and name it “CooperativeBlockPusherEnvironment”
    or something similar.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中创建一个新的C#脚本资源，并命名为“CooperativeBlockPusherEnvironment”或类似的名称。
- en: Open the new script and delete the boilerplate.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的脚本并删除模板内容。
- en: 'Add the following imports:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下导入项：
- en: '[PRE10]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a class for everything else to go in:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类来存储其他所有内容：
- en: '[PRE11]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This class does not need to be a child of `Agent`, and instead can just be a
    child of the default Unity `MonoBehaviour`.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个类不需要是`Agent`的子类，而是可以直接是默认的Unity `MonoBehaviour`的子类。
- en: 'Make a class to store all the agents that will be working together, as well
    as their starting positions:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类来存储所有将一起工作的代理及其起始位置：
- en: '[PRE12]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now create a similar class for the blocks that they’ll be pushing into the
    goal:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为它们将要推入目标的块创建一个类似的类：
- en: '[PRE13]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We need to create a nice `int`, to store the max steps we want the environment
    to take, so we can easily configure it from the editor:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个好的`int`，用来存储我们希望环境执行的最大步数，这样我们可以从编辑器轻松配置它：
- en: '[PRE14]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We also need to create a collection of member variables, to store handles to
    useful things like the ground, the overall area, the goal, something to check
    when we need to reset, and the count of blocks remaining undelivered to the goal:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要创建一个成员变量的集合，用于存储有用的东西的句柄，例如地面、整体区域、目标、在需要重置时检查的内容以及剩余未交付到目标的块的数量：
- en: '[PRE15]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And we need to create two lists, one of `Agents` and one of `Blocks`, using
    the classes we wrote a moment ago:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建两个列表，一个是`Agents`，另一个是`Blocks`，使用我们刚写的类：
- en: '[PRE16]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we create a `SimpleMultiAgentGroup`, which we’ll use to group the
    agents so that they can work together:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`SimpleMultiAgentGroup`，用于将代理分组，以便它们可以共同工作：
- en: '[PRE17]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: More on the `SimpleMultiAgentGroup` shortly.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 稍后会详细讨论`SimpleMultiAgentGroup`。
- en: 'Next, we need to implement a `Start()` method, which we’ll use to set everything
    up when a simulation is about to begin:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现一个`Start()`方法，用于在模拟即将开始时设置一切：
- en: '[PRE18]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside `Start()`, we’ll do all the necessary bits and pieces to make sure things
    are ready to go:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start()`方法内部，我们将执行所有必要的操作，以确保一切准备就绪：
- en: Get a handle on the ground’s bounds.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取地面边界的句柄。
- en: Iterate through the list of `Blocks` (all the blocks in the scene) and store
    their starting position and rotation and their `Rigidbody`.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代`Blocks`列表（场景中的所有块），并存储它们的起始位置、旋转和它们的`Rigidbody`。
- en: Initialize a new `SimpleMultiAgentGroup`.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化一个新的`SimpleMultiAgentGroup`。
- en: Iterate through the `Agent`s (all the agents in the scene) and store their starting
    position and rotation and their `Rigidbody`, and then call `RegisterAgent()` on
    the `SimpleMultiAgentGroup` we created, notifying it of the existence of each
    agent we want to cooperate together.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代`Agent`s列表（场景中的所有代理），并存储它们的起始位置、旋转和它们的`Rigidbody`，然后在我们创建的`SimpleMultiAgentGroup`上调用`RegisterAgent()`，通知它存在每个我们想要一起合作的代理。
- en: Call `ResetScene()`, which we’ll be writing in a moment.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`ResetScene()`，我们马上就会编写这个方法。
- en: 'Inside `Start()`, add this code to do all the aforementioned things:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start()`方法内部，添加以下代码来完成前述所有操作：
- en: '[PRE19]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we’ll implement `FixedUpdate()`, which gets called regularly by Unity:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`FixedUpdate()`方法，在Unity中会定期调用：
- en: '[PRE20]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we increment the reset timer by `1` every time, and check if the reset
    timer is greater than or equal to the maximum environment steps (and that the
    maximum environment steps is above `0`), and if so we interrupt the group of agents
    by calling `GroupEpisodeInterrupted()` on the agent group and call `ResetScene()`.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们每次增加重置计时器`1`，并检查重置计时器是否大于或等于最大环境步数（且最大环境步数大于`0`），如果是，则通过在代理组上调用`GroupEpisodeInterrupted()`中断代理组，并调用`ResetScene()`。
- en: If the maximum environment steps had not been reached, all we would have to
    do is call `AddGroupReward()` on the agent group, assigning a group penalty of
    `-0.5` divided by the maximum environment steps to penalize it for existing. This
    will, hopefully, contribute to making sure the agents do their task as quickly
    as possible.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果未达到最大环境步数，我们只需在代理组上调用`AddGroupReward()`，给予组的惩罚为`-0.5`除以最大环境步数，以惩罚它的存在。希望这样可以确保代理尽快完成任务。
- en: The `SimpleMultiAgentGroup` coordinates a collection of agents, and allows agents
    to work together to maximize a reward that is given to the whole group. The usual
    rewarding and ending of episodes takes place on the `Simple⁠M⁠u⁠l⁠t⁠i​A⁠g⁠e⁠n⁠t⁠Group`,
    instead of on individual agents.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SimpleMultiAgentGroup`协调了一组代理，并允许代理共同努力以最大化分配给整个组的奖励。通常的奖励和结束事件发生在`Simple⁠M⁠u⁠l⁠t⁠i​A⁠g⁠e⁠n⁠t⁠Group`上，而不是在单个代理上。'
- en: Note
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `SimpleMultiAgentGroup` is a feature of Unity ML-Agent’s implementation
    of MA-POCA, and thus it also only works when you’re using MA-POCA to train the
    agents.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SimpleMultiAgentGroup`是Unity ML-Agent实现的MA-POCA的一个特性，因此它只在使用MA-POCA训练代理时才起作用。'
- en: 'Now we’re going to make a rather large `GetRandomSpawnPos()` method, which
    we’ll use to randomly position the blocks and the agents in the environment, as
    needed:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个相当大的`GetRandomSpawnPos()`方法，根据需要随机放置区块和代理：
- en: '[PRE21]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we’ll make a `ResetBlock()` method, which takes a `Blocks` type (which
    we made earlier) and gives it a random spawn position (using that handy `GetRandomSpawnPos()`
    method we wrote a moment ago) and zeroes the velocity and angular velocity:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`ResetBlock()`方法，接受一个我们之前创建的`Blocks`类型，并给它一个随机的生成位置（使用我们之前编写的`GetRandomSpawnPos()`方法），将速度和角速度设为零：
- en: '[PRE22]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we need a method that can be used to log when an agent or group of agents
    has successfully delivered a block to the goal:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个方法，用于记录代理或代理组成功将区块交付到目标的时候：
- en: '[PRE23]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This might look slightly mysterious, but all that’s happening is that our `Scored()`
    method takes a `Collider`, and a `float` (representing a score), and because this
    method is only being called if a block has definitely been delivered to the goal,
    it:'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可能看起来有点神秘，但实际上我们的`Scored()`方法接受一个`Collider`和一个`float`（表示分数），因为这个方法只有在区块确实被交付到目标时才被调用，它：
- en: Decrements the count of remaining blocks by `1`
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将剩余区块的计数减少`1`
- en: Checks if there are `0` blocks left, and if so, sets a `bool` named `done` to
    `true`
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否剩余`0`个区块，如果是，则将名为`done`的布尔值设置为`true`
- en: Deactivates the game object belonging to the `Collider` that was passed in (in
    other words, it gets rid of the block that was pushed into the goal)
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停用传入的`Collider`所属的游戏对象（换句话说，消除推入目标的区块）
- en: Adds a reward to the `SimpleMultiAgentGroup`, based on the score being passed
    in
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`SimpleMultiAgentGroup`添加奖励，根据传入的分数
- en: Then checks if the `done` `bool` is `true`, and if it is, it calls `EndGroupEpisode()`
    on the `SimpleMultiAgentGroup`, and then calls `ResetScene()`
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后检查`done`的布尔值是否为`true`，如果是，则在`SimpleMultiAgentGroup`上调用`EndGroupEpisode()`，然后调用`ResetScene()`
- en: 'Next, we’ll create a quick helper method to return a random rotation:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个快速的辅助方法来返回一个随机旋转：
- en: '[PRE24]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And, for the environment script, we’ll write the oft-called `ResetScene()`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而且，对于环境脚本，我们将编写经常调用的`ResetScene()`：
- en: '[PRE25]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This function:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数：
- en: Sets the `resetTimer` back to `0`.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`resetTimer`设回`0`。
- en: Then rotates the whole area, so the goal is not always in the same side.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后旋转整个区域，这样目标不总是在同一侧。
- en: Iterates through all the `Agent`s in the `ListOfAgents`, gives them a random
    location and a random rotation using our helper methods, and zeroes their velocity
    and angular velocity.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代`ListOfAgents`中的所有`Agent`，使用我们的辅助方法给它们随机位置和随机旋转，并将它们的速度和角速度设为零。
- en: Iterates through all the `Block`s in the `ListOfBlocks`, gives them a random
    location and a random rotation using our helper methods, zeroes their velocity
    and angular velocity, and sets them to active.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代`ListOfBlocks`中的所有`Block`，使用我们的辅助方法给它们随机位置和随机旋转，将它们的速度和角速度设为零，并激活它们。
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: We set each of the blocks to active because they might be coming back from inactive
    after a reset, as the simulation may have been running, and some of the blocks
    may have been pushed into the goal (which, per the earlier code, means they get
    set to inactive).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个区块设置为活动状态，因为它们可能在重置后从非活动状态回来，因为模拟可能已经运行，并且一些区块可能已经被推入目标（根据之前的代码，这意味着它们被设置为非活动状态）。
- en: That’s it for the environment manager script. Save it and return to Unity.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 环境管理脚本到此结束。保存并返回Unity。
- en: Coding the Blocks
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码区块
- en: 'The last bit of coding we need to do is for the blocks themselves:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要完成的最后一部分编码是区块本身：
- en: Make a new C# script asset in the Project pane, and name it “GoalScore” or something
    similar.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中创建一个新的C#脚本资产，并命名为“GoalScore”或类似的名称。
- en: Open the script in your code editor and delete the boilerplate.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码编辑器中打开脚本并删除样板内容。
- en: 'Add the following imports:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下导入：
- en: '[PRE26]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Implement a class named `GoalScore`, a child of Unity’s default `MonoBehaviour`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`GoalScore`的类，它是 Unity 默认`MonoBehaviour`的子类：
- en: '[PRE27]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Inside, add some member variables to store the specific Unity tag we want to
    detect, the value of pushing the specific block this script will be attached to
    into the goal, and the block’s `Collider`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内部，添加一些成员变量以存储我们要检测的特定 Unity 标签，推送该脚本将附加到的特定块的价值，并且块的`Collider`：
- en: '[PRE28]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, implement the class `TriggerEvent`, as follows, inside the `GoalScore`
    class:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`GoalScore`类内部实现名为`TriggerEvent`的类，如下所示：
- en: '[PRE29]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This class is required to use Unity’s event system the way we’ll be using it.
    More on this in a moment.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要使用 Unity 的事件系统来使用这个类。稍后会详细介绍。
- en: 'After the `TriggerEvent` class, but still inside the `GoalScore` class, add
    the following trigger callbacks:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TriggerEvent`类之后，但仍然在`GoalScore`类内部，添加以下触发回调函数：
- en: '[PRE30]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These represent the events of something entering the collider of the object
    in question, staying in it, and exiting it.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些表示某物进入所讨论对象的碰撞体、停留在其中和退出其中的事件。
- en: 'Now, create the functions that are called for each of these:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建每个这些被调用的函数：
- en: '[PRE31]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Each of these maps to one of the trigger callbacks we created, taking a `Collider`,
    and if that `Collider` has the tag we want to look for (which is defined in one
    of the member variables we made earlier), we trigger the callback event, passing
    the `Collider` and `GoalValue` (which is one of the member variables we made a
    moment ago).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些每个都映射到我们创建的触发回调之一，接受一个`Collider`，如果该`Collider`具有我们要查找的标签（这在我们之前创建的某些成员变量中定义），则触发回调事件，传递`Collider`和`GoalValue`（这是我们刚刚创建的某个成员变量之一）。
- en: Save the script, and jump back to Unity.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，并返回 Unity。
- en: Finalizing the Environment and Agents
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成环境和代理的最后配置
- en: We’ve made three scripts, and now we need to hook them up.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了三个脚本，现在我们需要将它们连接起来。
- en: 'Start by doing the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进行以下操作：
- en: Drag the Agent script from the Project pane onto each agent in the Hierarchy
    (three agents total).
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Project 窗口中的代理脚本拖动到 Hierarchy 中的每个代理上（总共三个代理）。
- en: Drag the Environment script from the Project pane onto the environment (the
    parent object) in the Hierarchy.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Project 窗口中的环境脚本拖动到 Hierarchy 中的环境（父对象）上。
- en: And drag the GoalScore script from the Project pane onto each block in the Hierarchy
    (six blocks in total).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且从 Project 窗口中的 GoalScore 脚本拖动到 Hierarchy 中的每个块上（总共六个块）。
- en: 'Next, we need to configure everything. We’ll start with the agents. Do the
    following for each agent in the Hierarchy:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置所有内容。我们将从代理开始。对每个 Hierarchy 中的代理执行以下操作：
- en: Select the agent, and use the Inspector to add a Behavior Parameters component.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择代理，并使用 Inspector 添加一个行为参数组件。
- en: Configure the Behavior Parameters component as shown in [Figure 9-12](#fig:Coop-behaviourparameters).
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置行为参数组件如图[9-12](#fig:Coop-behaviourparameters)所示。
- en: '![psml 0912](assets/psml_0912.png)'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0912](assets/psml_0912.png)'
- en: Figure 9-12\. The configured Behavior Parameters component
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-12\. 已配置的行为参数组件
- en: Use the Inspector to add a Decision Requester component to the agent, leaving
    its settings at the defaults.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Inspector 向代理添加决策请求器组件，保留其设置为默认值。
- en: Use the Inspector to add a Rigidbody Sensor component to the Agent, taking care
    to assign the root body to be the agent’s Rigidbody component, and the virtual
    root to be the agent itself, ticking the boxes as shown in [Figure 9-13](#fig:Coop-rigidbodysensor).
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Inspector 向代理添加刚体传感器组件，确保将根体分配为代理的刚体组件，将虚拟根分配为代理本身，并按照图[9-13](#fig:Coop-rigidbodysensor)中显示的方式勾选框。
- en: '![psml 0913](assets/psml_0913.png)'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0913](assets/psml_0913.png)'
- en: Figure 9-13\. The Rigidbody Sensor component
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-13\. 刚体传感器组件
- en: Next, add an empty child object to the agent in the Hierarchy, and name it “Grid
    Sensor” or something similar.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 Hierarchy 中的代理中添加一个空的子对象，并命名为“网格传感器”或类似的名称。
- en: Select the Grid Sensor child of the agent in the Hierarchy, and use the Add
    Component button in its Inspector to add a Grid Sensor component.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 中的代理的网格传感器子对象上选择，并使用其 Inspector 中的“添加组件”按钮添加网格传感器组件。
- en: Use the Inspector to configure the Grid Sensor component as shown in [Figure 9-14](#fig:Coop-gridsensor).
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Inspector 配置网格传感器组件如图[9-14](#fig:Coop-gridsensor)所示。
- en: '![psml 0914](assets/psml_0914.png)'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0914](assets/psml_0914.png)'
- en: Figure 9-14\. The configured Grid Sensor component
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-14\. 已配置的网格传感器组件
- en: The Grid Sensor component creates a grid sensor. A grid sensor is an incredibly
    flexible sensor that creates a grid shape around an agent, and based on what kind
    of objects (defined by tags) that it’s set up to look for, it can detect the presence
    of objects in specific cells in a top-down 2D view around the agent. An example
    of the grid sensor attached to the selected agent is shown in [Figure 9-15](#fig:Coop-gridvis).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 网格传感器组件创建一个网格传感器。网格传感器是一种非常灵活的传感器，它围绕代理创建一个网格形状，并根据它设置为查找的对象类型（由标签定义），在代理周围的顶部视角的特定单元格中检测对象的存在。所选代理附加的网格传感器示例显示在[图 9-15](#fig:Coop-gridvis)中。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Eidos, the video game development studio, [contributed the Grid Sensor component
    to the Unity ML-Agents project](https://oreil.ly/ryu3F). The grid sensors combine
    the generality of data extraction from raycasts with the computational efficiency
    of convolutional neural networks (CNNs—neural networks that work with images).
    The grid sensor collects data from your simulations by querying the physics properties
    and then structures the data into a “height x width x channel” matrix. This matrix
    is analogous to an image in many ways, and can be fed into a CNN. Another benefit
    is that the grid can have a lower resolution than an actual image, which can improve
    training times.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Eidos，视频游戏开发工作室，[向Unity ML-Agents项目贡献了网格传感器组件](https://oreil.ly/ryu3F)。网格传感器将射线投射数据提取的通用性与卷积神经网络（CNNs——处理图像的神经网络）的计算效率结合起来。网格传感器通过查询物理属性收集模拟数据，然后将数据结构化为“高度
    x 宽度 x 通道”的矩阵。这个矩阵在很多方面类似于图像，并且可以输入到CNN中。另一个好处是，网格可以比实际图像具有更低的分辨率，这可以提高训练时间。
- en: '![psml 0915](assets/psml_0915.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0915](assets/psml_0915.png)'
- en: Figure 9-15\. The Grid Sensor component in action
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-15\. 网格传感器组件的操作
- en: 'Next, do the following for each of the blocks in the Hierarchy:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对层次结构中的每个块执行以下操作：
- en: Select the block, and use the Inspector to set the Goal Score component (the
    script we wrote and dragged onto it a moment ago) to detect things tagged with
    “goal.”
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择块，并使用检视器将目标分数组件（我们刚刚编写并拖动到其上的脚本）设置为检测带有“goal”标签的物体。
- en: 'Set the appropriate goal value: 1 for small blocks, 2 for medium blocks, and
    3 for large blocks.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置适当的目标值：小块为1，中块为2，大块为3。
- en: Next, click the + button below the Trigger Callbacks section, and set the drop-down
    to Runtime Only, as shown in [Figure 9-16](#fig:Coop-dropdown).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，单击触发回调部分下方的 + 按钮，并将下拉列表设置为仅运行时，如[图 9-16](#fig:Coop-dropdown)所示。
- en: '![psml 0916](assets/psml_0916.png)'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0916](assets/psml_0916.png)'
- en: Figure 9-16\. Setting to Runtime Only
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-16\. 仅设置为运行时
- en: Drag the Environment object from the Hierarchy into the field below the drop-down
    containing Runtime Only, and then set the drop-down to the right to point to the
    `Scored()` method in the environment script we created earlier, as shown in [Figure 9-17](#fig:Coop-scoredmethod).
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构中拖动环境对象到下拉列表下方的字段中，然后将右侧的下拉列表设置为指向我们先前创建的环境脚本中的`Scored()`方法，如[图 9-17](#fig:Coop-scoredmethod)所示。
- en: '![psml 0917](assets/psml_0917.png)'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0917](assets/psml_0917.png)'
- en: Figure 9-17\. Choosing the `Scored()` method
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-17\. 选择`Scored()`方法
- en: 'Next, do the following for the environment parent object:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对环境父对象执行以下操作：
- en: Select the environment parent object in the Hierarchy.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择环境父对象。
- en: In its Inspector, under the Environment component (which belongs to the script
    we wrote and dragged on), set Max Environment Steps to `5000`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其检视器中，在属于我们编写并拖动的脚本的环境组件下，将最大环境步骤设置为`5000`。
- en: Then drag the floor, environment parent object, and goal into the appropriate
    fields, as shown in [Figure 9-18](#fig:Coop-env).
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将地板、环境父对象和目标拖入相应的字段中，如[图 9-18](#fig:Coop-env)所示。
- en: '![psml 0918](assets/psml_0918.png)'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0918](assets/psml_0918.png)'
- en: Figure 9-18\. Configuring the environment
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-18\. 配置环境
- en: Update the List of Agents shown in the component to have `3`, and drag in each
    of the three agents, as shown in [Figure 9-19](#fig:Coop-agentlist).
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新组件中显示的代理列表以包含`3`，并拖入每个三个代理，如[图 9-19](#fig:Coop-agentlist)所示。
- en: '![psml 0919](assets/psml_0919.png)'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0919](assets/psml_0919.png)'
- en: Figure 9-19\. The list of agents
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-19\. 代理列表
- en: Update the List of Blocks shown in the component to have `6`, and drag in each
    of the six blocks, as shown in [Figure 9-20](#fig:Coop-blocklist).
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新组件中显示的块列表以包含`6`，并拖入每个六个块，如[图 9-20](#fig:Coop-blocklist)所示。
- en: '![psml 0920](assets/psml_0920.png)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0920](assets/psml_0920.png)'
- en: Figure 9-20\. The list of blocks
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-20\. 块列表
- en: That’s it! Save the scene.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！保存场景。
- en: Training for Cooperation
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为合作进行培训
- en: 'It’s almost time to train our cooperative environment. As usual, first we need
    to create a YAML file:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎是时候训练我们的合作环境了。通常，首先我们需要创建一个 YAML 文件：
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, save it somewhere! To run the training, fire up your terminal and run
    the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将其保存在某个地方！要运行训练，请启动您的终端并运行以下内容：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: And that’s it. Your training might take a few hours—on our testing MacBook Pro,
    it took about 18 hours to get somewhere.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。您的训练可能需要几个小时——在我们的测试 MacBook Pro 上，花了大约 18 小时才达到某个位置。
- en: Grab the resulting *.onnx* file, drag it into the Project pane in Unity, then
    assign it to the appropriate field in all your agents, as shown in [Figure 9-21](#fig:Coop-onnxfile),
    and run your simulation to watch your little agent friends work together to push
    blocks.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到生成的 *.onnx* 文件，将其拖入 Unity 中的项目面板，然后分配到所有代理人的适当字段中，如 [图 9-21](#fig:Coop-onnxfile)
    所示，并运行您的模拟以观察您的小伙伴代理共同推动方块。
- en: '![psml 0921](assets/psml_0921.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0921](assets/psml_0921.png)'
- en: Figure 9-21\. The model is attached to the agents
  id: totrans-268
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-21\. 该模型附加到代理人上
- en: Cooperative Agents or One Big Agent
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合作代理或一个大代理
- en: It’s sometimes difficult to conceptualize when you might want to take a cooperative
    multi-agent approach in which each agent is genuinely separate, but they are rewarded
    and guided through the systems discussed in this chapter, versus making a single
    agent that manifests in the simulation as an assortment of entities.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有时很难概念化您可能希望采用合作多代理方法的情况，在这种方法中，每个代理都是真正独立的，但它们通过本章讨论的系统受到奖励和指导，而不是制作一个在模拟中表现为各种实体的单个代理。
- en: In other words, you could replicate the behavior of the simulation you built
    here by making a single “giant” agent that has three cube entities in the world,
    each of which can move independently.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，您可以通过制作一个在世界中有三个立方体实体的单个“巨大”代理来复制您在此处构建的模拟的行为。
- en: It’s usually easier to make separate agents, because each agent will have a
    much simpler model which will result in more reliable training, and you’ll converge
    on a solution much more quickly. The neural network stored in the model for each
    agent will be a lot smaller than the theoretical giant agent, and the behaviors
    will be more predictable and, likely, reliable. But yes, you could make a giant
    agent.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 制作单独的代理通常更容易，因为每个代理将有一个更简单的模型，这将导致更可靠的训练，并且您将更快地收敛于解决方案。每个代理的模型中存储的神经网络比理论上的巨大代理要小得多，并且行为更可预测，可能也更可靠。但是，是的，您可以制作一个巨大的代理。
- en: Note
  id: totrans-273
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: One agent “cooperating” with other agents is no different from a lone agent
    in that no communication can happen between the brains of different agents (they
    cannot share intent, and information about the state of other agents can only
    come from external observations of them). Other agents existing in the simulation
    simply act as another part of the environment that this agent must consider and
    observe—albeit a potentially chaotic one.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一个代理人与其他代理人“合作”与孤立代理人没有任何不同，因为不同代理人之间不能进行通信（它们不能共享意图，关于其他代理人状态的信息只能通过对它们的外部观察得到）。存在于模拟中的其他代理人只是这个代理人必须考虑和观察的环境的另一部分——尽管可能是一个潜在混乱的部分。
- en: The problem space for a collection of legitimately individual but cooperatively
    learning agents, instead of limbs of a giant agent, is much smaller than one agent
    trying to deal with the exponential interactions that can happen between the entities
    under its control. Thus, it’s usually better to make a cooperative collection
    of agents if you need to.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合法的个体集合，但协作学习代理人的问题空间，而不是一个巨大代理人的部分，比试图处理其控制下实体之间可能发生的指数级交互的单个代理人小得多。因此，如果需要的话，通常最好制作一个协作集合的代理人。
- en: Tip
  id: totrans-276
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to explore cooperative agents in more detail, check out [Unity’s
    fantastic Dodgeball environment](https://oreil.ly/BETZi).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更详细地探索合作代理，请查看 [Unity 的精彩躲避球环境](https://oreil.ly/BETZi)。
