- en: 'Chapter 3\. Effective Dependency Management: Principles and Tools'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。有效的依赖管理：原则与工具
- en: 'In this chapter and the next, we’ll tackle a challenge that every ML practitioner
    will no doubt encounter at many points in their career: *dependency hell*. Dependency
    hell is one of the common causes of the infamous [“works on my machine” problem](https://oreil.ly/Ib_og).
    As an ML practitioner who often deals with dependency hell, you might often be
    wishing for answers to the following questions:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下一章中，我们将解决每位机器学习从业者在职业生涯中无疑会遇到的一个挑战：*依赖地狱*。依赖地狱是臭名昭著的[“在我的电脑上可以运行”问题](https://oreil.ly/Ib_og)的常见原因之一。作为一个经常遭遇依赖地狱的机器学习从业者，您可能经常希望找到以下问题的答案：
- en: How can my teammates and I easily and reproducibly install dependencies whenever
    and wherever we need them—on a local machine, a notebook in the cloud, a distributed
    cluster, etc.—with minimal toil and troubleshooting?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我和我的团队如何能够在任何需要的地方轻松、可重复地安装依赖项——无论是在本地机器、云端笔记本还是分布式集群上——并且最小化繁琐和故障排除？
- en: As our project’s dependencies grow ever larger, how can we optimize them so
    that installing dependencies doesn’t feel like we’re waiting to download the internet?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着我们项目的依赖项越来越多，我们如何优化它们，以便安装依赖项时不觉得自己在等待下载整个互联网？
- en: How can we ensure that our project is not compromised by security vulnerabilities
    in its dependencies, and those dependencies’ dependencies?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保我们的项目不会因其依赖项及其依赖项的安全漏洞而受到损害？
- en: 'By the end of Chapters [3](#effective_dependency_management_princip) and [4](ch04.html#effective_dependency_management_in_prac),
    you will have answers to all these questions. You’ll be able to apply effective
    dependency management practices to your own projects as you learn:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到第 [3](#effective_dependency_management_princip) 和第 [4](ch04.html#effective_dependency_management_in_prac)
    章结束时，您将对所有这些问题有了答案。在学习过程中，您将能够将有效的依赖管理实践应用到您自己的项目中，学到：
- en: How to recognize an incomplete dependency management approach
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何识别不完整的依赖管理方法
- en: Principles and tools for effectively managing dependencies in ML projects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效管理机器学习项目依赖项的原则和工具
- en: When, why, and how to use containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时、为何以及如何使用容器
- en: How to simplify the use of Docker with [batect](https://batect.dev), a command-line
    tool
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何简化使用 Docker 和 [batect](https://batect.dev)，一个命令行工具
- en: These two chapters are suitable for novices who are new to dependency management
    in Python-based ML projects and also intermediate users seeking advanced principles
    and best practices in dependency management. Novices can enjoy a beginner-friendly
    introduction to Python dependency managers and containers in the context of ML
    projects, as well as guiding principles and practical building blocks of any dependency
    management stack. Intermediate practitioners can learn advanced usage patterns
    and tools that help simplify dependency management. For both groups of readers,
    the accompanying code repository is something you can use when bootstrapping or
    updating your own ML projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这两章适合对基于 Python 的机器学习项目依赖管理尚不熟悉的新手，也适合寻求依赖管理高级原则和最佳实践的中级用户。新手可以在机器学习项目的上下文中享受友好的初学者介绍
    Python 依赖管理器和容器，以及任何依赖管理堆栈的指导原则和实际构建块。中级从业者可以学习帮助简化依赖管理的高级使用模式和工具。对于这两类读者，随附的代码存储库是您在引导或更新自己的机器学习项目时可以使用的资源。
- en: While we have picked a simple supervised learning example for [the hands-on
    exercise](https://oreil.ly/851RR), the approach in this chapter is generalizable
    to many other ML and data science paradigms such as deep learning, reinforcement
    learning, operations research, and even non-ML applications in Python such as
    web applications, visualization dashboards, and so on. In this chapter, there
    will be some reference to code samples, but they are intended for reading and
    illustrating concepts. In the next chapter, you can roll up your sleeves and code
    along in the hands-on exercise.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们选择了一个简单的监督学习示例用于[实践练习](https://oreil.ly/851RR)，但本章的方法适用于许多其他机器学习和数据科学范例，如深度学习、强化学习、运营研究，甚至是
    Python 中的非机器学习应用，如 Web 应用程序、可视化仪表盘等。本章中将涉及一些代码示例，但它们旨在阐述和说明概念。在下一章中，您可以动手进行实践练习。
- en: Finally, this is not a prescription for “This Is The Way It Must Be Done.” Rather,
    it’s a modular set of techniques and tools that have helped us—and can help any
    ML practitioner—avoid common pitfalls in managing dependencies in the ML and Python
    ecosystem. Should you face any of the traps described in this chapter, consider
    how these principles and practices can help you.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这不是“必须这样做”的规定。相反，这是一套模块化的技术和工具，它们帮助了我们——并且可以帮助任何机器学习从业者——避免在机器学习和Python生态系统中管理依赖时常见的陷阱。如果你在本章中遇到描述的任何陷阱，请考虑这些原则和实践如何帮助你。
- en: With that, let’s jump into the first section—principles and practices for effective
    dependency management.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，让我们进入第一部分——有效的依赖管理原则和实践。
- en: What If Our Code Worked Everywhere, Every Time?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果我们的代码在任何地方、任何时候都能正常工作会怎样？
- en: 'Raise your hand if you’ve ever:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 举手之劳，如果你曾经：
- en: Cloned a repo at work or in your personal project hoping to test out an exciting
    idea, only to get stuck even before you can start because of a dependency installation
    error like `command 'gcc' failed with exit status 1`?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作中或个人项目中克隆了一个仓库，希望测试一个激动人心的想法，但在开始之前甚至无法启动，因为出现了依赖安装错误，比如`command 'gcc' failed
    with exit status 1`？
- en: Accidentally installed a library (e.g., `pandas==x.x.x`) in your OS-level Python
    or in the virtual environment for another project, thereby polluting those environments—and
    wasting time undoing the damage—because you forgot to activate the right virtual
    environment?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不小心在操作系统级别的Python中或者另一个项目的虚拟环境中安装了一个库（例如，`pandas==x.x.x`），从而污染了这些环境——浪费了时间来消除损害——因为你忘记激活正确的虚拟环境？
- en: 'Spent days or even weeks getting set up in a new project, growing some gray
    hair along the way, while troubleshooting dependency installation errors like
    those that arise due to differing versions of an OS-level dependency such as Python?
    `Error: No matching distribution found for torch==x.x.x`, anyone?'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '花费了几天甚至几周的时间在新项目中设置环境，这一路上长了些许灰白头发，同时排除依赖安装错误，比如由于操作系统级别依赖（如Python）的不同版本而引起的错误：`Error:
    No matching distribution found for torch==x.x.x`，有人碰到过吗？'
- en: We have a feeling that we’re not the only ones on this boat. In fact, we are
    100% certain that all ML practitioners have been tripped up by similar issues,
    caused by an incomplete dependency management solution, when trying to run some
    ML code locally or on the cloud (see [Figure 3-1](#an_xkcd_comic_expressing_the_funny_but)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感觉我们并不是唯一一个遇到这种情况的人。事实上，我们可以百分之百确定所有机器学习从业者都曾因为不完整的依赖管理解决方案而遇到类似问题，当试图在本地或云端运行一些机器学习代码时（见[图3-1](#an_xkcd_comic_expressing_the_funny_but)）。
- en: '![](assets/emlt_0301.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/emlt_0301.png)'
- en: 'Figure 3-1\. An [xkcd comic](https://oreil.ly/ffGv7) expressing the funny-but-true
    nature of dependency management in Python: it’s more complicated than it needs
    to be (source: [xkcd.com](https://oreil.ly/eTAAk), used with permission)'
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1。一张[xkcd漫画](https://oreil.ly/ffGv7)，表达了Python依赖管理的有趣但真实的本质：它比必要的复杂得多（来源：[xkcd.com](https://oreil.ly/eTAAk)，经许可使用）
- en: We can avoid these pitfalls if we understand the basics of dependency management
    in Python and basic principles and practices for effective dependency management.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们理解Python依赖管理的基础知识以及有效依赖管理的基本原则和实践，我们就能避免这些陷阱。
- en: In the remainder of this section, we’ll explore a better path by looking to
    enduring dependency management principles and practices from the software engineering
    world.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分中，我们将通过查看软件工程世界中持久的依赖管理原则和实践，探索一条更好的路径。
- en: 'A Better Way: Check Out and Go'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的方法：检出和执行
- en: 'Here’s a fun question: When you—or a new starter—first joined your team, how
    long did it take to set up your development environment and make your first commit?
    Was it days? Weeks?'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有个有趣的问题：当你——或一个新手——第一次加入你的团队时，设置开发环境并进行第一次提交花费了多长时间？是几天？几周？
- en: 'Imagine this alternate reality: You’re onboarding a new teammate, and your
    instruction to them is simply “check out the project repo, run `./go.sh`, and
    you’re done.” That sounds radical and almost fictional, but by the end of this
    chapter, you will see that it is doable and you will learn how to do this in your
    own ML projects.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这个替代现实：你正在接纳新的团队成员，你对他们的指导仅仅是“检查项目仓库，运行`./go.sh`，然后完成”。听起来很激进，几乎是虚构的，但是在本章结束时，你会发现这是可行的，你将学会如何在你自己的机器学习项目中做到这一点。
- en: This is known as [“check out and go”](https://oreil.ly/b5kNk), and it is a common
    practice in teams with mature software engineering practices. They avoid setup
    procedures that are partially automated and guided by lengthy documentation, word-of-mouth
    knowledge, and ad hoc troubleshooting. Instead, a new code contributor can set
    up their development environment locally in a few commands and run tests, commit,
    and push code within a day.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为 [“检出和启动”](https://oreil.ly/b5kNk)，它是成熟软件工程实践团队中的常见做法。他们避免部分自动化并且依赖于冗长文档、口口相传的知识和临时排除故障的设置流程。相反，新的代码贡献者可以在几个命令中在本地设置他们的开发环境，运行测试，提交和推送代码，一天内完成。
- en: 'In a moment, we will describe the principles and practices that will help you
    materialize this. But before that, we’d like to describe the benefits of adopting
    this practice, based on our experience in real-world ML projects:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将描述原则和实践，这将帮助您实现这一点。但在此之前，我们想根据我们在真实 ML 项目中的经验描述采用这一做法的好处：
- en: Faster onboarding
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 更快的入职速度
- en: Instead of spending days and even weeks getting set up, new teammates—and also
    existing teammates contributing to a different project in the organization, or
    teammates getting a new computer—can get set up within a day, start running code
    and tests locally, and start to make code contributions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 新团队成员——以及在组织中为不同项目做贡献的现有团队成员或获得新电脑的团队成员——可以在一天内完成设置，并开始在本地运行代码和测试，开始进行代码贡献。
- en: Saving time and cognitive resources
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 节省时间和认知资源
- en: The ability to automatically create consistent production-like environments
    reduces toil and time spent on configuring and troubleshooting [snowflake environments](https://oreil.ly/Akr5L)^([1](ch03.html#ch01fn21))
    or trying to remember how you installed and configured a particular dependency
    many months ago. As a result, teammates can do more of the things that they want
    to do, which helps us feel productive and satisfied.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 能够自动创建一致的类生产环境，减少了在配置和排除故障 [雪花环境](https://oreil.ly/Akr5L)^([1](ch03.html#ch01fn21))
    或尝试记住几个月前如何安装和配置特定依赖的时间和认知资源。因此，队友们可以做更多他们想做的事情，这有助于我们感到高效和满意。
- en: Experiment-operation symmetry
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实验操作对称性
- en: By running everything in consistent, reproducible, production-like environments,
    we can be sure that what works locally on our machines will work when we push
    our code and run code on the cloud, for example when we run tests on CI/CD pipelines
    or train our models on CPU or GPU instances on the cloud.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在一致、可重现、类生产的环境中运行所有内容，我们可以确保在本地机器上运行的内容在推送代码和在云上运行代码时也能正常工作，例如在 CI/CD 管道上运行测试或在云上的
    CPU 或 GPU 实例上训练模型时。
- en: Reproducibility and repeatability
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可重现性和可重复性
- en: The code that we wrote last week to solve a problem will work everywhere—on
    our colleagues’ machines, on the CI/CD pipeline, on cloud compute instances—every
    time. It will work the same way regardless of the underlying operating system.
    This is also useful in academic settings, where there is an increasing focus for
    papers to improve reproducibility by providing both the code and data that were
    used to arrive at findings.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上周编写的代码解决了一个问题，可以在任何地方使用——在我们同事的机器上、在 CI/CD 管道上、在云计算实例上——每次都能正常工作。无论底层操作系统如何，它都将以相同的方式工作。在学术环境中，这也很有用，因为越来越多的论文通过提供用于发现结果的代码和数据来提高可重现性。
- en: Taken together, “check out and go” enables teams to easily and reliably set
    up runtime environments for developing, testing, and running code. This allows
    them to focus on solving the problems that they want to solve, instead of [yak
    shaving](https://oreil.ly/NhBxW).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 综合来看，“检出和启动”使团队能够轻松可靠地为开发、测试和运行代码设置运行时环境。这使他们能够专注于解决他们想要解决的问题，而不是 [剃毛](https://oreil.ly/NhBxW)。
- en: Teams could consider measuring “lead time to first push” for a new team member—or
    an existing team member on a new machine—as a litmus test of the effectiveness
    of the team’s dependency management approach. The “first push” is a helpful forcing
    function that verifies if a new team member is able to set up their development
    environment locally, configure their code editor, run tests, make a simple change,
    and locally test that the change worked.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 团队可以考虑测量新团队成员（或新设备上的现有团队成员）的“首次推送时间”，作为评估团队依赖管理方法效果的试金石。 “首次推送”是一个有用的强制函数，验证新团队成员是否能够在本地设置他们的开发环境，配置他们的代码编辑器，运行测试，进行简单更改，并在本地测试该更改是否有效。
- en: Now that we’ve seen the benefits of the “check out and go” practice, let’s take
    a look at the enduring principles that can help us implement it, regardless of
    which technology or tool we use.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了“签出并执行”的实践的好处，让我们来看看可以帮助我们实施它的持久原则，无论我们使用哪种技术或工具。
- en: Principles for Effective Dependency Management
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效依赖管理原则
- en: 'At its core, dependency management is a simple concept. In this context, *dependencies*
    refer to all the software components required by your project in order for it
    to work as intended and avoid runtime errors (see [Figure 3-2](#with_good_dependency_management_practic)).
    Dependencies can be further separated into two levels: OS-level dependencies and
    application-level dependencies.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，依赖管理是一个简单的概念。在这个背景下，*依赖关系* 指的是项目中所有必需的软件组件，以使其按预期工作并避免运行时错误（见 [图 3-2](#with_good_dependency_management_practic)）。依赖关系可以进一步分为两个级别：操作系统级别的依赖关系和应用程序级别的依赖关系。
- en: Modern ML applications are typically expected to run on multiple operating systems.
    For example, we may develop on Mac, Linux, or Windows, run tests on CI pipelines
    (typically Linux) and run full model training on ephemeral cloud CPU or GPU instances
    (typically Linux). Container technologies such as Docker help us simplify OS-level
    dependency management. The application-level dependencies that we install in one
    environment (e.g., local development environment) must work in the same way in
    other environments, as well (e.g., CI, preproduction, and production environments).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现代机器学习应用通常预计在多个操作系统上运行。例如，我们可能在 Mac、Linux 或 Windows 上进行开发，在 CI 流水线上运行测试（通常是
    Linux），并在瞬态云 CPU 或 GPU 实例（通常是 Linux）上运行完整的模型训练。像 Docker 这样的容器技术帮助我们简化操作系统级别的依赖管理。我们在一个环境中安装的应用程序级别的依赖关系（例如，本地开发环境）必须在其他环境中（例如，CI、预生产和生产环境）以同样的方式工作。
- en: By properly managing our dependencies at both levels, we ensure that we can
    create consistent and production-like environments from our code, and that what
    works here and now will work everywhere and every time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在两个级别上正确管理我们的依赖关系，我们确保能够从我们的代码创建一致和类似生产的环境，确保这里和现在的工作将在任何地方和任何时间都能工作。
- en: '![](assets/emlt_0302.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/emlt_0302.png)'
- en: Figure 3-2\. With good dependency management practices, we can create consistent,
    production-like, and reproducible environments from the get-go
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. 通过良好的依赖管理实践，我们可以从一开始就创建一致、类似生产环境的可重现环境。
- en: Before diving into specific technologies and implementation details, let’s understand
    four enduring principles that can guide us toward a proper dependency management
    solution, irrespective of which specific technology or tool we choose.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究具体技术和实施细节之前，让我们先了解四个持久的原则，这些原则可以指导我们朝着适当的依赖管理解决方案迈进，无论我们选择哪种具体的技术或工具。
- en: Dependencies “as code”
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖关系“作为代码”
- en: By specifying *all* dependencies and configuration [as code](https://oreil.ly/-45KL),
    we enable all code contributors to create consistent development environments
    from code *in an automated fashion*. In addition, any changes to the dependency
    stack—both OS-level and application-level dependencies—are version controlled
    and can be reproduced and rapidly tested in another environment (e.g., on the
    CI pipeline).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 *所有* 依赖关系和配置 [作为代码](https://oreil.ly/-45KL)，我们使所有代码贡献者能够从代码中以*自动化的方式*创建一致的开发环境。此外，依赖堆栈的任何更改——包括操作系统级别和应用程序级别的依赖关系——都是版本控制的，并且可以在另一个环境中（例如
    CI 流水线上）进行复制和快速测试。
- en: In contrast, any part of the dependency stack that is not codified and automated
    will need to be manually configured for every compute environment in which our
    code will run. This could include other teammates’ machines, CI/CD pipelines,
    cloud training instances, and production servers. In our experience, this invariably
    becomes a huge time sink and source of frustration.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，依赖堆栈中未编码和自动化的任何部分都需要为代码将运行的每个计算环境手动配置。这可能包括其他团队成员的计算机、CI/CD 流水线、云训练实例和生产服务器。根据我们的经验，这无疑会成为一个巨大的时间浪费和沮丧的源头。
- en: Production-like development environments from day one
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从一开始就类似于生产的开发环境
- en: There are few things more stressful and frustrating than detecting issues or
    errors only in production. Having a production-like environment during development
    helps to solve that problem. Even as we’re coding, we can catch potential issues
    that may occur when our code is running in a production environment because our
    development environment is production-like in terms of dependencies. This gives
    us the confidence that, from a software dependencies perspective, what works locally
    during development and testing will work in production.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比在生产中检测到问题或错误更加紧张和沮丧的了。在开发过程中拥有类似生产的环境有助于解决这个问题。即使在编码时，我们也可以捕捉到可能在生产环境中发生的问题，因为我们的开发环境在依赖项方面类似于生产环境。这使我们确信，从软件依赖项的角度来看，本地开发和测试正常运行的内容也将在生产环境中正常工作。
- en: We should ensure that we create production-like development environments as
    early as possible, even in the *first week* of a new ML application or project.
    Trying to get a messy project into shape is much harder than establishing the
    right habits right from the beginning.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该尽早创建类似生产的开发环境，甚至在新的ML应用或项目的*第一周*。试图整理一个混乱的项目比从一开始就养成正确的习惯要困难得多。
- en: Application-level environment isolation
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用级环境隔离
- en: Each application, project, or code repository should have its own isolated Python
    virtual environment. This allows us to avoid shared state and unnecessary coupling
    between different applications. In our experience, unnecessary coupling has led
    to cases where dependency changes for one application unintentionally and unexpectedly
    introduced errors in another application. Naturally, and annoyingly, that increases
    friction and slows down our ability to execute on our ideas.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用、项目或代码仓库都应该有自己独立的Python虚拟环境。这样我们就可以避免不同应用之间的共享状态和不必要的耦合。根据我们的经验，不必要的耦合导致某个应用的依赖变更不经意间地在另一个应用中引入错误。这自然而然地增加了摩擦，并减缓了我们执行想法的能力。
- en: There are many tools—such as Python’s built-in venv module, poetry, pipenv,
    conda—that provide functionalities for creating and managing isolated virtual
    environments. Whichever tool you pick—and teams should align toward one to reduce
    complexity—ensure that each application has its own dependencies that we can install
    in its own virtual environment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具——如Python的内置venv模块、poetry、pipenv、conda——提供了创建和管理隔离虚拟环境的功能。无论选择哪个工具——团队应该一致选择一个以减少复杂性——确保每个应用都有自己的依赖项，我们可以在其自己的虚拟环境中安装这些依赖。
- en: OS-level environment isolation
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作系统级环境隔离
- en: In most cases, we typically need to run our ML development on multiple operating
    systems. For example, developing on Windows or MacOS, testing on Linux on CI instances,
    and deploying to Linux instances on the cloud or on target devices. Even if the
    entire team were using one operating system (e.g., Linux), whatever we did to
    configure OS-level dependencies—like installing a specific version of Python 3.x—will
    need to be regularly reproducible on ephemeral target instances such as during
    deployment.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们通常需要在多个操作系统上运行我们的ML开发。例如，在Windows或MacOS上开发，通过CI实例在Linux上测试，并在云上或目标设备上部署到Linux实例。即使整个团队都使用同一个操作系统（例如Linux），我们为配置操作系统级依赖项（如安装特定版本的Python
    3.x）所做的任何工作都需要在临时目标实例上定期可重现，例如在部署期间。
- en: While ML practitioners are generally familiar with application-level dependency
    management in Python, we often neglect to manage OS-level dependencies in a similar
    way (i.e., as code). It’s more common to see some instructions in the README to
    manually install certain dependencies (e.g., Python 3) and leave the specific
    versions (e.g., Python 3.x) that we install to chance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ML从业者通常熟悉Python中的应用级依赖管理，但我们经常忽视以类似的方式管理操作系统级依赖（即作为代码）。更常见的是在README中看到一些说明手动安装某些依赖项（例如Python
    3），并且对我们安装的具体版本（例如Python 3.x）留下了机会。
- en: The cost of this neglect is time wasted troubleshooting issues and errors resulting
    from snowflake environments. If that all sounds too abstract, just think back
    to the times you cloned a repo to try and run some promising code or notebook,
    only to waste hours or even days troubleshooting errors caused by a missing or
    misconfigured OS-level dependency.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 忽视这一点的代价是浪费时间排查由雪花环境引起的问题和错误。如果这些听起来太抽象，只需回想一下您克隆了一个repo以尝试运行一些有前景的代码或笔记本，结果由于缺少或配置错误的操作系统级依赖项而浪费了几个小时甚至几天排查错误。
- en: Now that you’re equipped with these guiding principles, let’s look at the tools
    and technologies that can help us put these principles into practice.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了这些指导原则，让我们看看哪些工具和技术可以帮助我们将这些原则付诸实践。
- en: Tools for Dependency Management
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖管理工具。
- en: In this section, we’ll explore some tools that can help us put these principles
    into practice.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些可以帮助我们付诸实践这些原则的工具。
- en: 'In a nutshell, to effectively manage the dependencies of a given project, we
    need to:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，要有效地管理给定项目的依赖关系，我们需要：
- en: Specify OS-level dependencies as code (e.g., by using Docker)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将操作系统级别的依赖项指定为代码（例如，使用Docker）。
- en: Specify application-level dependencies as code (e.g., by using Poetry)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序级别的依赖项指定为代码（例如，使用Poetry）。
- en: In this book, we have decided to use Docker and Poetry. We have used several
    tools in the Python ecosystem in the past few years, and so far Docker and Poetry
    have stood out among the others and have worked well for us. With that said, we
    acknowledge that the choice of any tool in any project or team depends on several
    factors. Whichever you choose, just be sure that you use them in a way that upholds
    the four principles described in the preceding section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们决定使用Docker和Poetry。在过去几年中，我们在Python生态系统中使用了几种工具，到目前为止，Docker和Poetry在其中脱颖而出，并且对我们很有效。话虽如此，我们也承认，在任何项目或团队中选择任何工具取决于多个因素。无论你选择哪一个，只要确保你以前一节描述的四个原则为指导使用它们。
- en: Let’s start by understanding how Docker manages OS-level dependencies.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解Docker如何管理操作系统级别的依赖项。
- en: Managing OS-level dependencies
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理操作系统级别的依赖项。
- en: Containers encapsulate your code along with the entire dependency stack. This
    gives you a portable, reproducible, consistent runtime environment for your code
    across machines.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 容器将您的代码与整个依赖栈一起封装。这为您提供了一个可移植、可复制、一致的运行环境，使您的代码在不同机器上都能保持一致。
- en: If your ML stack requires running code in multiple compute environments (e.g.,
    local developer machines, training instances on the cloud, production API servers,
    CI/CD pipelines), you will definitely benefit from using Docker. By containerizing
    your code, you can ensure that if your code works now during experimentation and
    development, it will work just the same in another space and time—e.g., on the
    cloud and during scheduled production training runs—so long as the Docker runtime
    is present.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的ML堆栈需要在多个计算环境中运行代码（例如，本地开发机器、云上的训练实例、生产API服务器、CI/CD流水线），那么使用Docker肯定会有所帮助。通过将你的代码容器化，你可以确保在实验和开发期间代码现在工作，它将在另一个时空中同样工作，例如，在云端和计划的生产训练运行期间，只要Docker运行时存在。
- en: We will dive into the basic building blocks of working with Docker in the next
    section, but we’d like to take a moment to address the reflexive aversion to Docker,
    which can be common among ML practitioners due to three misconceptions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中深入探讨使用Docker的基本构建块，但我们希望花一点时间来解释对Docker的反射性厌恶，在ML从业者中可能很常见，因为存在三种误解。
- en: 'Misconception 1: Docker is overcomplicated and unnecessary'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 误解1：Docker过于复杂且不必要。
- en: Some see Docker as an overcomplicated and daunting tool that takes time and
    effort to learn without adding much value. On the other hand, we’ve also worked
    with other ML practitioners who use it in their day-to-day work as a tool that
    helps, rather than hinders, them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为Docker是一个过于复杂和令人望而却步的工具，学习它需要时间和精力，但并没有增加太多价值。另一方面，我们也与其他ML从业者合作过，他们将其视为一种帮助而非阻碍的工具，日常工作中经常使用它。
- en: If you are in the former camp, we hope that this chapter will demonstrate the
    value and simplicity of using containers. We wouldn’t need Docker if we were only
    ever going to run our code on one machine. However, as we’ve established earlier,
    that’s rarely the case when building ML systems.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你属于前者，我们希望本章能展示使用容器的价值和简单性。如果我们只打算在一台机器上运行代码，我们就不需要Docker。然而，正如我们之前所说的，当构建ML系统时，这种情况很少见。
- en: As with any technology, Docker comes with a learning curve, but it’s not a steep
    one. In our experience, the absence of Docker always ends up costing us more time.
    For example, if we accidentally make a horrible mess of a development environment
    (as we have done before!), it is very hard to recover from that if we were running
    on the host. But with containers, we just blow the image away and start with a
    fresh container in a few minutes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何技术一样，Docker有一个学习曲线，但并不陡峭。根据我们的经验，没有Docker最终总是会花更多的时间。例如，如果我们在开发环境中意外地搞得一团糟（正如我们以前做过的那样！），如果我们运行在主机上，要从中恢复是非常困难的。但是有了容器，我们只需删除镜像，几分钟内就可以从头开始一个新的容器。
- en: We may invest time learning it and setting things up for the team, but once
    that is done, we can reliably create consistent, reproducible, and production-like
    development environments effortlessly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会花时间学习它并为团队设置环境，但一旦完成，我们就能轻松地可靠地创建一致、可复制和类似生产的开发环境。
- en: 'Misconception 2: I don’t need Docker because I already use X (e.g., conda)'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 误解2：我不需要Docker，因为我已经使用X（例如conda）
- en: Docker is often wrongly pitted against other Python dependency managers such
    as pip, conda, poetry, and pip-tools. However, this is a poor comparison because
    they solve different problems—Python dependency managers concern themselves with
    application-level Python dependencies, while Docker also helps you install and
    configure OS-level dependencies, such as Python, gcc (GNU Compiler Collection),
    and CUDA.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Docker经常被错误地与其他Python依赖管理器如pip、conda、poetry和pip-tools相提并论。然而，这是一个不恰当的比较，因为它们解决了不同的问题——Python依赖管理器关注应用级Python依赖，而Docker还帮助您安装和配置OS级别的依赖，如Python、gcc（GNU编译器集合）和CUDA。
- en: Without Docker, our code is directly dependent on, and left to chance with,
    unspecified host-level runtime dependencies. Even if you’re just installing something
    as simple as `pandas==1.5.1`, the installation will succeed for developers using
    a version of Python greater than or equal to 3.8 but fail with the error `No matching
    distribution found for pandas==1.5.1` on any other machine that happened to have
    Python 3.7 or below (see [Figure 3-3](#even_something_as_simple_as_installing)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 没有Docker，我们的代码直接依赖于未指定的主机级运行时依赖，并留给机会。即使只是安装像`pandas==1.5.1`这样简单的东西，对于使用大于或等于3.8版本Python的开发人员，安装将成功，但在任何其他机器上，安装会因错误`No
    matching distribution found for pandas==1.5.1`而失败，这些机器上可能安装的是Python 3.7或更低版本（见[图3-3](#even_something_as_simple_as_installing)）。
- en: '![](assets/emlt_0303.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/emlt_0303.png)'
- en: Figure 3-3\. Installing a Python library (`pandas==1.5.1`) can fail (see left
    side of image—using Python 3.7) or succeed (see right side of image—using Python
    3.9) depending on the specific version of Python 3
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-3\. 安装Python库（`pandas==1.5.1`）可能会失败（见图像左侧—使用Python 3.7）或成功（见图像右侧—使用Python
    3.9），这取决于特定版本的Python 3。
- en: At the time of writing, there are [500 questions on Stack Overflow with this
    error](https://oreil.ly/iHDtN). That’s only counting the people who submitted
    a question on Stack Overflow, and not the countless people who were actively searching
    for an answer to this error. We were one of them, on multiple occasions! All of
    that time and effort could have been saved if we had used containers to specify
    a specific Python version.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写时，[Stack Overflow上有500个问题与此错误相关](https://oreil.ly/iHDtN)。这只计算了在Stack Overflow上提交问题的人数，而没有计算积极寻找答案的无数其他人。我们是其中之一，多次如此！如果我们早些时候使用容器来指定特定的Python版本，所有这些时间和精力都可以节省。
- en: 'Misconception 3: Docker will have a significant performance impact'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 误解3：Docker会显著影响性能
- en: 'When faced with a long-running and slow code, one has plenty of time to ponder
    many pertinent questions—What is the meaning of life? Why is my code so slow?
    Like a time-thirsty nomad in a time-scarce desert, we may start seeing mirages
    and perhaps want to confront Docker and ask: Are you slowing down my code?!'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 面对运行时间长且缓慢的代码，人们有足够的时间去思考许多相关问题——生命的意义是什么？为什么我的代码运行如此缓慢？就像在时间匮乏的沙漠中渴望时间的游牧民族一样，我们可能会开始看到海市蜃楼，并希望直面Docker并问道：你是不是在减慢我的代码？
- en: 'When thinking about optimization, never forget [the third rule of optimization](https://oreil.ly/XCN66):
    *Measure before optimizing*. A [benchmark analysis](https://oreil.ly/VcpSh) ran
    a computationally intensive deep learning task both inside and outside of containers
    and *found no noticeable differences* in performance. Another [benchmark analysis](https://oreil.ly/YPlLp)
    comparing the performance impact of running various deep learning models (e.g.,
    InceptionV3, VGG16) in containers and on host found that *performance differences
    are close to zero*.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑优化时，永远不要忘记[优化的第三法则](https://oreil.ly/XCN66)：*在优化之前进行测量*。[基准分析](https://oreil.ly/VcpSh)对比了在容器内外运行计算密集型深度学习任务的性能，发现性能没有显著差异。另一项[基准分析](https://oreil.ly/YPlLp)比较了在容器和主机上运行各种深度学习模型（如
    InceptionV3、VGG16）的性能影响，发现*性能差异接近于零*。
- en: Docker has been found to [sometimes slow down Python performance](https://oreil.ly/d07Mo),
    but the performance hit is not always consistent. The performance slowdown is
    likely due to one of Docker’s security features, [seccomp](https://oreil.ly/BzGuK).
    Using this chapter’s code example, we reproduced a performance impact—an average
    slowdown of 1.7%—when running `python src/train.py` in Docker and on the host
    (see [Table 3-1](#benchmarking_the_run_durations_of_this)). In both scenarios,
    we were using Python 3.10.6\. However, when we look at the performance breakdown,
    the slowdown was mainly from reading data from disk. The code for processing data
    and training models is equally performant, if not more performant.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 已被发现[有时会降低 Python 的性能](https://oreil.ly/d07Mo)，但性能损失并不总是一致的。性能减慢很可能是由于
    Docker 的一个安全功能[seccomp](https://oreil.ly/BzGuK)导致的。使用本章的代码示例，我们复现了性能影响——在 Docker
    和主机上运行`python src/train.py`时，平均减慢了 1.7%（见[表 3-1](#benchmarking_the_run_durations_of_this)）。在这两种场景下，我们都使用的是
    Python 3.10.6\. 但是，当我们查看性能分析时，减速主要来自于从磁盘读取数据。用于处理数据和训练模型的代码表现同样出色，甚至更出色。
- en: Table 3-1\. Benchmarking the run durations of this chapter’s model training
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. 本章模型训练运行持续时间的基准测试
- en: '| Code to run | Average duration across 10 runs (seconds) |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 运行的代码 | 十次运行的平均持续时间（秒） |'
- en: '| --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|   | *Duration on host* | *Duration in container* |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|   | *主机上的持续时间* | *容器中的持续时间* |'
- en: '| --- | --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `pd.read_csv(...)` (loading 100,000 rows of data) | 0.6 | 1.75 (slower than
    host) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `pd.read_csv(...)`（加载 100,000 行数据）| 0.6 | 1.75（比主机慢） |'
- en: '| `preprocess_data(...)` | 1.1 | 1.1 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `preprocess_data(...)` | 1.1 | 1.1 |'
- en: '| `fit_model(...)` | 15.4 | 14.6 (faster than host) |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `fit_model(...)` | 15.4 | 14.6（比主机更快） |'
- en: '| `evaluate_model(...)` | 0.4 | 0.4 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `evaluate_model(...)` | 0.4 | 0.4 |'
- en: '|   | **17.5** | **17.85** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|   | **17.5** | **17.85** |'
- en: 'Always remember to measure before optimizing: Measure performance under both
    conditions instead of assuming one will be worse than the other. Otherwise, you
    might find yourself trading off the benefits of using containers without knowing
    what gains you made, if any.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 始终记住在优化之前先进行测量：在两种条件下测量性能，而不是假设其中一种条件会比另一种差。否则，您可能会发现自己在不知道是否获得了任何收益的情况下，牺牲了使用容器的好处。
- en: 'Complicating the picture: Differing CPU chips and instruction sets'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复杂化的情况：不同的 CPU 芯片和指令集
- en: The concept of “build once, deploy anywhere” is a core tenet of Docker’s appeal.
    However, as anyone who has collaborated with teammates who are using machines
    with different chips—e.g., Intel Macs versus M1/M2 Macs—can tell you, this is
    not always the case. One common failure mode is Dockerfiles that install Python
    dependencies successfully in one machine, but unsuccessfully in another machine
    with a different chip or instruction set. Itamar Turner-Trauring clearly explains
    the root cause of this in his article [“Why New Macs Break Your Docker Build,
    and How to Fix It”](https://oreil.ly/Oct3e), and we encourage you to take a few
    minutes to check it out.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: “构建一次，随处部署”的概念是 Docker 吸引人的核心理念。然而，与使用不同芯片的队友合作的人可能会告诉你，并不总是这样。一个常见的失败模式是在一台机器上成功安装
    Python 依赖项的 Dockerfile，在另一台具有不同芯片或指令集的机器上安装失败。伊塔马尔·特纳-特劳林在他的文章[“为什么新的 Mac 会破坏你的
    Docker 构建，以及如何解决”](https://oreil.ly/Oct3e)中清楚地解释了这个问题的根本原因，我们鼓励您花几分钟时间查看。
- en: 'To briefly summarize Turner-Trauring’s article, a typical failure in installing
    dependencies across two types of CPUs could go like this (see [Figure 3-4](#anatomy_of_a_python_dependency_installa)):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 简单总结一下特纳-特劳林的文章，跨两种类型的 CPU 安装依赖项的典型失败可能会像这样进行（参见[图 3-4](#anatomy_of_a_python_dependency_installa)）：
- en: A teammate, Dana, is using an Intel Mac, which uses the *AMD64* instruction
    set, also known as x86_64.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一位队友 Dana 使用的是英特尔 Mac，它使用 *AMD64* 指令集，也称为 x86_64。
- en: Another teammate, Ted, is using a new Mac with M1 or M2 processors, which use
    the *ARM64* instruction set, also known as aarch64.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一位队友 Ted 使用的是配备 M1 或 M2 处理器的新 Mac，它们使用 *ARM64* 指令集，也称为 aarch64。
- en: AMD64 and ARM64 instruction sets are in different languages; a CPU that speaks
    one language can’t understand the other.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMD64 和 ARM64 指令集使用不同的语言；一个只懂一种语言的 CPU 无法理解另一种语言。
- en: To make it easier and quicker to install Python packages, package maintainers
    usually upload precompiled [wheels (a Python built-package format)](https://oreil.ly/xjKnz)
    to PyPI (Python Packaging Index), though not always for all CPU instruction sets.
    Precompiled Python wheels are tied to a particular CPU instruction set.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更轻松、更快速地安装 Python 包，软件包维护者通常会将预编译的 [wheels（Python 的构建包格式）](https://oreil.ly/xjKnz)
    上传到 PyPI（Python 包索引），尽管并非始终针对所有 CPU 指令集。预编译的 Python wheels 与特定的 CPU 指令集绑定。
- en: '![](assets/emlt_0304.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/emlt_0304.png)'
- en: Figure 3-4\. Anatomy of a Python dependency installation failure when package
    maintainers neglect to publish both ARM64 and AMD64 wheels, even though Docker
    was supposed to prevent such failures
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-4\. 当软件包维护者忽略发布 ARM64 和 AMD64 轮子时，Python 依赖安装失败的解剖图，即使 Docker 本应防止此类失败。
- en: 'How the dependency installation failure typically happens:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖安装失败通常发生的方式：
- en: Dana adds a Python package `xyz=1.0.0` to the project, and it installs successfully
    on her machine because the maintainers of xyz happened to publish AMD64 wheels.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dana 将一个 Python 包 `xyz=1.0.0` 添加到项目中，它在她的机器上成功安装，因为 xyz 的维护者碰巧发布了 AMD64 轮子。
- en: Ted pulls the code changes, and because there is a new dependency, `docker build`
    now will run `poetry install` (or `pip install`—it doesn’t matter in this context).
    As depicted in [Figure 3-4](#anatomy_of_a_python_dependency_installa), the maintainers
    of xyz neglected to publish ARM64 wheels. When Poetry can’t find the ARM64 wheel
    for xyz from PyPI, Poetry will download the source code and attempt to compile
    the package from source.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ted 拉取代码更改，由于有一个新的依赖关系，`docker build` 现在将运行 `poetry install`（或者在这个上下文中使用 `pip
    install` 也可以）。如图 [Figure 3-4](#anatomy_of_a_python_dependency_installa) 所示，xyz
    的维护者忽略了发布 ARM64 轮子。当 Poetry 从 PyPI 找不到 xyz 的 ARM64 轮子时，Poetry 将下载源代码并尝试从源代码编译包。
- en: At this point, `poetry install` will fail if the gcc compiler isn’t installed
    in the team’s development environment.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这一点上，如果团队的开发环境没有安装 gcc 编译器，`poetry install` 将失败。
- en: 'There is a quick and simple fix—install the gcc compiler in our Dockerfile
    before installing Python dependencies. This will ensure that we can install the
    specified package versions in our project, even if the maintainers neglected to
    publish wheels for a given CPU instruction set. This is accomplished easily with
    Docker, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个快速简单的解决方法——在我们的 Dockerfile 中安装 gcc 编译器，然后再安装 Python 依赖。这将确保我们可以在项目中安装指定的包版本，即使维护者忽略了为特定
    CPU 指令集发布轮子。这在 Docker 中可以轻松实现，如下所示：
- en: '[PRE0]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The downsides of this approach are that image builds will get slower and the
    images will be larger. Thankfully, both of these downsides can be mitigated by
    caching and multistage builds, respectively. We will demonstrate both of these
    techniques in the next chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是镜像构建会变慢，而且镜像会变得更大。幸运的是，这两个缺点可以通过缓存和多阶段构建来缓解，分别在下一章中演示这两种技术。
- en: 'The *proper* fix: all Python package maintainers should distribute wheels for
    AMD64, MacOS ARM64 (for poetry install in MacOS host), and Linux ARM64 (for poetry
    install in Docker containers). But that’s not always within our control.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*正确的* 解决方法：所有 Python 包维护者都应该为 AMD64、MacOS ARM64（用于 MacOS 主机的 poetry 安装）和 Linux
    ARM64（用于 Docker 容器中的 poetry 安装）分发轮子。但这并不总是在我们的控制之内。'
- en: Besides this failure mode relating to the installation of Python dependencies,
    teams that are working with deployment targets that comprise multiple platforms
    or various types of CPU chips must ensure that they are building [multiplatform
    images](https://oreil.ly/Jw_dy). This will allow the Docker runtime to automatically
    select the image that matches the OS and architecture of the respective development
    and deployment environments.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与安装 Python 依赖关系有关的失败模式外，与使用包含多个平台或不同类型 CPU 芯片的部署目标的团队必须确保他们构建了 [多平台镜像](https://oreil.ly/Jw_dy)。这将允许
    Docker 运行时自动选择与相应开发和部署环境的 OS 和架构匹配的镜像。
- en: For that, teams can use Docker’s [buildx tool](https://oreil.ly/XXDEy) to create
    multi-architecture images, ensuring that base images support multiple architectures,
    like ARM64 and AMD, across relevant operating systems—Linux, MacOS, Windows. Thorough
    testing in an environment mimicking the target production setup on CI/CD pipelines
    with multi-architecture build and test stages helps to ensure that the ML model
    runs seamlessly, regardless of the CPU chips being used in developers’ machines
    or production environments.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，团队可以使用Docker的[buildx工具](https://oreil.ly/XXDEy)创建多架构镜像，确保基础镜像支持多种架构，如ARM64和AMD，在相关操作系统——Linux、MacOS、Windows上。在模拟目标生产设置的CI/CD管道中进行全面测试，使用多架构的构建和测试阶段，有助于确保ML模型在开发人员机器或生产环境中使用的CPU芯片不同的情况下能够无缝运行。
- en: With OS-level dependencies under our belt, let’s now turn to tools for managing
    application-level dependencies.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有了操作系统级依赖，现在让我们转向管理应用级依赖的工具。
- en: Managing application-level dependencies
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理应用级依赖
- en: 'With application-level dependencies, it’s natural to feel overwhelmed by the
    plethora of tools in the Python ecosystem that seek to solve similar problems,
    just in different ways. Whichever tools you choose, *ensure that they work equally
    well in development and in production*. For example, while conda can be useful
    for development, it tends to be a large image (3–6 GB) with many dependencies
    that we don’t actually need. If you wanted to containerize and deploy your model
    as a web API, conda would be overkill and present an unnecessarily large attack
    surface area. If we were to use conda for development and another dependency manager
    for production, it would introduce: (i) training-serving asymmetry, and (ii) a
    fork in your dependency management solution, both of which need to be maintained.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用级依赖，面对Python生态系统中解决类似问题的众多工具，可能会感到不知所措，因为它们解决方式各异。无论您选择哪些工具，*确保它们在开发和生产中同样有效*。例如，虽然conda在开发中可能很有用，但它倾向于是一个大型镜像（3-6GB），具有许多我们实际上不需要的依赖。如果您想将模型容器化并部署为Web
    API，conda将会是过度解决方案，并且存在一个不必要的大攻击面积。如果我们在开发中使用conda，而在生产中使用另一个依赖管理器，将会引入：（i）训练和服务的不对称性，以及（ii）依赖管理解决方案的分歧，这两者都需要进行维护。
- en: 'In this chapter, we chose Poetry as our dependency manager because of its following
    benefits:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们选择了诗歌作为我们的依赖管理器，因为它有以下几个优点：
- en: Dependency pinning
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖固定
- en: Poetry’s dependency resolution feature will figure out the complete dependency
    tree, including transitive dependencies—i.e., dependencies of our dependencies—and
    generate a *poetry.lock* file that pins all dependencies. When we install dependencies,
    Poetry installs them with the versions specified in the lock file, and this prevents
    transitive dependencies from silently changing over time and sometimes [accidentally
    breaking our code](https://oreil.ly/dbwOW).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 诗歌的依赖解析功能将会计算出完整的依赖树，包括传递依赖——即我们依赖的依赖，并生成一个*poetry.lock*文件，固定所有依赖版本。当我们安装依赖时，诗歌会根据锁定文件中指定的版本安装它们，这可以防止传递依赖在时间推移中悄悄地改变，有时会[意外地破坏我们的代码](https://oreil.ly/dbwOW)。
- en: Installing dependencies automatically updates pyproject.toml
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 自动安装依赖项会更新pyproject.toml
- en: When we run `poetry add some-package`, Poetry will figure out what’s the latest
    compatible version that we can use, and automatically update *pyproject.toml*
    for us. We no longer have to manually figure out which version to specify when
    updating *requirements.txt*, or manually dig out the actual version number that
    was installed by running `pip list`!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`poetry add some-package`时，诗歌将找出我们可以使用的最新兼容版本，并自动为我们更新*pyproject.toml*。我们不再需要手动确定更新*requirements.txt*时要指定的版本，或者通过运行`pip
    list`手动找出实际安装的版本号！
- en: A single *pyproject.toml* dependency specification file
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 单一的*pyproject.toml*依赖规范文件
- en: Poetry’s [*pyproject.toml*](https://oreil.ly/CW6Ub) has a well-defined schema
    for defining production dependencies and development dependencies. It is also
    in line with [PEP 518](https://oreil.ly/yikrL), which is a Python Enhancement
    Proposal that introduced *pyproject.toml*, a file that would contain all build
    system dependencies for a given project.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 诗歌的[*pyproject.toml*](https://oreil.ly/CW6Ub)具有为定义生产依赖和开发依赖定义的明确定义的模式。它也符合[PEP
    518](https://oreil.ly/yikrL)，这是一个Python增强提案，引入了*pyproject.toml*，一个文件，它将包含给定项目的所有构建系统依赖。
- en: Packaging and publishing
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 打包和发布
- en: You can easily [publish your package](https://oreil.ly/AEPkG) to PyPI or to
    a private repository in a few commands.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地通过几个命令将您的包发布到 PyPI 或私有仓库。
- en: By this point, we’ve covered the key principles and tools for managing OS-level
    and application-level dependencies. In the next chapter, we’ll have a hands-on
    exercise to illustrate all of this. But for readers who are new to Docker and
    batect, we’d like to use the remainder of this chapter to provide a crash course
    on the what, where, when, and how of using containers in an ML workflow.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了管理操作系统级和应用程序级依赖项的关键原则和工具。在下一章中，我们将进行一个实践练习来说明所有这些内容。但对于对 Docker
    和 batect 还不熟悉的读者，我们希望利用本章剩余部分，为使用容器在 ML 工作流中的何时、何地、如何提供一个快速入门。
- en: A Crash Course on Docker and batect
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 和 batect 的快速入门
- en: In the first half of this section, we will describe the conceptual building
    blocks of working with Docker. Next, we’ll look at the common problem of needing
    to maintain a growing amount of “glue code” to coordinate growing lists of hand-typed
    Docker arguments and even multiple Dockerfiles. We’ll look at a command-line tool
    that solves that problem and simplifies how we interact with Docker—[batect](https://oreil.ly/Lt2ap).
    We’ll show you how you can use batect in your projects.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的上半部分，我们将描述使用 Docker 的概念构建块。接下来，我们将看到一个常见问题，即需要维护越来越多的“粘合代码”，以协调越来越多的手动输入的
    Docker 参数甚至多个 Dockerfile。我们将介绍一个命令行工具来解决这个问题，并简化我们与 Docker 的交互方式—[batect](https://oreil.ly/Lt2ap)。我们将向您展示如何在您的项目中使用
    batect。
- en: Let’s begin by going through the basic building blocks of working with Docker.
    We will explain some basic Docker concepts, but we won’t go into too much detail
    as there is already a wealth of [tutorials](https://oreil.ly/amr1g) and [guides](https://oreil.ly/vqtwh)
    that teach these concepts in an accessible manner. You can also skip ahead to
    the section on batect if you are familiar with Docker and containers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习使用 Docker 的基本构建块。我们将解释一些基本的 Docker 概念，但不会过多详细介绍，因为已经有大量[教程](https://oreil.ly/amr1g)和[指南](https://oreil.ly/vqtwh)以一种易于理解的方式教授这些概念。如果您对
    Docker 和容器已经很熟悉，也可以直接跳转到关于 batect 的部分。
- en: What Are Containers?
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器是什么？
- en: Think of a container as a running process—such as `echo "hello world"`, `python
    train.py`, or `python3 -m http.server`—that has all the dependencies it needs
    to run successfully.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 把容器想象成一个正在运行的进程—比如 `echo "hello world"`、`python train.py` 或 `python3 -m http.server`—它拥有运行所需的所有依赖项。
- en: The process code and its dependencies are captured in what we call an image.
    When we build an image—a lightweight, standalone, executable package of software
    that includes everything needed to run code—we specify everything that the process
    needs to run successfully.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 过程代码及其依赖被捕获在我们所称的镜像中。当我们构建一个镜像时—一个轻量级的、独立的、可执行的软件包，其中包括运行代码所需的一切—我们指定了进程成功运行所需的一切。
- en: When we *run* an image, we get a *container*. So, when we run our process or
    command as a container, it will always run successfully, even if the host machine
    is a “fresh box” that doesn’t have the dependencies we need, other than the Docker
    runtime.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们*运行*一个镜像时，我们得到一个*容器*。因此，当我们将我们的进程或命令作为容器运行时，它将始终成功运行，即使主机机器是一个“全新的盒子”，除了
    Docker 运行时没有我们需要的依赖项。
- en: 'For anyone new to containers, these terms may sound more daunting than they
    really are. If that’s you, we hope this analogy will help to simplify the concept
    of containers:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何对容器还不熟悉的人来说，这些术语可能听起来比实际情况更令人生畏。如果您是其中之一，我们希望这个类比能帮助简化容器概念：
- en: A not-so-relaxing afternoon without containers
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有容器的不那么轻松的下午
- en: 'Your friend lives in a tropical country and they tell you: put a chair outdoors,
    sit on it, and enjoy the nice, cool breeze. You live in a temperate country and
    it’s currently winter. You follow the exact same instructions but did not enjoy
    the same outcome as your friend.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你的朋友住在一个热带国家，他告诉你：在户外放一把椅子，坐在上面，享受凉爽的微风。你住在温带国家，现在是冬天。你按照完全相同的说明做了，但没有像你的朋友一样享受到相同的结果。
- en: A relaxing afternoon with containers
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与容器一起放松的下午
- en: 'Your friend lives somewhere in the world, and he bought a space pod with an
    air conditioner, puts a chair in it, sits on it, and enjoys the nice, cool breeze.
    The experience was so amazing that they immediately told you about it. It’s still
    winter for you, and you follow the exact same instructions: buy the exact same
    space pod, turn on the air conditioner, sit on a chair inside it, and enjoy the
    nice, cool breeze.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你的朋友住在世界的某个地方，他买了一个带空调的太空舱，放了一把椅子，坐在里面，享受着凉爽的微风。这种体验如此惊人，以至于他立即告诉了你。对你来说仍然是冬天，你按照完全相同的指示：购买同样的太空舱，打开空调，坐在里面的椅子上，享受凉爽的微风。
- en: That’s what containers do for our application—containers, like space pods, provide
    a deterministic runtime environment that decouples our code from the state of
    the operating system (or “bare metal” runtime).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是容器为我们的应用程序所做的事情——容器就像太空舱一样，提供了一个确定性运行环境，将我们的代码与操作系统（或“裸机”运行时）的状态分离开来。
- en: Now, let’s take a look at where Docker would fit in with various development
    machines and platforms.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Docker在各种开发机器和平台中的适用情况。
- en: 'The technologies that make up an ML practitioner’s development environment
    depend on several factors, such as personal experience, team preferences, organizational
    policies, and even regulatory constraints on where compute and data can exist.
    An ML practitioner could be developing on one of the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ML从业者的开发环境所使用的技术取决于多种因素，如个人经验、团队偏好、组织政策，甚至是关于计算和数据存放位置的法规限制。ML从业者可能正在以下之一进行开发：
- en: Local machines
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地机器
- en: Local machines that trigger jobs on the cloud or on a distributed cluster (e.g.,
    Kubeflow, Metaflow, Ray, AWS SageMaker, Google Vertex AI, Azure ML)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地机器上触发云端或分布式集群上的作业（例如Kubeflow、Metaflow、Ray、AWS SageMaker、Google Vertex AI、Azure
    ML）
- en: Ad hoc provisioned compute instances (e.g., AWS EC2 instances)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时配置的计算实例（例如AWS EC2实例）
- en: Cloud workspaces (e.g., GitHub Codespaces, AWS SageMaker Studio Notebooks, GCP
    Cloud Workstations)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云工作空间（例如GitHub Codespaces、AWS SageMaker Studio笔记本、GCP云工作站）
- en: On-premises compute instances
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地计算实例
- en: Embedded devices (e.g., Raspberry Pi)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式设备（例如树莓派）
- en: Regardless of which development environment you’re using, Docker can help you
    quickly create consistent runtime environments for your code on any of the above
    target environments, as long as the Docker runtime is available. Cloud ML services
    typically support Docker and will have documentation detailing how you can specify
    Docker images—both public images or your custom images—when running tasks or jobs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种开发环境，只要有Docker运行时可用，Docker都可以帮助你快速创建一致的运行环境，用于任何上述目标环境。云ML服务通常支持Docker，并会有文档详细说明如何在运行任务或作业时指定Docker镜像——无论是公共镜像还是自定义镜像。
- en: Reduce the Number of Moving Parts in Docker with batect
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少Docker中的移动部件使用batect
- en: As projects become more complex, we might find ourselves with a growing number
    of Docker runtime parameters and command-line options—such as volume mounts and
    ports to publish. And these configuration parameters often need to be maintained
    in multiple places in our codebase. We’ve seen teams maintain an ever-lengthening
    list of hand-typed Docker arguments, which they specify and synchronize across
    multiple places, such as in the README, CI/CD pipeline, Makefiles, and shell scripts.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目变得越来越复杂，我们可能会发现自己有越来越多的Docker运行时参数和命令行选项——比如挂载卷和需要发布的端口。这些配置参数通常需要在代码库的多个地方进行维护。我们看到团队在多个地方维护一长串手工输入的Docker参数列表，比如在README、CI/CD流水线、Makefiles和shell脚本中进行指定和同步。
- en: To complicate the picture further, we may also have multiple containers that
    need to communicate with each other, run in a specific sequence, or even multiple
    Dockerfiles for multiple tasks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步复杂的是，我们可能还有多个需要彼此通信、按特定顺序运行的容器，甚至多个用于多个任务的Docker文件。
- en: 'The good news is: We can simplify all these moving parts with [batect](https://oreil.ly/Lt2ap)—a
    command-line tool that lets us (i) define our development tasks alongside their
    associated configuration parameters as a single source of truth in a config file,
    and (ii) run Docker containers as batect tasks.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是：我们可以通过[batect](https://oreil.ly/Lt2ap)来简化所有这些移动部件——这是一个命令行工具，让我们可以 (i)
    在配置文件中定义开发任务及其关联的配置参数作为唯一的真实数据源，以及 (ii) 将Docker容器作为batect任务运行。
- en: Let’s look at four benefits of using batect in our ML development lifecycle.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在我们的ML开发生命周期中使用batect的四个好处。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A few months after we wrote this chapter, batect’s creator and maintainer announced
    that [batect will no longer be maintained](https://oreil.ly/ZyMrQ). Any existing
    projects using batect will continue to work—and have continued to work in the
    code-along repositories for this book. But batect will no longer receive new features,
    bug fixes, or security fixes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编写本章几个月后，batect 的创建者和维护者宣布[batect 将不再维护](https://oreil.ly/ZyMrQ)。使用 batect
    的现有项目将继续运行，并且在本书的代码库中也将继续运行。但是 batect 将不再获得新功能、错误修复或安全修复。
- en: Nevertheless, batect continues to be a useful abstraction on top of Docker (as
    we’ll elaborate on in this chapter).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，batect 在 Docker 的基础上继续作为一个有用的抽象（正如我们将在本章中详细阐述的那样）。
- en: 'Benefit 1: Simpler command-line interface'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点 1：更简单的命令行界面
- en: 'When working with Docker, it’s common to end up with Docker commands peppered
    with many invocation parameters—e.g., environment variables, volume mount folders,
    ports to publish—that are used in multiple places, all of which need to be kept
    in sync. Below is an example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Docker 时，通常会遇到很多调用参数的 Docker 命令，例如环境变量、卷挂载文件夹、需要发布的端口等，这些参数在多个地方使用，都需要保持同步。下面是一个例子：
- en: '[PRE1]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Apart from specifying these commands in the README, we would also need to specify
    them wherever we want to run these commands, such as in bash scripts or CI pipelines.
    If we were to change an option (e.g., volume mount directory), we would need to
    change it in multiple places. This violates the DRY principle (Don’t Repeat Yourself)
    and we have to take on the toil of manually keeping these commands in sync, and
    the consequences of accidental inconsistencies.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 README 中指定这些命令之外，我们还需要在任何需要运行这些命令的地方（如 bash 脚本或 CI 管道）指定它们。如果我们要更改一个选项（例如，卷挂载目录），我们需要在多个地方进行更改。这违反了
    DRY 原则（不要重复自己），我们必须手动保持这些命令的同步，并承担意外不一致的后果。
- en: 'In contrast, batect lets us maintain these configuration parameters in a configuration
    file, as below, which serves as a single source of truth:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，batect 允许我们在配置文件中维护这些配置参数，如下所示，这个文件作为唯一的真实来源：
- en: '[PRE2]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![](assets/1.png)](#code_id_3_1)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](assets/1.png)](#code_id_3_1)'
- en: Notice how batect simplifies how we invoke the same `docker run` command.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 batect 如何简化我们调用相同的 `docker run` 命令的方式。
- en: '[![](assets/2.png)](#code_id_3_2)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](assets/2.png)](#code_id_3_2)'
- en: Batect allows us to define *containers* and *tasks* in a configuration file
    (*batect.yml*). All the Docker options we typically pass to `docker build` and
    all the `docker run` commands, along with their various options, are now defined
    “as code” in *batect.yml*. We can start a container simply by executing a batect
    task (e.g., `./batect train-model`). *Batect.yml* becomes a single source of truth
    for these tasks, and if we were to change an option (e.g., `environment = 'staging'`
    or `'production'`), we would only need to change it in one place.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Batect 允许我们在配置文件（*batect.yml*）中定义*容器*和*任务*。我们可以在*batect.yml*中定义所有通常传递给`docker
    build`和`docker run`命令的Docker选项及其各种选项。通过执行一个 batect 任务（例如，`./batect train-model`），我们可以简单地启动一个容器。*Batect.yml*成为这些任务的单一真实来源，如果我们要更改一个选项（例如，`environment
    = 'staging'`或`'production'`），我们只需要在一个地方进行更改。
- en: '[![](assets/3.png)](#code_id_3_3)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](assets/3.png)](#code_id_3_3)'
- en: You can name this container to be anything you want. It doesn’t have to be `dev`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此容器命名为任何您想要的名称。它不必是`dev`。
- en: 'Benefit 2: Simple task composition'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点 2：简单的任务组合
- en: 'Let’s consider a scenario where we need to run a task (e.g., train a model)
    before we can run another task (e.g., run API test). On a fresh instance (e.g.,
    on CI), if we were to directly run the API test, it would fail because the model
    artifact hasn’t been created yet. Let’s see how we would do this without batect:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，我们需要在运行另一个任务（例如，运行 API 测试）之前运行一个任务（例如，训练模型）。在一个新的实例上（例如，CI 上），如果我们直接运行
    API 测试，它会失败，因为模型文件尚未创建。让我们看看如果没有 batect 我们将如何做到这一点：
- en: '[PRE4]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to run API tests on our CI/CD pipeline, we would need to specify both
    of these somewhat verbose commands. Teams typically wrap these up in bash scripts
    to encapsulate this logic and hide the verbosity of these commands.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的 CI/CD 管道上运行 API 测试，我们需要指定这两个有些冗长的命令。团队通常会将它们封装在 bash 脚本中，以封装这些逻辑并隐藏这些命令的冗长性。
- en: 'Now let’s see how we’d do the same task with batect:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用 batect 执行相同的任务：
- en: '[PRE5]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![](assets/1.png)](#code_id_3_4)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](assets/1.png)](#code_id_3_4)'
- en: batect helps us simplify this with the `prerequisites` option. On our CI/CD
    pipeline, we can just specify `./batect api-test` and batect will take care of
    running the prerequisite task (`smoke-test-model-training`) before running the
    API tests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: batect 帮助我们通过 `prerequisites` 选项简化了这一过程。在我们的 CI/CD 流水线上，我们只需指定 `./batect api-test`，batect
    将负责在运行 API 测试之前运行先决任务（`smoke-test-model-training`）。
- en: 'Now that we’ve seen how batect helps us keep `docker run` commands simple,
    consistent, and in one place, let’s look at another benefit of batect: Local-CI
    symmetry.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 batect 如何帮助我们保持 `docker run` 命令简单、一致且集中于一个地方，让我们再看一看 batect 的另一个好处：本地-CI
    对称性。
- en: 'Benefit 3: Local-CI symmetry'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优势 3：本地-CI 对称性
- en: Without batect, each step on CI will be a verbose implementation detail (for
    example, `docker run -it --rm -v $(pwd):/code loan-default-⁠prediction:​dev ./scripts/train-model.sh`.)
    This makes it harder to read and keep track of what’s going on.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 batect，CI 中的每一步都将是冗长的实现细节（例如，`docker run -it --rm -v $(pwd):/code loan-default-⁠prediction:​dev
    ./scripts/train-model.sh`）。这使得阅读和跟踪正在进行的操作变得更加困难。
- en: 'In contrast, batect lets us keep our CI/CD pipeline concise and easy to understand.
    In the following code sample, it’s apparent that we’re running three commands:
    `smoke-test-model-training`, `api-test`, and `train-model`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，batect 让我们的 CI/CD 流水线简洁且易于理解。在以下代码示例中，很明显我们运行了三个命令：`smoke-test-model-training`、`api-test`
    和 `train-model`：
- en: '[PRE7]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This also helps us easily reproduce failures that happened in CI. Should a task
    fail on CI (e.g., `api-test`), we can easily reproduce errors locally by running
    the exact same command that we asked CI to run (e.g., `./batect api-test`) and
    iterate on a bug fix. We no longer have to manually corral a hodgepodge of commands,
    arguments, and environment variables scattered across CI/CD pipeline specifications
    and shell scripts.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这还帮助我们轻松重现在 CI 中发生的失败。如果 CI 中的任务失败（例如，`api-test`），我们可以通过运行我们要求 CI 运行的完全相同的命令（例如，`./batect
    api-test`）轻松地在本地重现错误，并迭代修复 bug。我们不再需要手动整理分散在 CI/CD 流水线规范和 shell 脚本中的各种命令、参数和环境变量。
- en: 'Benefit 4: Faster builds with caches'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优势 4：使用缓存加速构建
- en: One key challenge when using Docker in ML projects is long build times due to
    the time spent on downloading and installing large Python packages (e.g., `torch==1.13.1`
    is 500 MB), large pretrained models (e.g., llama-2-7b is 13 GB), and large datasets.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习项目中使用 Docker 的一个关键挑战是由于下载和安装大型 Python 包（例如，`torch==1.13.1` 为 500 MB）、大型预训练模型（例如，llama-2-7b
    为 13 GB）和大型数据集所花费的时间，导致构建时间很长。
- en: Docker comes with [build-time caching mechanisms](https://oreil.ly/Szm18), which
    can help you save several minutes for each fresh build. By adding the bold lines
    below, we can avoid unnecessary redownloads and reinstallation, and reduce the
    time taken to build our image. Even for the fairly vanilla dependencies that we
    are using in this example, we shortened the build time from three minutes to just
    under two minutes. The time savings would be more significant in projects where
    we download larger dependencies, pretrained models, and datasets.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供了[构建时缓存机制](https://oreil.ly/Szm18)，可以帮助您在每次新构建时节省数分钟的时间。通过添加下面的粗体行，我们可以避免不必要的重新下载和重新安装，并减少构建镜像所需的时间。即使对于我们在本示例中使用的相对简单的依赖项，我们也将构建时间从三分钟缩短到不到两分钟。在下载更大的依赖项、预训练模型和数据集的项目中，节省的时间将更为显著。
- en: '[PRE8]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Strictly speaking, you don’t need batect to realize the benefits of Docker
    caches. However, we find that batect’s interface for defining caches—and invalidating
    caches, where necessary—is easier to use. The following code sample shows how
    we would implement the same caches, but this time using batect:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，您并不需要 batect 来实现 Docker 缓存的好处。然而，我们发现 batect 用于定义缓存及在必要时使其无效的接口更易于使用。以下代码示例展示了我们如何使用
    batect 实现相同的缓存：
- en: '[PRE9]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![](assets/1.png)](#code_id_3_5)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](assets/1.png)](#code_id_3_5)'
- en: This is how we define and add a cache volume. In addition to dependencies, you
    can also cache other downloaded artifacts, such as pretrained models and data.
    The ability to name the cache volume makes it easier to understand what’s going
    on, as well.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何定义并添加缓存卷。除了依赖项之外，您还可以缓存其他下载的工件，例如预训练模型和数据。命名缓存卷的能力使得理解正在发生的情况变得更加容易。
- en: '[![](assets/2.png)](#code_id_3_6)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](assets/2.png)](#code_id_3_6)'
- en: Notice how our Dockerfile is now back to how it was prior to adding caches and
    is now easier to understand.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的 Dockerfile 现在回到了添加缓存之前的状态，现在更易于理解。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you encounter any errors relating to stale or corrupted caches when you’re
    running a command, you can simply delete the cache and try to command again:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行命令时遇到与陈旧或损坏缓存有关的错误，请简单删除缓存并尝试重新运行命令：
- en: 'To [clear the cache using batect](https://oreil.ly/Iprov), you can run the
    following command:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要通过 batect [清除缓存](https://oreil.ly/Iprov)，您可以运行以下命令：
- en: '[PRE11]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To [clear the cache using Docker](https://oreil.ly/5r-Uu), you can run the
    following command:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要通过 Docker [清除缓存](https://oreil.ly/5r-Uu)，您可以运行以下命令：
- en: '[PRE12]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we use containers without specifying any caches, we often find ourselves
    wasting significant amounts of time waiting. In the ML tech stacks that we’ve
    worked with, we’ve waited between 3–10 minutes for various images to build locally
    or on CI. When given a choice between staring blankly at a screen and context
    switching to do something else while waiting, we sometimes choose the latter to
    feel “productive.” But the irony is that this context switching leads to more
    open threads, more mental exhaustion, and lower productivity. With just a few
    lines of YAML configuration in batect, we can reduce wait time and its associated
    costs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在不指定任何缓存的情况下使用容器，我们经常会发现自己在等待中浪费了大量时间。在我们使用的 ML 技术栈中，我们等待各种镜像在本地或 CI 中构建的时间介于
    3 到 10 分钟之间。当面对选择在屏幕前发呆还是在等待时做些其他事情时，我们有时会选择后者以感到“有效率”。但讽刺的是，这种上下文切换会导致更多的未完成任务、更多的精神疲劳和更低的生产力。通过在
    batect 的少量 YAML 配置中，我们可以减少等待时间及其相关成本。
- en: How to use batect in your projects
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何在你的项目中使用 batect
- en: Batect is [easy to install](https://oreil.ly/sOQuW), and integrates well with
    common CI platforms such as [GitHub Actions](https://oreil.ly/kcHL9) and [CircleCI](https://oreil.ly/QWcCV).
    Batect offers two simple abstractions—[containers](https://oreil.ly/A5ijI) and
    [tasks](https://oreil.ly/3lPZm)—and supports everything that you can do through
    the Docker client (e.g., mount volumes, publish ports, entry points). In the next
    chapter, we will demonstrate what a Dockerized and “batect-ized” project looks
    like.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Batect [易于安装](https://oreil.ly/sOQuW)，并与常见的 CI 平台如 [GitHub Actions](https://oreil.ly/kcHL9)
    和 [CircleCI](https://oreil.ly/QWcCV) 集成良好。Batect 提供两个简单的抽象——[容器](https://oreil.ly/A5ijI)
    和 [任务](https://oreil.ly/3lPZm)，支持通过 Docker 客户端进行的所有操作（例如挂载卷、发布端口、入口点）。在下一章中，我们将展示一个
    Docker 化和“batect 化”的项目是什么样子。
- en: If you wish to explore batect further, the documentation is comprehensive and
    includes a [getting started guide](https://oreil.ly/tDD9s), [*batect.yml* configuration
    reference](https://oreil.ly/xxGO6), and [guides on how to use it with CI systems](https://oreil.ly/XWnNU).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望进一步探索 batect，文档内容详尽，包括[入门指南](https://oreil.ly/tDD9s)，[*batect.yml* 配置参考](https://oreil.ly/xxGO6)，以及[如何在
    CI 系统中使用的指南](https://oreil.ly/XWnNU)。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'A counterargument that we commonly hear is: Instead of introducing a new tool,
    why not use Docker Compose? The reason is: Docker Compose is designed for running
    and orchestrating *long-lived* processes, and it also does not allow you to run
    a subset of specific tasks or containers. For example, docker-compose up will
    start all the services specified in *docker-compose.yml*. In contrast, batect
    supports both running long-lived and short-lived processes, and is better suited
    for defining containerized tasks that we run locally and on the CI/CD pipeline
    in the ML development lifecycle.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常听到的一个反驳是：为什么要引入新工具，而不使用 Docker Compose？原因在于：Docker Compose 设计用于运行和编排*长期存在*的进程，而且不允许你运行特定任务或容器的子集。例如，docker-compose
    up 将启动*docker-compose.yml*中指定的所有服务。相比之下，batect 支持长期运行和短期任务，并更适合在 ML 开发生命周期中定义本地和
    CI/CD 管道中运行的容器化任务。
- en: Now that we are equipped with the principles and tools for effective dependency
    management, let’s recap what we’ve learned in this chapter, before we jump into
    a practical hands-on example in the next chapter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了有效的依赖管理原则和工具，让我们在进入下一章的实际操作示例之前，回顾一下本章学到的内容。
- en: Conclusion
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'Give yourself a massive pat on your back because you’ve just covered a lot
    of ground in one chapter! To recap, in this chapter, we covered:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请给自己一个巨大的鼓励，因为你在一章节中涵盖了很多内容！总结一下，在本章中，我们讨论了：
- en: How to recognize an incomplete dependency management approach
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何识别不完整的依赖管理方法
- en: Principles and tools enabling the practice of “check out and go” in ML projects
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ML 项目中实现“检出并运行”的原则和工具
- en: When, why, and how to use containers
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当、为什么以及如何使用容器
- en: How to simplify the definition and invocation of Docker commands with batect
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过batect简化Docker命令的定义和调用
- en: The irony of dependency management is that it’s a solved problem in the software
    engineering world, yet it continues to be a common pitfall in the world of ML.
    Perhaps this is due to an overwhelming array of tools, the strong pull (in many
    directions) of entrenched legacy practices, and the lack of a standardized approach
    on dependency management in the Python ecosystem.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖管理的讽刺在于，在软件工程界它已经是一个解决了的问题，然而在机器学习领域它仍然是一个常见的陷阱。也许这是由于大量的工具、根深蒂固的传统实践的强烈影响（在多个方向上）以及Python生态系统中依赖管理的标准化方法的缺乏。
- en: Whatever the reason may be, in our experience, the ML dependency management
    toolchain is at a mature state, and teams can create runtime environments reliably
    and reproducibly in experimentation, development, and production with these principles
    and practices.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 不管原因是什么，在我们的经验中，机器学习依赖管理工具链处于成熟阶段，团队可以使用这些原则和实践在实验、开发和生产中可靠、可重现地创建运行时环境。
- en: On that note, it’s time for the most exciting part of this topic—a hands-on
    example to demonstrate what effective dependency management could look like in
    practice! See you in the next chapter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，现在是这个话题中最令人兴奋的部分——一个实际操作示例来展示有效的依赖管理在实践中是什么样子！在下一章见。
- en: ^([1](ch03.html#ch01fn21-marker)) “Snowflake” environments refer to environments
    that are manually or partially manually created and configured. Like snowflakes,
    no two snowflake environments are identical.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#ch01fn21-marker)) “雪花”环境指的是手动或部分手动创建和配置的环境。就像雪花一样，没有两个雪花环境是完全相同的。
