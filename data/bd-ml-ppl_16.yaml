- en: Appendix A. Introduction to Infrastructure for Machine Learning
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 A. 机器学习基础设施简介
- en: 'This appendix gives a brief introduction to some of the most useful infrastructure
    tools for machine learning: containers, in the form of Docker or Kubernetes. While
    this may be the point at which you hand your pipeline over to a software engineering
    team, it’s useful for anyone building machine learning pipelines to have an awareness
    of these tools.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录简要介绍了一些最有用的机器学习基础设施工具：以 Docker 或 Kubernetes 的形式的容器。虽然这可能是您将流水线交给软件工程团队的时候，但对于任何构建机器学习流水线的人来说，了解这些工具是非常有用的。
- en: What Is a Container?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是容器？
- en: All Linux operating systems are based on the filesystem, or the directory structure
    that includes all hard drives and partitions. From the root of this filesystem
    (denoted as `/`), you can access almost all aspects of a Linux system. Containers
    create a new, smaller root and use it as a “smaller Linux” within a bigger host.
    This lets you have a whole separate set of libraries dedicated to a particular
    container. On top of that, containers let you control resources like CPU time
    or memory for each container.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Linux 操作系统都基于文件系统，或包括所有硬盘和分区的目录结构。从这个文件系统的根目录（表示为 `/`）可以访问几乎所有 Linux 系统的方面。容器创建一个新的、更小的根目录，并将其用作在更大的主机内部的“小型
    Linux”。这使您可以拥有一整套专用于特定容器的库。此外，容器还允许您控制每个容器的 CPU 时间或内存等资源。
- en: Docker is a user-friendly API that manages containers. Containers can be built,
    packaged, saved, and deployed multiple times using Docker. It also allows developers
    to build containers locally and then publish them to a central registry that others
    can pull from and immediately run the container.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一个用户友好的 API，用于管理容器。使用 Docker 可以多次构建、打包、保存和部署容器。它还允许开发者在本地构建容器，然后发布到一个中央注册表，其他人可以从中拉取并立即运行容器。
- en: Dependency management is a big issue in machine learning and data science. Whether
    you are writing in R or Python, you’re almost always dependent on third-party
    modules. These modules are updated frequently and may cause breaking changes to
    your pipeline when versions conflict. By using containers, you can prepackage
    your data processing code along with the correct module versions and avoid these
    problems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖管理在机器学习和数据科学中是一个重大问题。无论您是在 R 还是 Python 中编写代码，几乎总是依赖于第三方模块。这些模块经常更新，可能会在版本冲突时对您的流水线造成破坏性变化。通过使用容器，您可以预先打包您的数据处理代码以及正确的模块版本，避免这些问题。
- en: Introduction to Docker
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 简介
- en: To install Docker on Mac or Windows, visit [https://docs.docker.com/install](https://docs.docker.com/install)
    and download the latest stable version of Docker Desktop for your operating system.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Mac 或 Windows 上安装 Docker，请访问 [https://docs.docker.com/install](https://docs.docker.com/install)，并下载适合您操作系统的最新稳定版
    Docker Desktop。
- en: 'For a Linux operating system, Docker provides a very convenient script to install
    Docker with just a couple of commands:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 操作系统，Docker 提供了一个非常方便的脚本，只需几个命令即可安装 Docker：
- en: '`$` `curl -fsSL https://get.docker.com -o get-docker.sh` `$` `sudo sh get-docker.sh`'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$` `curl -fsSL https://get.docker.com -o get-docker.sh` `$` `sudo sh get-docker.sh`'
- en: 'You can test whether your Docker installation is working correctly using the
    command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令测试 Docker 安装是否正常工作：
- en: '`docker run hello-world`'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run hello-world`'
- en: Introduction to Docker Images
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像简介
- en: A Docker image is the basis of a container, and it consists of a collection
    of changes to the root filesystem and the execution parameters to run the container.
    The image must first be “built” before it can be run.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像是容器的基础，由对根文件系统的一系列更改和运行容器的执行参数组成。在运行之前，必须先“构建”镜像。
- en: 'A useful concept behind Docker images is storage layers. Building an image
    means installing almost a whole dedicated Linux OS for your package. To avoid
    running this operation every time, Docker uses a layered filesystem. Here is how
    it works: if the first layer contains Files A and B, and the second layer adds
    File C, the resulting filesystems show A, B, and C. If we want to create a second
    image that uses Files A, B, and D, we only need to change the second layer to
    add File D. This means that we can have base images that have all the basic packages,
    and then we can focus on changes specific to your image, as shown in [Figure A-1](#filepos1609829).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像背后一个有用的概念是存储层。构建镜像意味着为您的包安装一个几乎完整的专用 Linux 操作系统。为了避免每次都运行这个操作，Docker
    使用了一个分层文件系统。其工作方式如下：如果第一层包含文件 A 和 B，第二层添加文件 C，结果的文件系统会显示 A、B 和 C。如果我们想创建第二个使用文件
    A、B 和 D 的镜像，只需要更改第二层以添加文件 D。这意味着我们可以有基础镜像拥有所有基本软件包，然后我们可以专注于针对您的镜像的特定更改，如[图 A-1](#filepos1609829)所示。
- en: '![](images/00109.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00109.jpg)'
- en: Figure A-1\. Example of a layered filesystem
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A-1\. 分层文件系统示例
- en: Docker image names are called tags. They follow the pattern `docker registry``/``docker
    namespace``/``image name``:``tag`. For example, docker.io/tensorflow/tensorflow:nightly
    would point to the `tensorflow` image in DockerHub in the `tensorflow` namespace.
    The tag is usually used to mark versions of a particular image. In our example,
    the tag `nightly` is reserved for nightly builds of TensorFlow.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像名称称为标签。它们遵循模式`docker registry``/``docker 命名空间``/``镜像名称``:``标签`。例如，docker.io/tensorflow/tensorflow:nightly
    将指向 DockerHub 中 `tensorflow` 命名空间中的 `tensorflow` 镜像。标签通常用于标记特定镜像的版本。在我们的示例中，标签
    `nightly` 保留用于 TensorFlow 的每夜构建版本。
- en: 'Docker images are built based on a `Dockerfile`. Each line in a Dockerfile
    starts with one of a few clauses. The most important are:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像是根据`Dockerfile`构建的。Dockerfile 中的每一行都以几个子句之一开头。最重要的是：
- en: '`FROM`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`'
- en: Indicates the Docker base container to build from. We will always want to use
    this clause. There are many base containers available to download, such as `ubuntu`.
  id: totrans-20
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指示要构建的 Docker 基础容器。我们总是需要使用这个子句。可以下载许多基础容器，比如`ubuntu`。
- en: '`RUN`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`'
- en: Runs bash. This is the bread and butter of most Docker images. This is where
    we want to do package installations, directory creation, etc. Because each line
    will create a layer in the image, it’s good to have package installations and
    other long tasks as one of the first lines in Dockerfile. This means that during
    rebuilds, Docker will try to use layers from the cache.
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行 bash。这是大多数 Docker 镜像的核心。在这里，我们希望执行包安装、目录创建等操作。因为每行操作都会在镜像中创建一个层，所以最好将包安装和其它的长时间任务作为
    Dockerfile 中的最前面行之一。这意味着在重建过程中，Docker 将尝试使用缓存中的层。
- en: '`ARG`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARG`'
- en: Builds arguments. It’s useful if you want to have multiple flavors of the same
    image, for example dev and production.
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建参数。如果您想要拥有同一镜像的多个版本，比如开发和生产版本，这很有用。
- en: '`COPY`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`'
- en: Copies files from a context. The path to the context is an argument used in
    `docker build`. The context is a set of local files that are exposed to Docker
    during the build, and it only uses them in the process. This can be used to copy
    your source code to a container.
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从上下文中复制文件。上下文路径是`docker build`中使用的参数。上下文是一组本地文件，在构建过程中会暴露给 Docker，它只在过程中使用这些文件。这可以用来将源代码复制到容器中。
- en: '`ENV`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV`'
- en: Sets an environment variable. This variable will be part of the image and will
    be visible in build and run.
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 设置环境变量。这个变量将成为镜像的一部分，将在构建和运行中可见。
- en: '`CMD`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`'
- en: This is the default command for a container. A good practice in Docker is to
    run one command per container. Docker will then monitor this command, exit when
    it exits, and post STDOUT from it to `docker logs`. Another way to specify this
    command is by using `ENTRYPOINT`. There are several subtle differences between
    these, but here we’ll focus on `CMD`.
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是容器的默认命令。在 Docker 中的一个良好实践是每个容器运行一个命令。Docker 将监视该命令，当命令退出时退出，并将其标准输出（STDOUT）发布到`docker
    logs`。指定此命令的另一种方法是使用 `ENTRYPOINT`。这两者之间有几个细微差别，但这里我们将关注`CMD`。
- en: '`USER`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`用户`'
- en: The default user in the container. This is different from host system users.
    You should create a user during the build if you want to run commands as one.
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 容器中的默认用户。这与主机系统用户不同。如果要以某个用户身份运行命令，则应在构建过程中创建该用户。
- en: '`WORKDIR`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`工作目录`'
- en: The default directory in the image. This will be the directory the default command
    will be run from.
  id: totrans-34
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图像中的默认目录。这将是执行默认命令的目录。
- en: '`EXPOSE`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`暴露`'
- en: Specifies ports the container will use. For example, HTTP services should have
    `EXPOSE 80`.
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指定容器将使用的端口。例如，HTTP 服务应该有 `EXPOSE 80`。
- en: Building Your First Docker Image
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 构建你的第一个 Docker 镜像
- en: Let’s build our first image!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来构建我们的第一个镜像！
- en: 'First, we need to create a new directory for our small Docker project:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的小型 Docker 项目创建一个新目录：
- en: '`$` `mkdir hello-docker` `$` `cd` `hello-docker`'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$` `mkdir hello-docker` `$` `cd` `hello-docker`'
- en: 'In this directory, create a file called Dockerfile with the following contents:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个目录中，创建一个名为 Dockerfile 的文件，内容如下：
- en: '`FROM ubuntu RUN apt-get update RUN apt-get -y install cowsay CMD /usr/games/cowsay`
    `"Hello Docker"`'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM ubuntu RUN apt-get update RUN apt-get -y install cowsay CMD /usr/games/cowsay`
    `"Hello Docker"`'
- en: To build it, use the command `docker build . -t hello-docker`. The `-t` flag
    specifies the tag for this image. You will see a series of commands that are run
    in the container. Each layer in our image (corresponding to each command in the
    `Dockerfile`) is called in the temporary container running the previous layers.
    The difference is saved, and we end up with a full image. The first layer (which
    we don’t build) is based on Ubuntu Linux. The `FROM` command in `Dockerfile` tells
    Docker to pull this image from a registry, in our case DockerHub, and use it as
    the base image.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建它，使用命令 `docker build . -t hello-docker`。`-t` 标志指定了这个镜像的标签。你会看到一系列在容器中运行的命令。我们镜像中的每一层（对应于
    `Dockerfile` 中的每个命令）在上一个层的临时容器中被调用。差异被保存下来，最终得到一个完整的镜像。第一层（我们不构建的那一层）基于 Ubuntu
    Linux。`Dockerfile` 中的 `FROM` 命令告诉 Docker 从注册表（在我们的情况下是 DockerHub）拉取这个镜像，并将其作为基础镜像使用。
- en: 'After the build is finished, calling `docker images` should show something
    like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，调用 `docker images` 应该显示类似以下的内容：
- en: '`REPOSITORY      TAG        IMAGE ID          CREATED          SIZE hello-docker   
    latest     af856e494ed4      2 minutes ago    155MB ubuntu          latest    
    94e814e2efa8      5 weeks ago      88.9MB`'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`REPOSITORY      TAG        IMAGE ID          CREATED          SIZE hello-docker   
    latest     af856e494ed4      2 minutes ago    155MB ubuntu          latest    
    94e814e2efa8      5 weeks ago      88.9MB`'
- en: We should see the base Ubuntu image and our new image.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能看到基础 Ubuntu 镜像和我们的新镜像。
- en: Even though we have built this image, that doesn’t mean it’s ready to use. The
    next step is to run the image. `docker run` is arguably the most important command
    in Docker. It creates a new container from an existing image (or, if an image
    is not present on the system, it will try to pull it from the registry). To run
    our image, we should call `docker run -it hello-docker`. This should show us the
    output of our `cowsay` command.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们已经构建了这个镜像，这并不意味着它已经可以使用了。下一步是运行这个镜像。`docker run` 可能是 Docker 中最重要的命令。它从现有镜像创建一个新容器（或者，如果系统上不存在镜像，则尝试从注册表拉取）。为了运行我们的镜像，我们应该调用
    `docker run -it hello-docker`。这应该显示我们的 `cowsay` 命令的输出。
- en: DOCKER REGISTRIES
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 注册表
- en: One of the great strengths of Docker is the ease of publishing a built image.
    The repository of Docker images is called the registry. The default Docker registry,
    called DockerHub, is supported by Docker, Inc. An account on DockerHub is free
    and lets you push public images to it.
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 的一个重要优势之一是方便地发布构建好的镜像。Docker 镜像的存储库称为注册表。默认的 Docker 注册表叫做 DockerHub，由
    Docker, Inc. 支持。在 DockerHub 上注册账号是免费的，并且允许你将公共镜像推送到上面。
- en: Diving into the Docker CLI
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解 Docker CLI
- en: The Docker CLI is the main way to interact with images and containers on your
    local machine. In this section, we’ll discuss the most important commands and
    options for it. Let’s start with `docker run`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Docker CLI 是在本地机器上与镜像和容器交互的主要方式。在本节中，我们将讨论它的最重要的命令和选项。让我们从 `docker run` 开始。
- en: 'There are many important options we could pass to `docker run`. With these,
    we can override most of the options set in the `Dockerfile`. This is important
    because many Docker images will have a set basic default command, but often that’s
    not exactly how we want to run them. Let’s look at our `cowsay` example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递许多重要的选项给 `docker run`。通过这些选项，我们可以覆盖 `Dockerfile` 中设置的大多数选项。这很重要，因为许多 Docker
    镜像会有一个基本的默认命令，但通常这并不完全符合我们的运行需求。让我们来看看我们的 `cowsay` 示例：
- en: '`docker run -it hello-docker /usr/games/cowsay` `"Our own message"`'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -it hello-docker /usr/games/cowsay` `"Our own message"`'
- en: 'The argument that comes after the image tag will override the default command
    we have set in `Dockerfile`. This is the best way to specify our own command-line
    flags to the default binaries. Other useful flags for `docker run` include:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图像标记之后的参数将覆盖我们在 `Dockerfile` 中设置的默认命令。这是指定我们自己的命令行标志给默认二进制文件的最佳方式。`docker run`
    的其他有用标志包括：
- en: '`-it`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`-it`'
- en: Means “interactive” (i) and `tty` (t), which allows us to interact with the
    command being run from our shell.
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 意味着 “交互式”（i）和 `tty`（t），允许我们与从我们的 shell 运行的命令进行交互。
- en: '`-v`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v`'
- en: Mounts a Docker volume or host directory into the container—for example, a directory
    containing datasets.
  id: totrans-58
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 Docker 卷或主机目录挂载到容器中，例如包含数据集的目录。
- en: '`-e`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`-e`'
- en: Passes configurations through environment variables. For example, `docker run
    -e MYVARNAME=value image` will create the `MYVARNAME` env variable in a container.
  id: totrans-60
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过环境变量传递配置。例如，`docker run -e MYVARNAME=value image` 将在容器中创建 `MYVARNAME` 环境变量。
- en: '`-d`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`'
- en: Allows the container to be run in detached mode, making it perfect for long
    running tasks.
  id: totrans-62
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 允许容器以分离模式运行，非常适合长时间运行的任务。
- en: '`-p`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`'
- en: Forwards a host’s port to a container to allow external services to interact
    with the container over a network. For example, `docker run -d -p 8080:8080 imagename`
    would forward `localhost:8080` to the container’s port 8080.
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将主机端口转发到容器，以允许外部服务通过网络与容器交互。例如，`docker run -d -p 8080:8080 imagename` 将主机的 `localhost:8080`
    转发到容器的端口 8080。
- en: DOCKER COMPOSE
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DOCKER COMPOSE
- en: '`docker run` can get pretty complex when you start mounting directories, managing
    container links, and so on. Docker Compose is a project to help with that. It
    allows you to create a docker-compose.yaml file in which you can specify all your
    Docker options for any number of containers. You can then link containers together
    over a network or mount the same directories.'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你开始挂载目录、管理容器链接等时，`docker run` 可以变得相当复杂。Docker Compose 是一个项目，旨在帮助处理这些问题。它允许你创建一个
    `docker-compose.yaml` 文件，在其中可以为任意数量的容器指定所有 Docker 选项。然后，你可以通过网络连接容器，或者挂载相同的目录。
- en: 'Other useful Docker commands include:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的 Docker 命令包括：
- en: '`docker ps`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps`'
- en: Shows all the running containers. To also show exited containers, add the `-a`
    flag.
  id: totrans-69
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 显示所有正在运行的容器。若要显示已退出的容器，添加 `-a` 标志。
- en: '`docker images`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker images`'
- en: Lists all images present on the machine.
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列出机器上存在的所有镜像。
- en: '`docker inspect container id`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker inspect 容器ID`'
- en: Allows us to examine the container’s configuration in detail.
  id: totrans-73
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 允许我们详细检查容器的配置。
- en: '`docker rm`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker rm`'
- en: Deletes containers.
  id: totrans-75
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 删除容器。
- en: '`docker rmi`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker rmi`'
- en: Deletes images.
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 删除镜像。
- en: '`docker logs`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker logs`'
- en: Displays the STDOUT and STDERR information produced by a container, which is
    very useful for debugging.
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 显示容器产生的 STDOUT 和 STDERR 信息，非常有助于调试。
- en: '`docker exec`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker exec`'
- en: Allows you to call a command within a running container. For example, `docker
    exec -it` `container id` `bash` will allow you to enter into the container environment
    with bash and examine it from inside. The `-it` flag works in the same way as
    in `docker run`.
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 允许你在运行的容器内部调用命令。例如，`docker exec -it 容器ID bash` 允许你使用 bash 进入容器环境并进行内部检查。`-it`
    标志的工作方式与 `docker run` 中的相同。
- en: Introduction to Kubernetes
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 介绍
- en: Up to now, we’ve just talked about Docker containers running on a single machine.
    What happens if you want to scale up? Kubernetes is an open source project, initially
    developed by Google, that manages scheduling and scaling for your infrastructure.
    It dynamically scales loads to many servers and keeps track of computing resources.
    Kubernetes also maximizes efficiency by putting multiple containers on one machine
    (depending on their size and needs), and it manages the communications between
    containers. It can run on any cloud platform—AWS, Azure, or GCP.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了在单台机器上运行的 Docker 容器。如果你想要扩展规模呢？Kubernetes 是一个开源项目，最初由 Google 开发，用于管理基础设施的调度和扩展。它动态地将负载扩展到多台服务器，并跟踪计算资源。Kubernetes
    还通过将多个容器放置在一台机器上（取决于它们的大小和需求），并管理容器之间的通信来最大化效率。它可以在任何云平台上运行，如 AWS、Azure 或 GCP。
- en: Some Kubernetes Definitions
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Kubernetes 定义
- en: 'One of the hardest parts of getting started with Kubernetes is the terminology.
    Here are a few definitions to help you:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的入门中最难的部分之一是术语。以下是一些定义，帮助你理解：
- en: Cluster
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 集群
- en: A cluster is a set of machines that contains a central node controlling the
    Kubernetes API server and many worker nodes.
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个集群是包含控制 Kubernetes API 服务器的中心节点和许多工作节点的一组机器。
- en: Node
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 节点
- en: A node is a single machine (either a physical machine or a virtual machine)
    within a cluster.
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个节点是集群中的单个机器（可以是物理机器或虚拟机器）。
- en: Pod
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Pod
- en: A pod is a group of containers that run together on the same node. Often, a
    pod only contains a single container.
  id: totrans-91
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个 Pod 是一组在同一节点上运行的容器。通常，一个 Pod 只包含一个容器。
- en: Kubelet
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Kubelet
- en: A kubelet is the Kubernetes agent that manages communication with the central
    node on each worker node.
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: kubelet是每个工作节点上管理与中心节点通信的Kubernetes代理。
- en: Service
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 服务
- en: A service is a group of pods and the policies to access them.
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 服务是一组Pod和访问它们的策略。
- en: Volume
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 卷
- en: A volume is a storage space shared by all containers in the same pod.
  id: totrans-97
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 卷是同一Pod中所有容器共享的存储空间。
- en: Namespace
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: A namespace is the virtual cluster that divides up the space in a physical cluster
    into different environments. For example, we can divide a cluster into development
    and production environments or environments for different teams.
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名空间是将物理集群空间划分为不同环境的虚拟集群。例如，我们可以将集群划分为开发环境、生产环境或不同团队的环境。
- en: ConfigMap
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap
- en: A ConfigMap provides an API for storing nonconfidential configuration information
    (environment variables, arguments, etc.) in Kubernetes. ConfigMaps are useful
    to separate the configuration from container images.
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ConfigMap为在Kubernetes中存储非机密配置信息（环境变量、参数等）提供API。ConfigMap有助于将配置与容器映像分离。
- en: kubectl
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl
- en: kubectl is the CLI for Kubernetes.
  id: totrans-103
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: kubectl是Kubernetes的命令行工具。
- en: Getting Started with Minikube and kubectl
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Minikube和kubectl入门
- en: We can create a simple, local Kubernetes cluser using a tool called Minikube.
    Minikube makes it easy to set up Kubernetes on any operating system. It creates
    a virtual machine, installs Docker and Kubernetes on it, and adds a local user
    connected to it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个名为Minikube的工具创建一个简单的本地Kubernetes集群。Minikube可以在任何操作系统上轻松设置Kubernetes。它创建一个虚拟机，在其上安装Docker和Kubernetes，并添加一个连接的本地用户。
- en: DON’T USE MINIKUBE IN PRODUCTION
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要在生产环境中使用Minikube
- en: Minikube should not be used in production; rather, it is designed to be a quick
    and easy local environment. The easiest way to gain access to a production-quality
    Kubernetes cluer is by purchasing managed Kubernetes as a service from any major
    public cloud provider.
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Minikube不应在生产环境中使用；它设计用于快速而轻松的本地环境。获取生产质量的Kubernetes集群的最简单方法是从任何主要公共云提供商购买托管的Kubernetes服务。
- en: First, install kubectl, the Kubernetes CLI tool.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装kubectl，即Kubernetes的命令行工具。
- en: 'For Mac, kubectl can be installed using `brew`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Mac用户，可以使用`brew`安装kubectl：
- en: '`brew install kubectl`'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`brew install kubectl`'
- en: For Windows, see [their resources](https://oreil.ly/AhAwc).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户，请参阅[其资源](https://oreil.ly/AhAwc)。
- en: 'For Linux:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux：
- en: '`curl -LO https://storage.googleapis.com/kubernetes-release``\` `/release/v1.14.0/bin/linux/amd64/kubectl
    chmod +x ./kubectl sudo mv ./kubectl /usr/local/bin/kubectl`'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.14.0/bin/linux/amd64/kubectl
    chmod +x ./kubectl sudo mv ./kubectl /usr/local/bin/kubectl`'
- en: To install Minikube, we’ll first need to install a hypervisor that creates and
    runs virtual machines, such as [VirtualBox](https://oreil.ly/LJgFJ).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Minikube，首先需要安装一个创建和运行虚拟机的hypervisor，比如[VirtualBox](https://oreil.ly/LJgFJ)。
- en: 'On a Mac, Minikube can be installed using `brew`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，可以使用`brew`安装Minikube：
- en: '`brew install minikube`'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`brew install minikube`'
- en: For Windows, see [the resources](https://oreil.ly/awtxY).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户，请参阅[资源](https://oreil.ly/awtxY)。
- en: 'For Linux machines, use the following steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux机器，请使用以下步骤：
- en: '`curl -Lo minikube` `\` `https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
    chmod +x minikube sudo cp minikube /usr/local/bin` `&&` `rm minikube`'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
    chmod +x minikube sudo cp minikube /usr/local/bin && rm minikube`'
- en: 'Once installation is complete, start a simple Kubernetes cluster in a single
    command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，可以通过一个简单的命令启动一个简单的Kubernetes集群：
- en: '`minikube start`'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`minikube start`'
- en: 'To quickly check if Minikube is good to go, we can try to list the nodes in
    the cluster:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速检查Minikube是否已准备就绪，可以尝试列出集群中的节点：
- en: '`kubectl get nodes`'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`kubectl get nodes`'
- en: Interacting with the Kubernetes CLI
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与Kubernetes CLI交互
- en: The Kubernetes API is based on resources. Almost everything in the Kubernetes
    world is represented as a resource. `kubectl` is built with this in mind, so it
    will follow a similar pattern for most of the resource interactions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API基于资源。几乎Kubernetes世界中的所有内容都表示为资源。`kubectl`就是基于这一理念构建的，因此它在大多数资源交互中遵循类似的模式。
- en: 'For example, a typical `kubectl` call to list all pods would be:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，列出所有Pod的典型`kubectl`调用为：
- en: '`kubectl get pods`'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`kubectl get pods`'
- en: 'This should produce a list of all the running pods, but since we haven’t created
    any, the listing will be empty. That doesn’t mean that no pods are currently running
    on our cluster. Most of the resources in Kubernetes can be placed in a namespace,
    and unless you query the specific namespace, they won’t show up. Kubernetes runs
    its internal services in a namespace called `kube-system`. To list all pods in
    any namespace, you can use the `-n` option:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生一个所有运行中的 pod 的列表，但因为我们还没有创建任何 pod，所以列表是空的。这并不意味着我们的集群上当前没有运行的 pod。Kubernetes
    将其内部服务运行在名为 `kube-system` 的 namespace 中。要列出任何 namespace 中的所有 pod，可以使用 `-n` 选项：
- en: '`kubectl get pods -n kube-system`'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`kubectl get pods -n kube-system`'
- en: This should return several results. We can also use `--all-namespaces` to show
    all pods regardless of namespace.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回多个结果。我们还可以使用 `--all-namespaces` 显示所有 namespace 中的所有 pod。
- en: 'You can use the name only to display one pod:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以仅使用名称显示一个 pod：
- en: '`kubectl get po mypod`'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`kubectl get po mypod`'
- en: 'You can also filter out by label. For example, this call should show all pods
    that have the label `component` with the value `etcd` in `kube-system`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过标签进行过滤。例如，此调用应显示所有在 `kube-system` 中具有标签 `component=etcd` 值的 pod：
- en: '`kubectl get po -n kube-system -l` `component``=``etcd`'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`kubectl get po -n kube-system -l component=etcd`'
- en: 'The information displayed by `get` can also be modified. For example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 显示的信息也可以修改。例如：'
- en: '`# Show nodes and addresses of pods.` `kubectl get po -n kube-system -o wide`
    `# Show the yaml definition of pod mypod.` `kubectl get po mypod -o yaml`'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# 显示 pod 的节点和地址。` `kubectl get po -n kube-system -o wide` `# 显示名为 mypod 的
    pod 的 yaml 定义。` `kubectl get po mypod -o yaml`'
- en: 'To create a new resource, `kubectl` offers two commands: `create` and `apply`.
    The difference is that `create` will always try to create a new resource (and
    fail if it already exists), whereas `apply` will either create or update an existing
    resource.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新资源，`kubectl` 提供两个命令：`create` 和 `apply`。不同之处在于，`create` 将始终尝试创建新资源（如果已存在则失败），而
    `apply` 将创建或更新现有资源。
- en: 'The most common way to create a new resource is by using a YAML (or JSON) file
    with the resource definition, as we’ll see in the next section. The following
    kubectl commands allow us to create of update Kubernetes resources, (e.g., pods):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新资源最常见的方法是使用包含资源定义的 YAML（或 JSON）文件，我们将在下一节中看到。以下 kubectl 命令允许我们创建或更新 Kubernetes
    资源（例如 pod）：
- en: '`# Create a pod that is defined in pod.yaml.` `kubectl create -f pod.yaml`
    `# This can also be used with HTTP.` `kubectl create -f http://url-to-pod-yaml`
    `# Apply will allow making changes to resources.` `kubectl apply -f pod.yaml`'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# 创建在 pod.yaml 中定义的 pod。` `kubectl create -f pod.yaml` `# 这也可以与 HTTP 一起使用。`
    `kubectl create -f http://url-to-pod-yaml` `# apply 允许对资源进行更改。` `kubectl apply
    -f pod.yaml`'
- en: 'To delete a resource, use `kubectl delete`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除资源，请使用 `kubectl delete`：
- en: '`# Delete pod foo.` `kubectl delete pod foo` `# Delete all resources defined
    in pods.yaml.` `kubectl delete -f pods.yaml`'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# 删除名为 foo 的 pod。` `kubectl delete pod foo` `# 删除在 pods.yaml 中定义的所有资源。` `kubectl
    delete -f pods.yaml`'
- en: 'You can use `kubectl edit` to update an existing resource quickly. This will
    open an editor where you can edit the loaded resource definition:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `kubectl edit` 快速更新现有资源。这将打开一个编辑器，您可以在其中编辑加载的资源定义：
- en: '`kubectl edit pod foo`'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`kubectl edit pod foo`'
- en: Defining a Kubernetes Resource
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 Kubernetes 资源
- en: Kubernetes resources are most often defined as YAML (although JSON can also
    be used). Basically, all resources are data structures with a few essential sections.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 资源通常定义为 YAML（虽然也可以使用 JSON）。基本上，所有资源都是具有几个关键部分的数据结构。
- en: '`apiVersion`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion`'
- en: Every resource is part of an API, either supplied by Kubernetes itself or by
    third parties. The version number shows the maturity of the API.
  id: totrans-147
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个资源都是由 Kubernetes 本身或第三方提供的 API 的一部分。版本号显示 API 的成熟度。
- en: '`kind`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind`'
- en: The type of resource (e.g., pod, volume, etc.).
  id: totrans-149
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 资源类型（例如 pod、volume 等）。
- en: '`metadata`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`metadata`'
- en: The data required for any resource.
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何资源所需的数据。
- en: '`name`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`'
- en: The key that every resource can be queried by, which must be unique.
  id: totrans-153
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个资源都可以通过查询的关键字来查询，这个关键字必须是唯一的。
- en: '`labels`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`labels`'
- en: Each resource can have any number of key-value pairs called labels. These labels
    can then be used in selectors, for querying resources, or just as information.
  id: totrans-155
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个资源可以有任意数量的键值对，称为标签。然后可以将这些标签用于选择器，用于查询资源，或仅作为信息。
- en: '`annotations`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`annotations`'
- en: Secondary key-value pairs that are purely informational and cannot be used in
    queries or selectors.
  id: totrans-157
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 仅作信息用途的次要键值对，不能用于查询或选择器。
- en: '`namespace`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`namespace`'
- en: A label that shows a resource belongs to a particular namespace or team.
  id: totrans-159
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 显示资源属于特定命名空间或团队的标签。
- en: '`spec`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec`'
- en: Configuration of the resource. All information required for the actual runtime
    should be in `spec`. Each `spec` schema is unique to a particular resource type.
  id: totrans-161
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 资源的配置。所有实际运行所需的信息都应该在 `spec` 中。每个 `spec` 模式都是特定资源类型的唯一。
- en: 'Here is an example .yaml file using these definitions:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用这些定义的示例 .yaml 文件：
- en: '`apiVersion``:` `v1` `kind``:` `Pod` `metadata``:``name``:` `myapp-pod` `labels``:``app``:`
    `myapp` `spec``:``containers``:``— name``:` `myapp-container     image: busybox
        command: [``''sh''``,` `''-c''``,` `''echo``Hello``Kubernetes!``&&``sleep``3600''``]`'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`apiVersion`:`v1` `kind`:`Pod` `metadata`:`name`:`myapp-pod` `labels`:`app`:`myapp`
    `spec`:`containers`:`— name`:`myapp-container     image: busybox     command:
    [''sh'', ''-c'', ''echo Hello Kubernetes! && sleep 3600'']'
- en: In this file, we have `apiVersion` and `kind`, which define what this resource
    is. We have `metadata` that specifies the name and the label, and we have `spec`,
    which makes up the body of the resource. Our pod consists of a single container,
    running the command `sh -c echo Hello Kubernetes! && sleep 3600` in the image
    `busybox`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们有 `apiVersion` 和 `kind`，定义了这个资源是什么。我们有指定名称和标签的 `metadata`，还有构成资源主体的
    `spec`。我们的 Pod 包含一个单一容器，在镜像 `busybox` 中运行命令 `sh -c echo Hello Kubernetes! && sleep
    3600`。
- en: Deploying Applications to Kubernetes
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到 Kubernetes
- en: In this section, we will walk through the full deployment of a functional Jupyter
    Notebook using Minikube. We will create a persistent volume for our notebooks
    and create a NodePort service to allow us access to our notebook.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过 Minikube 完整部署一个功能性的 Jupyter Notebook。我们将为我们的笔记本创建一个持久卷，并创建一个 NodePort
    服务，以允许我们访问我们的笔记本。
- en: 'First, we need to find the correct Docker image. jupyter/tensorflow-notebook
    is an official image maintained by the Jupyter community. Next, we will need to
    find out which port our application will listen on: in this case, it’s `8888`
    (the default port for Jupyter Notebooks).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到正确的 Docker 镜像。jupyter/tensorflow-notebook 是由 Jupyter 社区维护的官方镜像。接下来，我们需要找出我们的应用程序将监听的端口：在这种情况下，它是
    `8888`（Jupyter Notebooks 的默认端口）。
- en: 'We want our notebook to persist between sessions, so we need to use PVC (persistent
    volume claim). We create a pvc.yaml file to do this for us:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的笔记本在会话之间持久存在，因此我们需要使用 PVC（持久卷声明）。我们创建一个 pvc.yaml 文件来为我们完成这个任务：
- en: '`kind``:` `PersistentVolumeClaim` `apiVersion``:` `v1` `metadata``:``name``:`
    `notebooks` `spec``:``accessModes``:` `— ReadWriteOnce` `resources``:``requests``:``storage``:`
    `3Gi`'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`kind`:`PersistentVolumeClaim` `apiVersion`:`v1` `metadata`:`name`:`notebooks`
    `spec`:`accessModes`:`— ReadWriteOnce` `resources`:`requests`:`storage`:`3Gi`'
- en: 'Now we can create this resource by calling:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过调用以下命令来创建此资源：
- en: '`kubectl apply -f pvc.yaml`'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`kubectl apply -f pvc.yaml`'
- en: 'This should create a volume. To confirm, we can list all volumes and PVCs:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该创建一个卷。要确认，我们可以列出所有的卷和 PVC：
- en: '`kubectl get pv kubectl get pvc kubectl describe pvc notebooks`'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`kubectl get pv kubectl get pvc kubectl describe pvc notebooks`'
- en: 'Next up, we create our deployment .yaml file. We will have one pod that will
    mount our volume and expose port 8888:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的 deployment .yaml 文件。我们将有一个 Pod，它将挂载我们的卷并暴露端口 8888：
- en: '`apiVersion``:` `apps/v1` `kind``:` `Deployment` `metadata``:``name``:` `jupyter`
    `labels``:``app``:` `jupyter` `spec``:``selector``:``matchLabels``:``app``:` `jupyter`
    ![](images/00002.jpg)`template``:``metadata``:``labels``:``app``:` `jupyter` `spec``:``containers``:``—
    image``:` `jupyter/tensorflow-notebook` ![](images/00075.jpg)`name``:` `jupyter`
    `ports``:``— containerPort``:` `8888           name: jupyter` `volumeMounts``:``—
    name``:` `notebooks           mountPath: /home/jovyan` `volumes``:``— name``:`
    `notebooks         persistentVolumeClaim:` `claimName``:` `notebooks`'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`apiVersion`:`apps/v1` `kind`:`Deployment` `metadata`:`name`:`jupyter` `labels`:`app`:`jupyter`
    `spec`:`selector`:`matchLabels`:`app`:`jupyter` ![](images/00002.jpg)`template`:`metadata`:`labels`:`app`:`jupyter`
    `spec`:`containers`:`— image:`jupyter/tensorflow-notebook` ![](images/00075.jpg)`name`:`jupyter`
    `ports`:`— containerPort:`8888           name: jupyter` `volumeMounts`:`— name:`notebooks
              mountPath: /home/jovyan` `volumes`:`— name:`notebooks         persistentVolumeClaim:`claimName:`notebooks'
- en: '![](images/00002.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00002.jpg)'
- en: It’s important that this selector matches the labels in the template.
  id: totrans-177
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 非常重要的是，此选择器必须与模板中的标签匹配。
- en: '![](images/00075.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00075.jpg)'
- en: Our image.
  id: totrans-179
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们的镜像。
- en: 'By applying this resource (in the same way we did with PVC), we will create
    a pod with a Jupyter instance:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用此资源（与 PVC 相同的方式），我们将创建一个带有 Jupyter 实例的 Pod：
- en: '`# Let''s see if our deployment is ready.` `kubectl get deploy` `# List pods
    that belong to this app.` `kubectl get po -l` `app``=``jupyter`'
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# 让我们看看我们的部署是否准备就绪。` `kubectl get deploy` `# 列出属于此应用程序的 Pod。` `kubectl get
    po -l` `app``=``jupyter`'
- en: 'When our pod is in the `Running` state, we should grab a token with which we’ll
    be able to connect to our notebook. This token will appear in logs:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 Pod 处于 `Running` 状态时，我们应该获取一个令牌，用于连接到我们的笔记本。此令牌将出现在日志中：
- en: '`kubectl logs deploy/jupyter`'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`kubectl logs deploy/jupyter`'
- en: 'To confirm that the pod is working, let’s access our notebook with `port-forward`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认 Pod 是否正常工作，让我们使用 `port-forward` 访问我们的笔记本：
- en: '`# First we need the name of our pod; it will have a randomized suffix.` `kubectl
    get po -l` `app``=``jupyter kubectl port-forward jupyter-84fd79f5f8-kb7dv 8888:8888`'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# 首先我们需要为我们的 Pod 命名; 它将具有随机后缀。` `kubectl get po -l` `app``=``jupyter kubectl
    port-forward jupyter-84fd79f5f8-kb7dv 8888:8888`'
- en: 'With this, we should be able to access a notebook on [http://localhost:8888](http://localhost:8888).
    The problem is, nobody else will be able to since it’s proxied through our local
    `kubectl`. Let’s create a `NodePort` service to let us access the notebook:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们应该能够在 [http://localhost:8888](http://localhost:8888) 访问笔记本。问题是，其他人无法访问，因为它是通过我们的本地
    `kubectl` 代理的。让我们创建一个 `NodePort` 服务来让我们访问这个笔记本：
- en: '`apiVersion``:` `v1` `kind``:` `Service` `metadata``:``name``:` `jupyter-service`
    `labels``:``app``:` `jupyter` `spec``:``ports``:``— port``:` `8888       nodePort:
    30888` `selector``:``app``:` `jupyter` `type``:` `NodePort`'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`apiVersion``:` `v1` `kind``:` `Service` `metadata``:``name``:` `jupyter-service`
    `labels``:``app``:` `jupyter` `spec``:``ports``:``— port``:` `8888       nodePort:
    30888` `selector``:``app``:` `jupyter` `type``:` `NodePort`'
- en: 'When this is created, we should be able to access our Jupyter! But first, we
    need to find the IP address of our pod. We should be able to access Jupyter under
    this address and port 30888:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个创建完成后，我们应该能够访问我们的 Jupyter！但首先，我们需要找到我们的 Pod 的 IP 地址。我们应该能够通过这个地址和端口 30888
    访问 Jupyter：
- en: '`minikube ip` `# This will show us what is our kubelet address is.` `192.168.99.100:30888`'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`minikube ip` `# 这将显示我们的 kubelet 地址是什么。` `192.168.99.100:30888`'
- en: Others can now access the Jupyter Notebook by using the obtained IP address
    and the service port (see [Figure A-2](#filepos1653945)). Once you access the
    address with your browser, you should see the Jupyter Notebook instance.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其他人现在可以通过获取的 IP 地址和服务端口访问 Jupyter Notebook（见 [Figure A-2](#filepos1653945)）。一旦您在浏览器中访问该地址，您应该能看到
    Jupyter Notebook 实例。
- en: '![](images/00006.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00006.jpg)'
- en: Figure A-2\. Jupyter Notebook running on Kubernetes
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A-2\. 运行在 Kubernetes 上的 Jupyter Notebook
- en: 'This was a brief overview of Kubernetes and its parts. The Kubernetes ecosystem
    is very extensive, and a brief appendix can’t provide a holistic overview. For
    more details regarding Kubeflow’s underlying architecture Kubernetes, we highly
    recommend the O’Reilly publication Kubernetes: Up and Running by Brendan Burns
    et al.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '这是关于 Kubernetes 及其部件的简要概述。Kubernetes 生态系统非常广泛，简短的附录无法提供全面的概述。有关 Kubeflow 底层架构
    Kubernetes 的更多详细信息，我们强烈推荐 O’Reilly 出版的《Kubernetes: Up and Running》一书，作者是 Brendan
    Burns 等人。'
