- en: 'Chapter 3\. See Your Customers and Business Better: 360 Graphs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章\. 更好地了解您的客户和业务：360 图
- en: 'This chapter will employ some real-world use cases to illustrate two of the
    six graph powers that we discussed in the previous chapter: [“Connecting the Dots”](ch02.html#connecting_the_dots)
    and the [“The 360 View”](ch02.html#the_threesixzero_view). The 360 view offered
    by graphs helps enterprises and agencies see their data more comprehensively,
    which in turn enables better analytics. In the first use case, we build a Customer
    360 (C360) graph to enable a company to track and understand presales customer
    journeys. In the second case, we build a Drug Interaction 360 graph so researchers
    can develop safer drug therapies.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将运用一些真实的用例来说明我们在上一章讨论的六个图形功能中的两个：“连接点”和“360视图”。图提供的360视图帮助企业和机构更全面地看待他们的数据，从而实现更好的分析能力。在第一个用例中，我们建立一个客户360（C360）图，使公司能够跟踪和理解售前客户旅程。在第二个案例中，我们建立了一个药物相互作用360图，以便研究人员可以开发更安全的药物疗法。
- en: 'After completing this chapter, you should be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您应能够：
- en: Define the term *C360* and explain its value proposition
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义术语*C360*并解释其价值主张
- en: Know how to model and analyze customer journeys in a graph
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何在图中建模和分析客户旅程
- en: Know how to use graph analytics to count and filter properties and relationships
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何使用图分析来计数和过滤属性和关系
- en: Set up and run a TigerGraph Cloud Starter Kit using GraphStudio
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GraphStudio设置和运行TigerGraph Cloud Starter Kit
- en: Read and understand basic GSQL queries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读并理解基本的 GSQL 查询
- en: 'Case 1: Tracing and Analyzing Customer Journeys'
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例1：追踪和分析客户旅程
- en: A business is nothing without sales. Selling, whether to consumers (B2C) or
    to other businesses (B2B), has become not only an art but also a science. Businesses
    analyze every stage of their interactions with a prospect (a potential customer)
    from beginning to end, hopefully resulting in a sale. According to Gartner, worldwide
    spending on customer relationship management (CRM) software increased by 15.6%
    in 2018 to reach $48.2 billion in 2020.^([1](ch03.html#ch01fn4)) Salesforce has
    established itself as the market leader in CRM software, with approximately a
    20% market share.^([2](ch03.html#ch01fn5))
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 没有销售就没有业务。销售，无论是面向消费者（B2C）还是其他企业（B2B），不仅成为一门艺术，也成为一门科学。企业分析他们与潜在客户（潜在客户）从开始到结束的每个阶段的互动，希望最终能够实现销售。根据Gartner的数据，2018年全球客户关系管理（CRM）软件支出增长了15.6%，达到2020年的482亿美元。^([1](ch03.html#ch01fn4))
    Salesforce已经确立了作为CRM软件市场领导者的地位，市场份额约为20%。^([2](ch03.html#ch01fn5))
- en: A key way to think about the process of selling is to consider the prospective
    customer’s experience as a series of events over time. How and when did someone
    engage with the business and its wares? Mapping out the interactions with a sales
    prospect is known as *tracing the customer’s journey*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将销售过程视为潜在客户在时间上的一系列事件体验是考虑的关键方式。某人如何何时参与企业及其商品？绘制与销售前景的互动称为*追踪客户旅程*。
- en: The customer journey model is an essential tool for sales and marketing. First,
    it takes the customer’s point of view, as they are the ultimate decision makers.
    Second, by realizing that the customer may need to move through stages, the business
    can map out what it believes will be attractive journeys that will secure many
    successful business deals. Third, when looking at individual journeys, we can
    see how far they have progressed, whether a journey has stalled, become slow,
    or changed course. Fourth, by analyzing the collected set of journeys, businesses
    can see patterns and trends and compare them to their targeted behavior. Are users
    in fact following the journey that was designed? Do particular engagements succeed
    in moving prospects forward?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 客户旅程模型是销售和营销的重要工具。首先，它采用客户的视角，因为他们是最终决策者。其次，通过意识到客户可能需要通过阶段，企业可以制定出他们认为将会吸引并确保许多成功业务交易的吸引力旅程。第三，通过查看个体旅程，我们可以看到它们的进展如何，一个旅程是否停滞不前，变慢或改变方向。第四，通过分析收集的旅程集合，企业可以看到模式和趋势，并将其与其目标行为进行比较。用户是否实际上按照设计的旅程进行？特定的参与是否成功推动潜在客户向前发展？
- en: There is a need for an effective and scalable data system that can collect the
    mixed types of data in a customer journey and support the analysis of both individual
    and aggregated journeys.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个有效且可扩展的数据系统，可以收集客户旅程中的混合数据类型，并支持对个体和聚合旅程的分析。
- en: 'Solution: Customer 360 + Journey Graph'
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案：客户360 + 旅程图
- en: CRMs would seem to offer the solution, but they have not fully met business’s
    needs for customer journey analysis. Designed for data to be either entered manually
    or ingested digitally, CRMs record and present data primarily in tabular form.
    The challenge comes from the fact that different types of engagements (watching
    a video, attending a demonstration, downloading trial software) have different
    characteristics. Storing mixed data like this in one table doesn’t work well,
    so data must be spread across multiple tables. The real challenge comes from modeling
    the journey’s sequence. The only way to follow the sequence is either through
    a series of costly table joins or to filter for all engagements associated with
    a certain person and then sort those engagements by time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CRM系统似乎提供了解决方案，但它们并没有完全满足企业对客户旅程分析的需求。设计用于手动输入数据或数字化摄取数据，CRM主要以表格形式记录和呈现数据。挑战在于不同类型的参与行为（观看视频、参加演示、下载试用软件）具有不同的特征。将这种混合数据存储在一个表中并不奏效，因此数据必须分布在多个表中。真正的挑战在于建模旅程的顺序。遵循顺序的唯一方法要么是通过一系列昂贵的表连接，要么是筛选与某个人相关的所有参与行为，然后按时间排序这些参与行为。
- en: With a graph, on the other hand, we can easily model the sequence directly with
    edges, as shown in [Figure 3-1](#customer_journey_general_stages_and_a_p). The
    journeys of all prospective customers can be stored in one graph. Individual journeys
    will have similarities and intersections with one another, as persons attend the
    same events or engage in similar activities.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用图形，我们可以直接使用边轻松建模顺序，如在[图3-1](#customer_journey_general_stages_and_a_p)中所示。所有潜在客户的旅程可以存储在一个图形中。个别旅程将彼此相似并交叉，因为个人参加相同的事件或从事类似的活动。
- en: '![Customer journey: general stages and a particular customer’s journey shown
    as a graph](assets/gpam_0301.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![客户旅程：一般阶段和一个特定客户的旅程的图形显示](assets/gpam_0301.png)'
- en: 'Figure 3-1\. Customer journey: general stages and a particular customer’s journey
    shown as a graph'
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1. 客户旅程：一般阶段和一个特定客户的旅程的图形显示
- en: 'Businesses not only want to map out customer journeys, but they also want to
    make them more successful: to increase customer satisfaction, to increase the
    percentage of journeys that end in a sale, to increase the value of sales, and
    to shorten the journeys. To do this, businesses need to understand the context
    of each customer and their decisions. This is where a 360 view helps. The 360
    view is one of the unique powers of graphs we discussed in the previous chapter.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 企业不仅希望绘制客户旅程，还希望使其更成功：提高客户满意度，增加以销售结束的旅程比例，增加销售价值，缩短旅程。为了做到这一点，企业需要了解每个客户及其决策的背景。这就是360度视图发挥作用的地方。360度视图是我们在前一章中讨论的图形的独特力量之一。
- en: '*Customer 360 (C360)* is a comprehensive view of a customer (or any entity
    of interest) created by integrating data from multiple sources, as suggested in
    [Figure 3-2](#a_customer_threesixzero_graph_gathers_a). Like customer journeys,
    Customer 360 is a great fit for graphs and graph analytics. A graph can support
    an unlimited number of relationships between one vertex (a customer) and other
    entities. These entities can describe not just the journey (a cold call, webinar,
    brochure, product demonstration, or website interaction) but also the context
    of the customer (current and past job titles, tenures, employers, locations, skills,
    interests, and education). A good 360 database will also include information about
    employers and industries (size, initiatives, news, etc.).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*客户360（C360）*是通过集成多个来源的数据创建的客户（或任何感兴趣的实体）的综合视图，正如在[图3-2](#a_customer_threesixzero_graph_gathers_a)中建议的那样。像客户旅程一样，客户360非常适合图形和图形分析。图形可以支持一个顶点（客户）与其他实体之间无限数量的关系。这些实体不仅可以描述旅程（冷呼叫、网络研讨会、宣传册、产品演示或网站互动），还可以描述客户的背景（当前和过去的职务头衔、任期、雇主、地点、技能、兴趣和教育）。一个好的360数据库还将包括关于雇主和行业的信息（规模、倡议、新闻等）。'
- en: '![Information about a single individual connected to form a holistic view for
    a Customer 360 Graph](assets/gpam_0302.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![连接以形成客户360图的全面视图的单个个体信息](assets/gpam_0302.png)'
- en: Figure 3-2\. Information about a single individual connected to form a holistic
    view for a Customer 360 Graph
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-2. 连接以形成客户360图的全面视图的单个个体信息
- en: With the combination of 360° data and journey analysis, businesses are able
    to clearly see what is happening in the sales process, at the individual and aggregate
    levels, to see the context of these actions, to see where improvement is desired,
    and to assess the impact of efforts at sales improvement.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 结合360°数据和旅程分析，企业能够清晰地看到销售过程中发生的情况，无论是个体还是整体水平，了解这些行动的背景，看到哪里需要改进，并评估销售改进所带来的影响。
- en: Our proposed solution is to develop a data model that makes it easy to examine
    and analyze customer journeys. The data model should also incorporate data described
    and related to customers to produce a Customer 360 view. The model should support
    queries about what events a customer journey does or doesn’t contain, as well
    as the timing of such events.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提议的解决方案是开发一个数据模型，使得检查和分析客户旅程变得简单。数据模型还应该包括描述和与客户相关的数据，以生成客户360视图。该模型应支持关于客户旅程包含或不包含哪些事件以及这些事件的时间的查询。
- en: 'Implementing the C360 + Journey Graph: A GraphStudio Tutorial'
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施 C360 + Journey Graph：GraphStudio 教程
- en: The implementation of a C360 and customer journey graph we present below is
    available as a TigerGraph Cloud Starter Kit. Starter kits are hands-on demos to
    teach you how graph analytics can help you with different use cases. Each kit
    comes with a graph schema, sample data, and queries. Don’t worry if this is your
    first time using TigerGraph Cloud. We’ll show you how to sign up for a free account
    and to deploy a free starter kit. Alternatively, if you have TigerGraph installed
    on your own machine, we’ll tell you how to import the starter kit into your system.
    Then we’ll simultaneously walk you through the design of the C360 graph and GraphStudio
    in general.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在下文中提供的 C360 和客户旅程图实施方案作为 TigerGraph Cloud Starter Kit 提供。起始套件是实践演示，教你如何使用图分析来处理不同的使用案例。每个套件都有一个图模式、示例数据和查询。如果这是你第一次使用
    TigerGraph Cloud，不用担心。我们将向你展示如何注册一个免费账户并部署一个免费的起始套件。或者，如果你已经在自己的机器上安装了 TigerGraph，我们将告诉你如何将起始套件导入到系统中。然后，我们将同时指导你设计
    C360 图和总体上的 GraphStudio。
- en: '[Figure 3-3](#setting_up_a_tigergraph_starter_kit) maps out the two paths toward
    setting up a starter kit. In the following sections, we’ll first tell you how
    to create a TigerGraph Cloud account. Then we’ll walk you through the steps for
    getting and loading a starter kit, first for TigerGraph Cloud users and then for
    TigerGraph on-premises users.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-3](#setting_up_a_tigergraph_starter_kit) 描述了设置起始套件的两条路径。在接下来的章节中，我们将首先告诉你如何创建
    TigerGraph Cloud 账户。然后我们将指导你完成获取和加载起始套件的步骤，首先是针对 TigerGraph Cloud 用户，然后是针对 TigerGraph
    自建用户。'
- en: '![Setting up a TigerGraph Starter Kit](assets/gpam_0303.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![设置 TigerGraph Starter Kit](assets/gpam_0303.png)'
- en: Figure 3-3\. Setting up a TigerGraph Starter Kit
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. 设置 TigerGraph Starter Kit
- en: Create a TigerGraph Cloud Account
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 TigerGraph Cloud 账户
- en: 'If this is your first time using TigerGraph Cloud, you need to set up an account.
    It’s simple and free:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次使用 TigerGraph Cloud，你需要设置一个账户。这很简单并且免费：
- en: In a web browser, go to [*tgcloud.io*](https://tgcloud.io).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页浏览器中，访问 [*tgcloud.io*](https://tgcloud.io)。
- en: Click the “Sign up” button and fill out the form. The sign-up form may ask you
    to create an organization. An organization can contain and manage multiple users
    and multiple databases under one account.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“注册”按钮并填写表单。注册表单可能要求你创建一个组织。一个组织可以包含和管理多个用户和多个数据库在同一个账户下。
- en: When you submit the form, TigerGraph Cloud will then ask you to go to your email
    to verify your account. You now have a TigerGraph Cloud account!
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你提交表单后，TigerGraph Cloud 将要求你去你的电子邮件验证你的账户。你现在拥有了一个 TigerGraph Cloud 账户！
- en: In the next section, we’ll tell you how to create a TigerGraph Cloud database,
    with your choice of starter kit.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将告诉你如何创建 TigerGraph Cloud 数据库，并选择起始套件。
- en: Get and Install the Customer 360 Starter Kit
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取并安装客户360起始套件
- en: We are going to use the starter kit called “Customer 360 – Attribution and Engagement
    Graph*.*” If you are a TigerGraph Cloud user, you can get the starter kit as part
    of a new database deployment. If you are running TigerGraph on your own computer,
    you can download the starter kit files from the [TigerGraph website](http://www.tigergraph.com)
    and then upload them into your TigerGraph instance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用名为“客户360 – 归因和参与图”的起始套件。如果你是 TigerGraph Cloud 用户，你可以作为新数据库部署的一部分获取起始套件。如果你在自己的计算机上运行
    TigerGraph，你可以从[TigerGraph网站](http://www.tigergraph.com)下载起始套件文件，然后将它们上传到你的 TigerGraph
    实例中。
- en: The next two sections go over the details for these two options.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个部分详细介绍了这两个选项的细节。
- en: Deploy a cloud instance with a starter kit
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署带有起始套件的云实例
- en: When you log in to TigerGraph Cloud, the first page visible is the My Clusters
    page. A cluster is a TigerGraph database deployment, with or without a graph schema
    or data. Click the Create Cluster button, which will take you to the Create Cluster
    page (shown in [Figure 3-4](#tigergraph_cloud_create_cluster_menu)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 登录TigerGraph Cloud时，第一个可见的页面是我的集群页面。集群是一个TigerGraph数据库部署，具有或不具有图架构或数据。单击创建集群按钮，这将带您进入创建集群页面（如图[3-4](#tigergraph_cloud_create_cluster_menu)所示）。
- en: '![TigerGraph Cloud Create Cluster menu](assets/gpam_0304.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![TigerGraph Cloud创建集群菜单](assets/gpam_0304.png)'
- en: Figure 3-4\. TigerGraph Cloud Create Cluster menu
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-4. TigerGraph Cloud创建集群菜单
- en: 'Then follow these steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下步骤操作：
- en: Confirm the service tier for your cluster. On the Create Cluster page, you’ll
    see it defaults to the free tier. Larger and more powerful clusters incur hourly
    charges. For the exercises in this book, the free size should be fine. You can
    upgrade a cluster after deploying it, if you wish.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认您集群的服务层级。在创建集群页面上，默认为免费层级。较大和更强大的集群会产生按小时计费。对于本书中的练习，免费大小应该足够。您可以在部署后升级集群，如果需要的话。
- en: Select a starter kit by use case. If the kit you want isn’t displayed, click
    on “View all use cases” to see more choices. In this case, it’s “Customer 360
    – Attribution and Engagement Graph.” For the free tier, that’s it. In a few minutes,
    your database instance will be ready.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个用例的起始套件。如果您想要的套件未显示，请单击“查看所有用例”以查看更多选择。在本例中，是“Customer 360 – Attribution
    and Engagement Graph”。对于免费层级，就是这样。几分钟后，您的数据库实例将准备就绪。
- en: 'If you decide to create a paid tier instance, then you have more choices to
    make: cloud platform provider, instance size, region, disk size, and cluster configuration.
    You can follow this tutorial with the default values for all of these.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您决定创建付费层级实例，则需要做更多选择：云平台提供商、实例大小、区域、磁盘大小和集群配置。您可以使用所有这些默认值按照本教程操作。
- en: Once your cluster instance is ready, it will be listed on the My Clusters page.
    Click its Tools button. From the menu that appears, select GraphStudio.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您的集群实例准备就绪，它将显示在我的集群页面上。单击其工具按钮。从显示的菜单中，选择GraphStudio。
- en: Continue to [“Load data and install queries for a starter kit”](#load_data_and_install_queries_for_a_sta).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续到[“加载数据并安装起始套件的查询”](#load_data_and_install_queries_for_a_sta)。
- en: 'Alternative: Import a starter kit into your TigerGraph instance'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另选项：将起始套件导入到您的TigerGraph实例中
- en: 'If you have TigerGraph software installed on your own machine, follow these
    steps to get a starter kit:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在自己的机器上安装了TigerGraph软件，请按照以下步骤获取起始套件：
- en: Go to [*www.tigergraph.com/starterkits*](http://www.tigergraph.com/starterkits).
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[*www.tigergraph.com/starterkits*](http://www.tigergraph.com/starterkits)。
- en: Find Customer 360—Attribution and Engagement Graph.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找Customer 360—Attribution and Engagement Graph。
- en: Download Data Set and the solution package corresponding to your version of
    the TigerGraph platform.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载与您的TigerGraph平台版本对应的数据集和解决方案包。
- en: Start your TigerGraph instance. Go to the GraphStudio home page.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的TigerGraph实例。前往GraphStudio主页。
- en: Click Import An Existing Solution and select the solution package that you downloaded.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击导入现有解决方案，并选择您下载的解决方案包。
- en: Continue to [“Load data and install queries for a starter kit”](#load_data_and_install_queries_for_a_sta).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续到[“加载数据并安装起始套件的查询”](#load_data_and_install_queries_for_a_sta)。
- en: Warning
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Importing a GraphStudio Solution will delete your existing database. If you
    wish to save your current design, perform a Graph­Studio Export Solution and also
    run a database backup as described on [the TigerGraph documentation site](https://oreil.ly/LoDnj).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 导入GraphStudio解决方案将删除您现有的数据库。如果您希望保存当前设计，请执行GraphStudio导出解决方案，并按照[TigerGraph文档站点](https://oreil.ly/LoDnj)上的说明备份数据库。
- en: Load data and install queries for a starter kit
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载数据并安装起始套件的查询
- en: 'There are three additional steps needed to complete the installation of a starter
    kit. If you know GraphStudio and just want to know how to install a starter kit,
    then follow these steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要三个额外步骤来完成起始套件的安装。如果您了解GraphStudio，只想知道如何安装起始套件，请按照以下步骤操作：
- en: Go to the Design Schema page. On the menu on the left, switch from the Global
    view to the starter kit’s local graph view. It might be called MyGraph, or it
    might have a customized name like AntiFraud.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往设计模式页面。在左侧菜单中，从全局视图切换到起始套件的本地图视图。可能称为MyGraph，或者可能具有像AntiFraud这样的自定义名称。
- en: Go to the Load Data page. Wait about five seconds until the Load Data button
    on the left end of the top menu becomes active. Click the button and wait for
    the data to finish loading. You can track the loading progress in the timeline
    display at the lower right.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到加载数据页面。等待大约五秒，直到顶部菜单左端的“加载数据”按钮变为活动状态。点击按钮，等待数据加载完成。您可以在右下角的时间轴显示中跟踪加载进度。
- en: Go to the Write Queries page. Above the list of queries, click the Install All
    Queries button and wait for the installation to complete.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到编写查询页面。在查询列表上方，点击“安装所有查询”按钮，并等待安装完成。
- en: An Overview of GraphStudio
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphStudio概述
- en: TigerGraph’s GraphStudio is a complete graph solution development kit, covering
    every stage in the process from developing a graph model to running queries. It
    is organized as a series of views or pages, each one for a different task in the
    development process.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: TigerGraph的GraphStudio是一个完整的图解决方案开发工具包，涵盖了从开发图模型到运行查询的整个过程中的每个阶段。它被组织为一系列视图或页面，每个页面用于开发过程中的不同任务。
- en: 'Because this is our first time through GraphStudio together, we are going to
    walk through all five stages: Design Schema, Map Data to Graph, Load Data, Explore
    Graph, and Write Queries. At each stage, we will both explain the general purpose
    of the page and guide you through details of the specific starter kit we are working
    with. In future chapters, we will skip over most of the generalities and only
    talk about the starter kit details.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是我们首次一起使用GraphStudio，我们将通过所有五个阶段：设计架构、映射数据到图、加载数据、探索图和编写查询。在每个阶段，我们将解释页面的一般目的，并指导您完成我们正在使用的特定起始套件的详细信息。在未来的章节中，我们将跳过大部分的概括，只讨论起始套件的细节。
- en: If we were beginning with an empty database, we would need to do additional
    design work, such as creating a graph model. Having a starter kit lets you skip
    most of this and get right to exploring and querying an example dataset.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从空数据库开始，我们需要进行额外的设计工作，例如创建图模型。有了起始套件，您可以跳过大部分工作，直接探索和查询示例数据集。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: How to create a graph model in GraphStudio is just one of the many topics covered
    in TigerGraph’s online documentation at [*docs.tigergraph.com*](https://docs.tigergraph.com).
    The official TigerGraph YouTube channel is also a valuable resource for tutorials.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在GraphStudio中创建图模型只是TigerGraph在线文档中涵盖的众多主题之一，详细信息请访问[*docs.tigergraph.com*](https://docs.tigergraph.com)。TigerGraph官方YouTube频道也是教程的宝贵资源。
- en: Design a Graph Schema
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计图架构
- en: The starter kit is preloaded with a graph model based on commonly used data
    objects in Salesforce and similar CRM software. The name of the graph in this
    starter kit is *MyGraph*. When you start GraphStudio, you are initially at the
    global graph level. You are not yet working on a particular graph. In a TigerGraph
    database, the global level is used to define data types that are potentially available
    to all users and all graphs. See the section labeled “Global types” in [Figure 3-5](#global_typescomma_local_typescomma_and).
    A database can then host one or more graphs. A graph can contain local types,
    and it can include some or all of the global types. See graphs G1 and G2 in the
    figure.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 起始套件预装了基于Salesforce和类似CRM软件中常用数据对象的图模型。此起始套件中图的名称为*MyGraph*。启动GraphStudio时，您最初位于全局图级别。您还没有在特定图上工作。在TigerGraph数据库中，全局级别用于定义可能对所有用户和所有图表可用的数据类型。请参阅图3-5中标记为“全局类型”的部分。然后数据库可以托管一个或多个图。图可以包含本地类型，并且可以包含某些或所有全局类型。请参阅图中的G1和G2。
- en: '![Global types, local types, and graphs in a TigerGraph database](assets/gpam_0305.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![TigerGraph数据库中的全局类型、本地类型和图表](assets/gpam_0305.png)'
- en: Figure 3-5\. Global types, local types, and graphs in a TigerGraph database
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-5。TigerGraph数据库中的全局类型、本地类型和图表
- en: To work on a graph, you need to select the graph, which moves you from the global
    level to the local graph level. To switch to a local graph, click on the circular
    icon in the upper left corner. A drop-down menu will appear, showing you the available
    graphs and letting you create a new graph. Click on MyGraph (step 2). Just below
    that, click on Design Schema to be sure we’re starting at the right place.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理图表，您需要选择图表，这将使您从全局级别移动到本地图表级别。要切换到本地图表，请点击左上角的圆形图标。会弹出一个下拉菜单，显示可用的图表，并允许您创建一个新图表。点击“MyGraph”（步骤2）。在下面稍微低一点的地方，点击“设计架构”，确保我们从正确的位置开始。
- en: You should now see a graph model or schema like the one in [Figure 3-6](#graph_schema_for_crm_data)
    in the main display panel.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该在主显示面板上看到一个类似于[图3-6](#graph_schema_for_crm_data)的图模型或模式。
- en: '![Graph schema for CRM data](assets/gpam_0306.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![CRM数据的图模式](assets/gpam_0306.png)'
- en: Figure 3-6\. Graph schema for CRM data (see a larger version of this figure
    at [https://oreil.ly/gpam0306](https://oreil.ly/gpam0306))
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-6\. CRM数据的图模式（在[https://oreil.ly/gpam0306](https://oreil.ly/gpam0306)查看更大的版本）
- en: A graph schema defines the *types* of data objects to be stored in the database.
    If the schema is depicted visually, then each data type is shown once. This schema
    has 8 vertex types and 14 edge types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的图模式定义了要存储的*数据对象类型*。如果图模式在视觉上呈现，那么每种数据类型只显示一次。此模式有8种顶点类型和14种边类型。
- en: The central vertex type is `**Contact**`, which is a prospective buyer of the
    product. However, a `**Contact**` is not just any prospective buyer, which reflects
    the fact that a person buying a B2B product on behalf of a company is not making
    a spur-of-the-moment decision. Instead, the person transitions through stages
    of the buying process. We call the person’s flow through the buying process the
    *customer journey*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 中心顶点类型是`**联系人**`，这是产品的潜在买家。然而，一个`**联系人**`不仅仅是任何潜在买家，这反映了一个代表公司购买B2B产品的人并非一时冲动的决定。相反，这个人通过购买过程的各个阶段进行过渡。我们称之为这个人在购买过程中的流程为*客户旅程*。
- en: One real-world person might show up more than once in the database. If the vendor
    conducts a marketing `**Campaign**`, then persons who respond to the campaign
    show up as `**CampaignMember**` vertices. Also, if a third party, a `**LeadSource**`,
    provides contact information about a potential buyer, then the potential buyer
    shows up as a `**Lead**`. A `**Salesperson**` engages a `**Lead**` to see if there
    is a realistic possibility of a sale. If there is, then the `**Lead**`’s information
    is copied to a new vertex type called a `**Contact**`. This `**Contact**` and
    their source `**Lead**` represent the same physical person but at different stages
    of the customer journey.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中，一个真实的人可能会出现多次。如果供应商进行了营销**`活动`**，那么对该活动作出反应的人将显示为**`营销活动成员`**顶点。此外，如果第三方，即`**潜在客户来源**`，提供了潜在买家的联系信息，则潜在买家将显示为一个`**潜在客户**`。一位`**销售人员**`与一个`**潜在客户**`进行接触，看看是否存在实际的销售可能性。如果存在，那么`**潜在客户**`的信息将复制到一个称为`**联系人**`的新顶点类型中。这个`**联系人**`及其来源的`**潜在客户**`代表同一个物理人，但处于客户旅程的不同阶段。
- en: '[Table 3-1](#vertex_types_in_the_salesforce_customer) contains descriptions
    of all eight vertex types. In some cases, the description of one vertex type talks
    about how it is related to another vertex type. For example, an **`Account`**
    is “an organization that a `**Contact**` belongs to.” Looking at [Figure 3-6](#graph_schema_for_crm_data),
    you can see an edge type called **`belongs_to`** between `**Account**` and `**Contact**`.
    There are 13 other edge types in the figure. The edge types have descriptive names,
    so if you understand the vertex types, you should be able to figure out the meaning
    of the edges.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3-1](#vertex_types_in_the_salesforce_customer)包含所有八种顶点类型的描述。在某些情况下，一个顶点类型的描述讨论它如何与另一个顶点类型相关。例如，一个**`账户`**是“一个`**联系人`**所属的组织”。查看[图3-6](#graph_schema_for_crm_data)，您可以看到`**账户**`和`**联系人**`之间的边类型称为**`属于`**。图中还有其他13种边类型。这些边类型有描述性的名称，因此如果理解了顶点类型，您应该能够理解边的含义。'
- en: Table 3-1\. Vertex types in the Salesforce Customer 360 graph model
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-1\. Salesforce Customer 360图模型中的顶点类型
- en: '| Vertex type | Description |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 顶点类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `**Account**` | An organization that a **`Contact`** belongs to |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `**账户**` | **`联系人`**所属的组织 |'
- en: '| `**Campaign**` | A marketing initiative intended to generate **`Leads`**
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `**营销活动**` | 旨在产生**`潜在客户`**的营销举措 |'
- en: '| `**CampaignMember**` | A persona who responds to a **`Campaign`** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `**营销活动成员**` | 响应**`营销活动`**的一个角色 |'
- en: '| `**Contact**` | A **`Lead`** who is now associated with a sales **`Opportunity`**
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `**联系人**` | 现在与销售**`机会`**相关联的一个**`潜在客户`** |'
- en: '| `**Industry**` | A business sector of an `**Account**` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `**行业**` | **`账户`**的业务部门 |'
- en: '| `**Lead**` | A person who is a potential buyer of the product but is not
    yet associated with an `**Opportunity**` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `**潜在客户**` | 一个有可能购买产品但尚未与一个`**销售机会**`相关联的人 |'
- en: '| `**LeadSource**` | A channel through which a **`Lead`** finds out about the
    product |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `**潜在客户来源**` | 一个**`潜在客户`**了解产品的渠道 |'
- en: '| `**Opportunity**` | A potential sales transaction, characterized by a monetary
    amount |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `**销售机会**` | 一个潜在的销售交易，以货币金额为特征 |'
- en: Data Loading
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据加载
- en: In TigerGraph starter kits, the data is included, but it is not yet loaded into
    the database. To load the data, switch to the Load Data page (step 1 of [Figure 3-7](#loading_data_in_a_starter_kit)),
    wait a few seconds until the Load button in the upper left of the main panel becomes
    active, and then click it (step 2). You can watch the progress of the loading
    in the real-time chart at the right (not shown). Loading the 34K vertices and
    105K edges should take two minutes on the TGCloud free instances; it’s faster
    on the paid instances.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TigerGraph 的入门套件中，数据已包含在内，但尚未加载到数据库中。要加载数据，请切换到加载数据页面（第 1 步，参见 [图 3-7](#loading_data_in_a_starter_kit)），等待几秒钟，直到主面板左上角的加载按钮变为活动状态，然后单击它（第
    2 步）。您可以在右侧的实时图表中观察加载的进度（未显示）。在 TGCloud 的免费实例上加载 34K 个顶点和 105K 条边应该需要两分钟；在付费实例上速度更快。
- en: '![Loading data in a starter kit](assets/gpam_0307.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![在入门套件中加载数据](assets/gpam_0307.png)'
- en: Figure 3-7\. Loading data in a starter kit
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-7\. 在入门套件中加载数据
- en: Queries and Analytics
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询与分析
- en: We will analyze the graph and run graph algorithms by composing and executing
    queries in GSQL, TigerGraph’s graph query language. When you first deploy a new
    starter kit, you need to install the queries. Switch to the Write Queries page
    (step 1 of [Figure 3-8](#installing_queries)). Then click the Install All icon
    at the top right of the list of queries (step 2).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过组合和执行 GSQL 中的查询来分析图并运行图算法，GSQL 是 TigerGraph 的图查询语言。在第一次部署新的入门套件时，您需要安装查询。切换到编写查询页面（第
    1 步，参见 [图 3-8](#installing_queries)）。然后点击查询列表右上角的“全部安装”图标（第 2 步）。
- en: '![Installing queries](assets/gpam_0308.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![安装查询](assets/gpam_0308.png)'
- en: Figure 3-8\. Installing queries
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-8\. 安装查询
- en: Learning and Using GSQL
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习和使用 GSQL
- en: The GSQL examples in this book are intended to show you some of the techniques
    to express informational and analytical queries of a graph database. While the
    examples are written in GSQL, it is not necessary for you to become fluent, nor
    do we even try to teach it in a rigorous way. If you know basic SQL and are familiar
    with a general-purpose language like Python, we believe you will be able to follow
    our explanations of the queries with a little effort. When we want to make a particular
    point about the GSQL language, we will use a note box like this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的 GSQL 示例旨在向您展示一些表达图数据库信息和分析查询技术的方法。虽然示例是用 GSQL 编写的，但您不必精通这门语言，我们也不会试图以严格的方式教授它。如果您了解基本的
    SQL 并熟悉像 Python 这样的通用语言，我们相信您将能够稍加努力地理解我们对查询的解释。当我们想要强调 GSQL 语言的某一点时，我们会使用如此的提示框。
- en: 'For our Customer 360 use case, we will discuss three queries:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 Customer 360 使用案例，我们将讨论三个查询：
- en: Customer interaction subgraph
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 客户互动子图
- en: This query generates a subgraph that gives us a holistic view of the customer
    journey. The subgraph embodies the interactions that the customer has with the
    company’s campaigns. The query starts with a given customer of type `**Contact**`
    vertex. From there, it collects `**Account**`, `**Opportunity**`, and `**CampaignMember**`
    vertices that the customer had interacted with. Furthermore, for each of the `**CampaignMember**`
    elements, a `**Campaign**` is selected as well. Finally, the query returns the
    resulting customer interaction subgraph.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询生成一个子图，为我们提供客户旅程的全面视图。子图体现了客户与公司广告活动的互动。查询从类型为`**Contact**`的给定客户开始。然后，它收集客户与之互动过的`**Account**`、`**Opportunity**`和`**CampaignMember**`顶点。此外，对于每个`**CampaignMember**`元素，也选择了一个`**Campaign**`。最后，查询返回生成的客户互动子图。
- en: Customer journey
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 客户旅程
- en: This query finds all the `**CampaignMember**` elements that the customer has
    interacted with during a time period. The query starts with a given `**Contact**`
    and filters for all the `**CampaignMember**` elements that have been in touch
    with the `**Contact**` between a start time and end time. Unlike the first query,
    we don’t return a subgraph with the connections between the `**Contact**` and
    `**CampaignMember**`. Here we return a sorted list of `**CampaignMember**` vertices.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询查找在某个时间段内与客户互动过的所有`**CampaignMember**`元素。查询从给定的`**Contact**`开始，并过滤出在开始时间和结束时间之间与`**Contact**`有过联系的所有`**CampaignMember**`元素。与第一个查询不同的是，我们不返回连接`**Contact**`和`**CampaignMember**`之间的子图。在这里，我们返回一个按`**CampaignMember**`顶点排序的列表。
- en: Similar contacts
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 相似联系人
- en: This query returns contacts similar to a given `**Contact**`. If the given **`Contact`**
    was successfully converted to a paying customer, this query can find additional
    good candidates for conversion. This query implements the Jaccard similarity measure
    in GSQL to calculate the similarity between a given `**Contact**` and other `**Contact**`
    vertices who share a similar `**Campaign**`. Then the contacts with the highest
    similarity score will be returned.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询返回与给定`**Contact**`类似的联系人。如果给定的`**Contact**`成功转化为付费客户，此查询可以找到其他潜在的转化候选人。此查询在
    GSQL 中实现了 Jaccard 相似度测量，用于计算给定`**Contact**`与共享相似`**Campaign**`的其他`**Contact**`顶点之间的相似性。然后返回相似度得分最高的联系人。
- en: For each of the three queries, we’ll give a high-level explanation, directions
    for running them in TigerGraph’s GraphStudio, what to expect as a result, and
    a closer look at some of the GSQL code in the queries.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这三个查询中的每一个，我们将提供一个高层次的解释，在 TigerGraph 的 GraphStudio 中运行它们的指南，预期的结果以及对查询中一些
    GSQL 代码的更详细的查看。
- en: Customer interaction subgraph
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户互动子图
- en: 'The `customer_interactions` query takes one argument: a customer who is a natural
    person of type `**Contact**`. First, we select all the `**Account**` identities
    that **`belongs_to`** the given `**Contact**`. Then we find all the `**Opportunity**`
    vertices connected to the `**Contact**`. In addition, the `**Contact**` vertex
    has a connection to one or more `**CampaignMember**`, who is a natural person
    that is part of a `**Campaign**`. [Figure 3-9](#contact_vertex_and_edges) illustrates
    the relationships uncovered by this query.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`customer_interactions`查询需要一个参数：作为`**Contact**`自然人类型的客户。首先，我们选择所有属于给定`**Contact**`的`**Account**`身份。然后，我们找到与`**Contact**`连接的所有`**Opportunity**`顶点。此外，`**Contact**`顶点与一个或多个属于`**Campaign**`的`**CampaignMember**`有连接。[图 3-9](#contact_vertex_and_edges)说明了此查询发现的关系。'
- en: '![Contact vertex and edges](assets/gpam_0309.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Contact 顶点和边缘](assets/gpam_0309.png)'
- en: Figure 3-9\. `**Contact**` vertex and edges
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-9\. **Contact** 顶点和边缘
- en: 'Do: Run the GSQL query `customer_interaction` by selecting the query name from
    the list (step 1 in [Figure 3-10](#running_the_customer_interaction_query)) and
    then clicking the Run icon above the code panel (step 2). This query has one input
    parameter: the “Contact” field lets us fill in a name of the customer. If you
    look at the query code pane ([Figure 3-10](#running_the_customer_interaction_query)),
    you will see a comment that suggests an example value for Contact: `Sam-Eisenberg`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 进行：通过从列表中选择查询名称（[图 3-10](#running_the_customer_interaction_query)中的步骤 1）并点击代码面板上方的运行图标（步骤
    2）来运行 GSQL 查询`customer_interaction`。此查询有一个输入参数：字段“Contact”让我们填入客户的姓名。如果您查看查询代码窗格（[图 3-10](#running_the_customer_interaction_query)），您将看到一个建议的`Contact`示例值的注释：`Sam-Eisenberg`。
- en: '![Running the customer_interaction query](assets/gpam_0310.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![运行`customer_interaction`查询](assets/gpam_0310.png)'
- en: Figure 3-10\. Running the `customer_interaction` query
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-10\. 运行`customer_interaction`查询
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Use your mouse to copy and paste values from the code window into the query
    parameter input boxes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鼠标从代码窗口复制并粘贴值到查询参数输入框中。
- en: The output will appear in the result panel below the query-editing panel. The
    graph may look scrambled initially. To clean up the appearance, click the Change
    Layout (force) button in the lower right corner of the output and select force.
    Then the output should look something like [Figure 3-11](#the_customer_interaction_query_result_w).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示在查询编辑面板下方的结果面板中。初始时，图可能看起来很混乱。要清理外观，请点击输出右下角的“更改布局（force）”按钮，然后选择 force。然后输出应该类似于[图 3-11](#the_customer_interaction_query_result_w)。
- en: '![The customer_interaction query result with input “Sam-Eisenberg”](assets/gpam_0311.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![带有输入“Sam-Eisenberg”的`customer_interaction`查询结果](assets/gpam_0311.png)'
- en: Figure 3-11\. The `customer_interaction` query result with input `Sam-Eisenberg`
    (see a larger version of this figure at [https://oreil.ly/gpam0311](https://oreil.ly/gpam0311))
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-11\. 查询结果`customer_interaction`，输入为`Sam-Eisenberg`（请查看此图的大图版本 [https://oreil.ly/gpam0311](https://oreil.ly/gpam0311)）
- en: 'Now we will look at how the GSQL query `cust_journey_subgraph` works. Refer
    to the code block that follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 GSQL 查询`cust_journey_subgraph`的工作原理。请参考随后的代码块：
- en: '[PRE0]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the first line, we define the name of the query and its input parameters.
    To find a customer subgraph, we need one parameter for the customer, a vertex
    of type `**Contact**`. Next we declare some variables. At [![1](assets/1.png)](#comarker1)
    we define a variable, a set of edges called `@@edges_to_display`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们定义了查询的名称及其输入参数。为了查找客户子图，我们需要一个客户参数，类型为 `**Contact**` 的顶点。接下来我们声明了一些变量。在
    [![1](assets/1.png)](#comarker1) 处，我们定义了一个名为 `@@edges_to_display` 的边集变量。
- en: GSQL Query Structure
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GSQL 查询结构
- en: A GSQL query is a named parameterizable procedure. The main body is a sequence
    of `SELECT` statements that traverse and analyze the graph one or more hops at
    a time. The inputs and outputs of a `SELECT` statement are vertex set variables.
    The output of the query as a whole is explicitly stated with `PRINT` statements.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 GSQL 查询是一个命名的可参数化过程。其主体是一系列 `SELECT` 语句，一次或多次遍历和分析图形。`SELECT` 语句的输入和输出是顶点集变量。整个查询的输出通过
    `PRINT` 语句明确声明。
- en: To begin traversing the graph, we need to define a vertex set that contains
    our starting point or points. At [![2](assets/2.png)](#comarker2) we create a
    vertex set called `cust` consisting of the `**Contact**` from the input parameters.
    Then at [![3](assets/3.png)](#comarker3) we use a `SELECT` statement to start
    to gather the customer’s interactions. The clause `FROM cust:s -(belongs_to:e)-
    Account:t` means traverse from `cust` across `**belongs_to**` edges to `**Account**`
    vertices. The notations `:e` and `:t` define alias variables for the edges and
    target vertices, respectively. The `ACCUM` clause acts like a `FOREACH` for the
    alias variables. In effect, each `e` edge that fits the `FROM` pattern is added
    to the `@@edges_to_display` accumulator. Lastly, the initial clause `accts = SELECT
    t` means that this statement returns a vertex set called `accts` consisting of
    the `t` alias vertices.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始遍历图形，我们需要定义一个包含我们的起始点或起始点的顶点集。在 [![2](assets/2.png)](#comarker2) 处，我们创建了一个名为
    `cust` 的顶点集，其中包含输入参数中的 `**Contact**`。然后在 [![3](assets/3.png)](#comarker3) 处，我们使用一个
    `SELECT` 语句开始收集客户的交互。子句 `FROM cust:s -(belongs_to:e)- Account:t` 意味着从 `cust` 沿着
    `**belongs_to**` 边遍历到 `**Account**` 顶点。符号 `:e` 和 `:t` 分别为边和目标顶点定义了别名变量。`ACCUM`
    子句像 `FOREACH` 一样作用于别名变量。实际上，符合 `FROM` 模式的每个 `e` 边都会被添加到 `@@edges_to_display` 累加器中。最后，初始子句
    `accts = SELECT t` 意味着此语句返回一个名为 `accts` 的顶点集，其中包含别名顶点 `t`。
- en: GSQL Accumulators
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GSQL 累加器
- en: '*Accumulators*, a unique feature of the GSQL language, are data objects that
    have a special operation called *accumulate*, indicated by the `+=` operator.
    The exact meaning of `+=` varies depending on the accumulator type, but it always
    is used to accept additional input data to update the accumulator’s external value.
    Accumulators can accept multiple asynchronous accumulate operations, and thus
    they are ideal for concurrent/parallel processing. The `@@` prefix indicates a
    global accumulator. A `@` prefix indicates a set of local (also known as vertex-attached)
    accumulators. `Local` means each vertex in the query has its own independent instance
    of this accumulator. For example, `@interact_size` is a local accumulator of type
    `SumAccum<INT>`. `SumAccum<INT>` is typically used to count.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*累加器* 是 GSQL 语言的一个独特特性，是具有特殊操作 *accumulate* 的数据对象，由 `+=` 运算符表示。`+=` 的确切含义取决于累加器类型，但它总是用于接受额外的输入数据以更新累加器的外部值。累加器可以接受多个异步累积操作，因此它们非常适合并发/并行处理。`@@`
    前缀表示全局累加器。`@` 前缀表示一组本地（也称为顶点附加）累加器。本地意味着查询中的每个顶点都有其自己独立的累加器实例。例如，`@interact_size`
    是类型为 `SumAccum<INT>` 的本地累加器。`SumAccum<INT>` 通常用于计数。'
- en: At [![4](assets/4.png)](#comarker4) we do something similar, but here we select
    the vertices and edges where the customer has a role in creating an `**Opportunity**`.
    The selected vertices are in the variable `Opps`; the selected edges are added
    to `@@edges_to_display`. Next, at [![5](assets/5.png)](#comarker5) we find the
    `**CampaignMember**` vertices that are connected to the customer and update `@@edges_to_display`
    again with the results. We then start from the `campaign_members` we selected
    in the previous step (`FROM campMems`) and find the vertices and edges of each
    `**CampaignMember**` that is part of a `**Campaign**`, then update `@@edges_to_display`
    again with the results at [![6](assets/6.png)](#comarker6). In [![7](assets/7.png)](#comarker7)
    we combine the vertices selected in steps [![3](assets/3.png)](#comarker3), [![4](assets/4.png)](#comarker4),
    [![5](assets/5.png)](#comarker5), and [![6](assets/6.png)](#comarker6) into one
    variable called `interactions`. Finally, we print (output) the input customer,
    its interactions, and their connecting edges (`@@_edges_to_display`). When the
    output contains vertices or edges, GraphStudio will display them graphically in
    the pane below the code pane. The output pane’s menu has options to format the
    output as JSON or tables as well.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在[![4](assets/4.png)](#comarker4)处我们执行类似操作，但在此处我们选择顾客在创建`**Opportunity**`时的顶点和边缘。所选的顶点存储在变量`Opps`中；所选的边缘添加到`@@edges_to_display`中。接下来，在[![5](assets/5.png)](#comarker5)处，我们找到与顾客连接的`**CampaignMember**`顶点，并再次用结果更新`@@edges_to_display`。然后，我们从前一步骤中选择的`campaign_members`开始(`FROM
    campMems`)，并找到每个是`**Campaign**`一部分的`**CampaignMember**`的顶点和边缘，然后在[![6](assets/6.png)](#comarker6)处再次用结果更新`@@edges_to_display`。在[![7](assets/7.png)](#comarker7)处，我们将步骤[![3](assets/3.png)](#comarker3)、[![4](assets/4.png)](#comarker4)、[![5](assets/5.png)](#comarker5)和[![6](assets/6.png)](#comarker6)中选择的顶点合并为一个名为`interactions`的变量。最后，我们打印（输出）输入的客户、其互动以及它们的连接边缘(`@@_edges_to_display`)。当输出包含顶点或边缘时，GraphStudio将在代码窗格下方的面板中以图形方式显示它们。输出窗格的菜单中有将输出格式化为JSON或表格的选项。
- en: Customer journey
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户旅程
- en: The  `customer_journey` query shows all `**CampaignMember**` and `**Account**`
    vertices that have a relationship with the customer during a given time period.
    Here we want to see more than just what marketing interactions a customer had;
    we want to see the sequence of activities. Let’s take a look at the GSQL implementation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`customer_journey`查询显示了在给定时间段内与客户有关系的所有`**CampaignMember**`和`**Account**`顶点。在这里，我们不仅想看到客户的市场互动，还想看到活动的顺序。让我们看看GSQL的实现。'
- en: 'This GSQL query takes four parameters:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此GSQL查询使用四个参数：
- en: '[PRE1]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first parameter is a vertex of type `**Contact**` and represents the customer
    that we are interested in. The second parameter is a list of campaign types to
    include. Leaving it empty will include all campaign types. The third and fourth
    parameters are of `DATETIME` types, and we use these parameters to determine the
    time window in which our query should be executed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是类型为`**Contact**`的顶点，表示我们感兴趣的客户。第二个参数是要包括的活动类型列表。如果留空将包括所有活动类型。第三和第四个参数是`DATETIME`类型，并且我们使用这些参数来确定查询应该执行的时间窗口。
- en: 'Next we take advantage of local accumulators to act like instance variables
    of a vertex class. We will add three string properties to each selected `**CampaignMember**`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们利用本地累加器来充当顶点类的实例变量。我们将为每个选择的`**CampaignMember**`添加三个字符串属性：
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'First we select the `**Account**` to which our target customer belongs:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们选择目标客户所属的`**Account**`：
- en: '[PRE3]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we select all `**CampaignMember**` vertices that are connected to the
    customer within the given time window:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们选择所有与给定时间窗口内的客户连接的`**CampaignMember**`顶点：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next we check that each of these `**CampaignMembers**` belongs to one of the
    campaign types designated in the input parameters. To do this, we need to traverse
    from each `**CampaignMember**` to its `**Campaign**`. While we are at it, we copy
    some information from the `**Campaigns**`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查每个这些`**CampaignMembers**`是否属于输入参数中指定的某个活动类型。为此，我们需要从每个`**CampaignMember**`到其`**Campaign**`进行遍历。在此过程中，我们从`**Campaigns**`复制一些信息：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `ORDER BY` clause at the end sorts the selected `**CampaignMember**` vertices
    by their effective date.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ORDER BY`子句最后按其生效日期对所选`**CampaignMember**`顶点进行排序。'
- en: The comments at the beginning of the query suggest some inputs to try. Click
    the Run Query button, then copy and paste the suggested inputs into the parameter
    text boxes on the left. For `campaign_type_set`, click the `+` symbol to add a
    value to the set. For the datetime parameters `start_time` and `end_time`, notice
    that GraphStudio accepts values in YYYY-MM-DD format. Scroll down if needed to
    get to the Run Query button. The output should include `**Contact**` `Sam-Eisenberg`,
    `**Account**` `VRG-Payments`, and seven `**CampaignMember**` elements. These are
    the components of Sam’s customer journey during the given time period.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 查询开头的注释建议尝试一些输入。单击“运行查询”按钮，然后将建议的输入复制并粘贴到左侧的参数文本框中。对于 `campaign_type_set`，单击
    `+` 符号以添加一个值到集合中。对于日期时间参数 `start_time` 和 `end_time`，请注意 GraphStudio 接受 YYYY-MM-DD
    格式的值。如有必要，请向下滚动到达“运行查询”按钮。输出应包括 `**Contact**` `Sam-Eisenberg`、`**Account**` `VRG-Payments`
    和七个 `**CampaignMember**` 元素。这些是 Sam 在给定时间段内的客户旅程的组成部分。
- en: 'To see the time sequence of the journey, switch to the JSON or table view output
    modes. Or you can run the `customer_journey_path` query, whose output is shown
    in [Figure 3-12](#output_of_customer_journey_path_query_f). It is identical to
    the `customer_journey` query, except for several extra lines of GSQL code, which
    insert directed edges from one `**CampaignMember**` vertex to the next. The code
    is a bit complex for this early in the book, so we won’t describe how it works.
    Also note that you need to run `customer_journey_path` twice: once to create the
    path edges, and again in order to see them.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看旅程的时间顺序，请切换到 JSON 或表格视图输出模式。或者您可以运行 `customer_journey_path` 查询，其输出显示在 [Figure 3-12](#output_of_customer_journey_path_query_f)
    中。它与 `customer_journey` 查询相同，除了几行额外的 GSQL 代码，这些代码插入了从一个 `**CampaignMember**` 顶点到下一个顶点的有向边。这本书的早期部分的代码有点复杂，所以我们不会详细描述它的工作原理。还要注意，您需要运行
    `customer_journey_path` 两次：一次用于创建路径边，再次用于查看它们。
- en: '![Output of customer_journey_path query for Sam-Eisenberg](assets/gpam_0312.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Sam-Eisenberg 的 customer_journey_path 查询输出](assets/gpam_0312.png)'
- en: Figure 3-12\. Output of `customer_journey_path` query for `Sam-Eisenberg` (see
    a larger version of this figure at [https://oreil.ly/gpam0312](https://oreil.ly/gpam0312))
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-12\. `Sam-Eisenberg` 的 `customer_journey_path` 查询输出（在 [https://oreil.ly/gpam0312](https://oreil.ly/gpam0312)
    上查看更大的版本）
- en: Similar customers
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相似的客户
- en: Before we implement similarity measures, we need to determine first for which
    attribute we want to compute the similarity. In our case, we want to compute the
    similarity for customers based on participation in similar sets of marketing campaigns.
    To measure this, we use Jaccard similarity. Jaccard similarity is not exclusively
    applicable for graph-structured data. It is a way to measure the similarity between
    two sets, based on how many items that belong to one set also belong to the other
    set, divided by the total number of distinct items appearing in either set. In
    the case of a graph, every vertex has a set of neighboring vertices. So graph-based
    Jaccard similarity measures the overlap of the neighbor set of one vertex with
    the neighbor set of another vertex. In other words, how many common neighbors
    are there, relative to the total number of neighbors?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实施相似性度量之前，我们需要首先确定要计算相似性的属性。在我们的情况下，我们希望根据参与类似市场活动集的客户来计算相似性。为了衡量这一点，我们使用
    Jaccard 相似性。Jaccard 相似性不仅适用于图结构数据。它是一种衡量两个集合相似度的方法，基于属于一个集合的项同时属于另一个集合的数量，除以两个集合中出现的所有不同项的总数。在图的情况下，每个顶点都有一组邻居顶点。因此，基于图的
    Jaccard 相似性衡量了一个顶点的邻居集与另一个顶点的邻居集之间的重叠程度。换句话说，共同邻居的数量相对于总邻居数是多少？
- en: Our situation is a little more complicated, because we want to assess the similarity
    of associations to campaigns; however, **`Campaigns`** are two hops away from
    **`Contacts`** rather than being directly connected. Furthermore, we allow the
    user to filter by types of campaigns to count.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的情况稍微复杂一些，因为我们想要评估与活动关联的相似性；然而，**`活动`**与**`联系人`**之间相距两步，而不是直接连接。此外，我们允许用户按活动类型进行筛选以计数。
- en: 'Let’s walk through the GSQL code for the `similar_contacts` query. This query
    accepts three parameters. The first parameter `source_customer` is a vertex of
    type `**Contact**` and represents the customer for whom we want to find similar
    customers. The second parameter is the set of campaign types (strings) that the
    user wants to consider. The third parameter is an integer value to determine how
    many similar customers we want to return:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们浏览`similar_contacts`查询的GSQL代码。此查询接受三个参数。第一个参数`source_customer`是类型为 **`Contact`**
    的顶点，代表我们要找到类似客户的客户。第二个参数是用户希望考虑的活动类型（字符串）集合。第三个参数是确定我们要返回多少个类似客户的整数值：
- en: '[PRE6]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We start with declaring four accumulators. The first three are integer counts:
    the number of campaigns for our input customer (`@@size_A`), the number of campaigns
    for each candidate contact (`@size_B`), and the number of campaigns that they
    have in common (`@size_intersection`). There’s only one input, so `@@size_A` is
    a global accumulator. The others are vertex-attached local accumulators. We also
    have a `FLOAT` type local accumulator to store the computed similarity value:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从声明四个累加器开始。前三个是整数计数：输入客户的活动数(`@@size_A`)，每个候选联系人的活动数(`@size_B`)，以及它们共同的活动数(`@size_intersection`)。只有一个输入，所以`@@size_A`是全局累加器。其他三个是附加到顶点的本地累加器。我们还有一个`FLOAT`类型的本地累加器来存储计算出的相似度值：
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then we get the value of `@@size_A` using the `outdegree()` function, specifying
    edge type **`is_connected_to`**:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`outdegree()`函数来获取`@@size_A`的值，指定边类型 **`is_connected_to`**：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we traverse from `source_customer` across two hops to go first to `**Campaign​Mem⁠⁠ber**`
    and then the `**Campaign**` vertices. This corresponds to steps 1 and 2 in [Figure 3-13](#overview_of_steps_for_selecting_the_sim).
    Note the `WHERE` clause for checking the campaign types:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从`source_customer`跨越两个跳到首先到`**Campaign​Mem⁠⁠ber**`，然后到`**Campaign**`顶点。这对应于
    [Figure 3-13](#overview_of_steps_for_selecting_the_sim) 中的步骤1和2。注意用于检查活动类型的`WHERE`子句：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Overview of steps for selecting the similar customers to calculate Jaccard
    similarity score](assets/gpam_0313.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![选择计算Jaccard相似度分数的相似客户步骤概览](assets/gpam_0313.png)'
- en: Figure 3-13\. Overview of steps for selecting the similar customers to calculate
    Jaccard similarity score
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-13。选择计算Jaccard相似度分数的相似客户步骤概览
- en: The next phase is a great example of the graph-based approach to analytics.
    This query’s task is “find all the Contacts B that have relationships similar
    to those of Contact A.” Rather than searching all possible **`Contacts`** and
    then comparing their relationships, we go to A’s related entities, then walk backward
    from there to candidate **`Contacts`**. These are steps 3 and 4 in [Figure 3-13](#overview_of_steps_for_selecting_the_sim).
    The reasoning is that this forward-then-backward walk across the relationships
    automatically filters out candidates that have nothing in common. And if we are
    clever, we can measure the degree of similarity while we are traversing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个阶段是分析的基于图的方法的一个很好的示例。此查询的任务是“查找所有具有与联系人A类似关系的联系人B”。而不是搜索所有可能的 **`Contacts`**，然后比较它们的关系，我们去到A的相关实体，然后从那里向候选
    **`Contacts`** 后退。这些是 [Figure 3-13](#overview_of_steps_for_selecting_the_sim)
    中的步骤3和4。推理是这种前进然后后退跨关系遍历会自动过滤掉没有共同点的候选者。如果我们聪明的话，在遍历时我们可以测量相似度的程度。
- en: 'Compare the GSQL code for step 3 with the code for step 2\. Notice how the
    directionality indicator for the directed edge changed from a > suffix to a <
    prefix:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 比较步骤3的GSQL代码与步骤2的代码。注意有向边的方向性指示符从 > 后缀变为 < 前缀：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The last hop is more complicated because it incorporates the Jaccard computation.
    The hop itself is as expected, with a `WHERE` clause to exclude going back to
    our `source_customer`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一跳更复杂，因为它包含Jaccard计算。跳跃本身如预期那样，有一个`WHERE`子句来排除回到我们的`source_customer`：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Recall that an `ACCUM` clause acts like a `FOREACH` block iterated across every
    path that satisfies the preceding `FROM-WHERE` clauses. The following code incrementally
    counts the size of the intersection between A’s and B’s campaign sets, and also
    sets `@size_B` for this particular **`Contact`**:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`ACCUM`子句就像是在满足前面的`FROM-WHERE`子句的每条路径上迭代的`FOREACH`块。以下代码逐步计算A和B活动集之间的交集大小，并为此特定的
    **`Contact`** 设置`@size_B`：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can calculate the Jaccard similarity. As its name implies, a `POST-ACCUM`
    clause usually takes place after an `ACCUM` clause. The two most important rules
    about `POST-ACCUM` are 1) it can use the accumulator results of the preceding
    `ACCUM` clause, and 2) it can only work with vertex variables, not edge variables.
    We use one of the standard formulations for Jaccard similarity. The denominator
    is equivalent to the number of unique items in sets A and B. The 1.0 in the numerator
    is to perform floating point arithmetic instead of integer arithmetic:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以计算Jaccard相似性了。顾名思义，`POST-ACCUM`子句通常在`ACCUM`子句之后执行。关于`POST-ACCUM`有两条最重要的规则：1）它可以使用前面`ACCUM`子句的累加器结果，2）它只能使用顶点变量，不能使用边变量。我们使用了Jaccard相似性的一个标准公式。分母等于集合A和B中唯一项的数量。分子中的1.0是为了执行浮点运算而不是整数运算。
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we order the resulting similarity score from highest to lowest, and
    we only take the `top_k` results to print:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们按照相似性得分从高到低排序，并只取`top_k`个结果进行打印：
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We went through the implementation of Jaccard similarity both to show you how
    easily some graph algorithms can be implemented in GSQL and to help you understand
    the approach if you want to write your own queries and analytics. TigerGraph provides
    an extensive library of prewritten graph data science algorithms, which we will
    present later in the book.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现Jaccard相似性来展示一些图算法在GSQL中的易实现性，同时帮助您理解该方法，以便如果您想编写自己的查询和分析时可以使用。TigerGraph提供了一个广泛的预写图数据科学算法库，我们将在本书的后面介绍。
- en: 'Case 2: Analyzing Drug Adverse Reactions'
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例2：分析药物不良反应
- en: In our second use case, we seek to analyze the adverse reactions to drug treatments.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第二个使用案例中，我们试图分析药物治疗的不良反应。
- en: Today’s healthcare system covers 30% of the world’s data volume, and its compound
    annual growth is projected to be 36% by 2025.^([3](ch03.html#ch01fn6)) This data
    collection ranges from external sources such as the US Food and Drug Administration
    (FDA) and National Databases Medical Associations to privately owned datasets
    from health insurance companies. Organizations mine this data for valuable insights
    to create targeted content and engagement campaigns, improve health insurance
    plans, and develop medicines. Developing better medical therapies is our focus
    for this use case.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的医疗系统涵盖了全球数据量的30%，其复合年增长率预计到2025年将达到36%。^[3](ch03.html#ch01fn6)这些数据来源于美国食品药品监督管理局（FDA）和国家数据库医学协会等外部来源，以及来自健康保险公司的私有数据集。组织利用这些数据获取有价值的洞见，创建针对性的内容和参与活动，改善健康保险计划，并开发药物。开发更好的医疗疗法是我们此用例的重点。
- en: When developing medicines, it is vital to have clear insight into the composition
    of drugs, how they interact with one another, and what side effects they might
    cause. Therefore, the FDA requires every drug manufacturer to monitor how its
    drugs are being used with other drugs and report on any adverse reaction.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发药物时，清楚地了解药物的组成、它们如何相互作用以及可能引起的副作用至关重要。因此，FDA要求每家药品制造商监控其药物与其他药物的使用情况，并报告任何不良反应。
- en: Analysts and researchers want to find relationships among various drugs, patients
    who use them, and the possible side effects. Do doctors prescribe the same drug
    to people in a particular postal district, or are their assessments mainly built
    upon patients who went to the same college? When a patient reports an adverse
    reaction to a given drug, other patients might also be in danger, given their
    drug interaction history. Without a view of how these drug interactions occur
    and to whom the drugs prescriptions are given, research in this field becomes
    challenging, and it could threaten public health when vital links between drugs
    and side effects are overlooked.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 分析师和研究人员希望找出各种药物、使用这些药物的患者以及可能的副作用之间的关系。医生是否会给同一个邮政区域的人开同一种药物，或者他们的评估主要建立在去同一所大学的患者基础上？当患者报告对某种药物有不良反应时，其他患者可能也面临危险，因为他们的药物相互作用历史。如果没有了解这些药物相互作用发生的方式以及给予这些药物处方的对象，该领域的研究将变得困难，并且当药物和副作用之间的重要联系被忽视时，可能会对公共健康构成威胁。
- en: 'Solution: Drug Interaction 360 Graph'
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案：药物交互360图
- en: The growing amount of healthcare data brings challenges in combining external
    and internal data sources at a large scale and presenting this in a meaningful
    way. The applications in this domain require an approach that can not only handle
    this large amount of data but also find hidden patterns among the various data
    sources.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 日益增长的医疗数据量带来了在大规模结合外部和内部数据源并以有意义的方式展示这些数据的挑战。这个领域的应用需要一种方法，既能处理这么大量的数据，又能在各种数据源中找到隐藏的模式。
- en: Graph databases are an ideal data platform for the discovery and analysis of
    drug interactions. With a graph database, we can form a 360 view of key entities
    and connect the dots to expose all possible correlations among patients, the drug
    interactions that have incurred, and the manufacturers of those drugs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据库是发现和分析药物相互作用的理想数据平台。通过图数据库，我们可以形成关键实体的360视图，并连接这些关键实体以揭示患者之间的所有可能相关性，以及这些药物的制造商。
- en: In contrast, relational and NoSQL databases store data in separate tables and
    rely on the analyst’s domain expertise to choose which tables to join, and each
    join is an expensive operation. The discovery of interactions and correlations
    is limited to the particular cases that the analysts checked by forming particular
    sequences of table joins. For this case, a tabular structure is less conducive
    to scientific discovery than a graph structure.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，关系数据库和NoSQL数据库将数据存储在单独的表中，并依赖于分析师的领域专业知识来选择要连接的表，每次连接都是一次昂贵的操作。发现相互作用和相关性仅限于分析师检查的特定情况，形成特定表连接序列。对于这种情况，表格结构不如图结构有利于科学发现。
- en: Implementation
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: To illustrate a drug interaction 360 graph, we will use the TigerGraph Cloud
    Starter Kit called “Healthcare Graph (Drug Interaction/FAERS).” To follow along,
    see the earlier instructions for how to deploy a TigerGraph Cloud Starter Kit.
    Load the data and install the queries.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一个药物相互作用360图，我们将使用名为“Healthcare Graph（Drug Interaction/FAERS）”的TigerGraph
    Cloud Starter Kit。要跟进，请查看之前的说明，了解如何部署TigerGraph Cloud Starter Kit，加载数据并安装查询。
- en: The data we are using for this use case is publicly available from the US FDA.
    It contains quarterly data from the FDA’s Adverse Event Reporting System (FAERS),
    including demographic and administrative information on the drug, patient outcome,
    and reaction from case reports. The FDA releases the data as seven tables. The
    documentation includes an entity-relationship diagram, which is suggestive of
    a two-hub 360 graph. However, investigating this data using relational database
    techniques would require creating many join tables. With graph databases, we can
    traverse these relationships much easier.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于此用例的数据来自美国FDA公开可用的数据。它包括FDA不良事件报告系统（FAERS）的季度数据，包括药品的人口统计和行政信息，患者结果以及案例报告中的反应。FDA将数据发布为七个表格。文档包括一个实体关系图，表明了一个双中心360图的可能性。然而，使用关系数据库技术调查这些数据将需要创建许多连接表。使用图数据库，我们可以更轻松地遍历这些关系。
- en: Graph Schema
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图模式
- en: To improve the visibility and analysis of the data, we propose to transform
    the seven tables into 10 vertex types and 10 edge types. We split the `Drug` table
    into `**Drug**` and `**DrugSequence**` vertex types, and we split the `Demographic`
    table into `**ReportedCase**`, `**Patient**`, and `**PharmaCompany**` tables.
    These splits give us the agility to shift our focus as needed and to more easily
    see the interplay between different factors. For every `**ReportedCase**`, we
    can find information about the patient, the drug manufacturer, the patient’s reaction,
    the source of the report, the outcome, and the various drugs the patient has been
    taking. For every `**DrugSequence**`, we can find the related drug, the indication,
    and the patient’s therapy.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高数据的可见性和分析能力，我们建议将这七个表格转换为10种顶点类型和10种边类型。我们将`**Drug**`表格分成`**Drug**`和`**DrugSequence**`顶点类型，将`Demographic`表格分成`**ReportedCase**`、`**Patient**`和`**PharmaCompany**`表格。这些分割使我们能够根据需要调整焦点，并更容易地看到不同因素之间的相互作用。对于每个`**ReportedCase**`，我们可以找到关于患者、药品制造商、患者反应、报告来源、结果以及患者正在服用的各种药物的信息。对于每个`**DrugSequence**`，我们可以找到相关药品、指示以及患者的疗法。
- en: '[Table 3-2](#vertex_types_in_the_drug_information_mo) describes the 10 vertex
    types, and [Figure 3-14](#graph_schema_of_drug_information_data) shows how they
    are connected. The starter kit contains data from one calendar quarter. In total,
    there are 1.87M vertices and 3.35M edges.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 3-2](#vertex_types_in_the_drug_information_mo) 描述了 10 种顶点类型，而 [图 3-14](#graph_schema_of_drug_information_data)
    显示了它们的连接方式。起始套件包含一个日历季度的数据。总计有 1.87M 个顶点和 3.35M 条边。'
- en: Table 3-2\. Vertex types in the Drug Information model
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 3-2\. 药品信息模型中的顶点类型
- en: '| Vertex type | Description | Instances |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: 顶点类型 | 描述 | 实例数 |
- en: '| --- | --- | --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `**DrugSequence**` | A sequence of `**Drug**` elements | 689,312 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `**药品序列**` | 一系列 `**药品**` 元素 | 689,312 |'
- en: '| `**Drug**` | A drug that is part of a `**DrugSequence**` | 40,622 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `**药品**` | 作为 `**药品序列**` 一部分的药物 | 40,622 |'
- en: '| `**Indication**` | An indication (medical condition) that can be treated
    with a `**DrugSequence**` | 422,145 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `**适应症**` | 可以用 `**药品序列**` 治疗的适应症（医疗状况） | 422,145 |'
- en: '| `**Therapy**` | A therapy where the `**DrugSequence**` is used | 268,244
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `**治疗**` | 使用 `**药品序列**` 的治疗方法 | 268,244 |'
- en: '| `**ReportedCase**` | A reported case of side effects | 211,414 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `**报告病例**` | 副作用的报告案例 | 211,414 |'
- en: '| `**Patient**` | A person who reported a case | 211,414 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `**患者**` | 报告案例的人 | 211,414 |'
- en: '| `**Outcome**` | A result after assessment of a `**ReportedCase**` | 7 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `**结果**` | 对 `**报告病例**` 进行评估后的结果 | 7 |'
- en: '| `**ReportSource**` | A source type for a `**ReportedCase**` | 9 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `**报告来源**` | 用于 `**报告病例**` 的来源类型 | 9 |'
- en: '| `**Reaction**` | A reaction from a `**ReportedCase**` | 9,791 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `**反应**` | 从 `**报告病例**` 得到的反应 | 9,791 |'
- en: '| `**PharmaCompany**` | A pharmaceutical company that manufactures a **`Drug`**
    | 7,740 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `**制药公司**` | 生产 **`药品`** 的制药公司 | 7,740 |'
- en: '![Graph schema of Drug Information data](assets/gpam_0314.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![药品信息数据的图模式](assets/gpam_0314.png)'
- en: Figure 3-14\. Graph schema of Drug Information data (see a larger version of
    this figure at [https://oreil.ly/gpam0314](https://oreil.ly/gpam0314))
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-14\. 药品信息数据的图模式（在 [https://oreil.ly/gpam0314](https://oreil.ly/gpam0314)
    查看更大的版本）
- en: Queries and Analytics
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询和分析
- en: The drug interaction starter kit comes with three queries as examples of drug
    interaction analysis. From these examples, a studious analyst can see how to construct
    other queries and even more complex queries.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 药物相互作用起始套件提供了三个示例，用于药物相互作用分析。通过这些示例，勤奋的分析师可以看到如何构建其他查询，甚至更复杂的查询。
- en: Find similar reported cases based on reactions
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 基于反应查找类似报告案例
- en: Finding cases with similar sets of reactions can lead to understanding root
    causes. This query starts from a given reported case and calculates its similarity
    to other cases, based on the similarity of reactions of the patients. Then it
    returns the top-scoring similar cases.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找具有类似反应集的案例可以帮助理解根本原因。该查询从给定的报告案例开始，计算其与其他案例的相似性，基于患者反应的相似性。然后返回得分最高的类似案例。
- en: Most reported drugs for a company
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 公司报告的大多数药物
- en: Pharmaceutical companies want to know which of their drugs are receiving the
    most reports of adverse reactions. Government regulatory agencies might also want
    to know this. This query performs that calculation for them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 制药公司想知道他们的药物中哪些收到了最多的不良反应报告。政府监管机构也可能对此感兴趣。此查询为他们执行此计算。
- en: Top side effects for top drugs
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的顶级药物副作用
- en: Pharmaceuticals and regulators want to know not only which drugs are being reported
    but also what the top side effects are. This query selects the topmost `**Drug**`
    type for a given `**Company**` and counts how many times each `**Reaction**` for
    that drug is reported.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 制药公司和监管机构想要知道报告的不仅仅是哪些药物，还想知道最常见的副作用是什么。该查询选择给定 `**公司**` 的最高 `**药品**` 类型，并计算该药物的每种
    `**反应**` 被报告的次数。
- en: Find similar reported cases
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找类似的报告案例
- en: Things that have similar characteristics are similar, but how exactly do we
    measure this? You must decide what characteristics matter and how to assess the
    strength of similarity. In a graph, an entity’s characteristics include not only
    its attributes but also its relationships. Looking at [Figure 3-14](#graph_schema_of_drug_information_data),
    you can see that `**ReportedCase**` is surrounded by relationships to six other
    vertex types, which are all potential similarity factors. It also has an edge
    type `**similarCaseTo**`, where the results of similarity calculations can be
    stored.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有相似特征的事物是相似的，但究竟如何度量？您必须决定哪些特征重要以及如何评估相似性的强度。在图中，实体的特征不仅包括其属性，还包括其关系。查看 [图 3-14](#graph_schema_of_drug_information_data)，您可以看到
    `**ReportedCase**` 周围与其他六种顶点类型的关系，这些都是潜在的相似性因素。它还有一种边缘类型 `**similarCaseTo**`，可以在那里存储相似性计算的结果。
- en: 'The query implements relationship-based similarity scoring: `jaccard_nbor_reaction`.
    The query’s first argument, `source`, is the `**ReportedCase**` of interest. The
    `etype` argument specifies what type of relationships to consider. The `top_k`
    argument determines how many reported cases the query returns, and `sampSize`
    invokes sampling if each instance of a `**Reaction**` (or other characteristic)
    has more than this threshold number of related cases.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 查询实现基于关系的相似度评分：`jaccard_nbor_reaction`。查询的第一个参数 `source` 是感兴趣的 `**ReportedCase**`。`etype`
    参数指定要考虑的关系类型。`top_k` 参数确定查询返回的报告案例数，而 `sampSize` 如果每个 `**Reaction**` 实例有超过此阈值的相关案例则调用抽样。
- en: Once we specify which characteristics to consider, we still need to apply a
    formula for measuring similarity. This query uses Jaccard similarity, the most
    commonly used measure when the property is categorical rather than numeric. We
    only know if a reaction occurs, not its strength, so the data is categorical.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们指定要考虑的特征，仍然需要应用一个用于测量相似性的公式。此查询使用 Jaccard 相似度，当属性是分类而不是数值时，这是最常用的测量方法。我们只知道反应是否发生，而不知其强度，因此数据是分类的。
- en: '[PRE15]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Similar to the first query in our first case example, we need to define the
    vertices where we start our traversal. We do this at [![1](assets/1.png)](#comarker1-2).
    Then to compute the Jaccard calculation, we need the size of the source vertex’s
    neighbor set, which we obtain by applying the `out_degree` function and specifying
    `etype` at [![2](assets/2.png)](#comarker2-2). At [![3](assets/3.png)](#comarker3),
    we collect `**Neighbors**` by traversing from `Start` over every `etype` edge.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们第一个案例示例中的第一个查询，我们需要定义从哪些顶点开始遍历。我们在 [![1](assets/1.png)](#comarker1-2) 处进行此操作。然后，为了计算
    Jaccard 计算，我们需要源顶点的邻居集大小，我们通过应用 `out_degree` 函数并在 [![2](assets/2.png)](#comarker2-2)
    处指定 `etype` 来获取此信息。在 [![3](assets/3.png)](#comarker3) 处，我们通过从 `Start` 到每个 `etype`
    边缘的遍历来收集 `**Neighbors**`。
- en: 'The expression `Start:s-(etype:e)-:t`, at [![4](assets/4.png)](#comarker4-2),
    represents a traversal pattern in the graph. This particular pattern means:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `Start:s-(etype:e)-:t` 在图中表示遍历模式，位于 [![4](assets/4.png)](#comarker4-2)。此特定模式意味着：
- en: Begin with a member of the set `Start`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以集合成员 `Start` 开始。
- en: Connect to an edge of type `etype`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到类型为 `etype` 的边缘。
- en: Through that edge, arrive at any target vertex.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过该边缘，到达任何目标顶点。
- en: 'The expression also defines three aliases for the three parts of the pattern:
    `s`, `e`, and `t`. The result of the `FROM` clause is a set of tuples (`s`, `e`,
    `t`) that satisfy the pattern. The alias `t` represents a member of the set of
    target vertices. These aliases are local; they can only be used within this `SELECT`
    block. They are unrelated to the aliases in other `SELECT` blocks.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 该表达式还为模式的三个部分定义了三个别名：`s`、`e` 和 `t`。`FROM` 子句的结果是满足模式的元组集合 (`s`, `e`, `t`)。别名
    `t` 表示目标顶点集的成员。这些别名是局部的，只能在此 `SELECT` 块内使用。它们与其他 `SELECT` 块中的别名无关。
- en: At [![5](assets/5.png)](#comarker5-2) we select other vertices. We do this by
    checking if `etype` is `reactionTo`; then `Neighbors` will comprise all the `**Reactions**`
    of the given source `**ReportedCase**`. Then we build a set of `**ReportedCases**`
    by traversing from the `Neighbors` across `etype` edges again. If the out degree
    of a neighbor is greater than `sampSize`, we traverse only a sample of the connecting
    edges. We exclude the source vertex from the selection at [![6](assets/6.png)](#comarker6-2).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [![5](assets/5.png)](#comarker5-2) 处，我们选择其他顶点。我们通过检查 `etype` 是否为 `reactionTo`
    来执行此操作；然后 `Neighbors` 将包括给定源 `**ReportedCase**` 的所有 `**Reactions**`。然后我们通过再次遍历
    `etype` 边，从 `Neighbors` 构建一组 `**ReportedCases**`。如果邻居的出度大于 `sampSize`，我们只遍历连接边的一个样本。我们在
    [![6](assets/6.png)](#comarker6-2) 处排除源顶点的选择。
- en: '[PRE16]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: This pattern (traverse to neighbors, traverse back along the same edge type,
    exclude the starting vertex) is a common technique to find entities that have
    something in common with the starting entity. It is the graph-based technique
    for collaborative filtering recommendation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式（遍历邻居，沿着相同的边类型返回遍历，排除起始顶点）是一种常见的技术，用于查找与起始实体有共同点的实体。这是基于图的协同过滤推荐的技术。
- en: 'At [![7](assets/7.png)](#comarker7-2) we compute the Jaccard similarity score
    between the source vertex and each member of `Others`. Given two sets A and B,
    *Jaccard*(A, B) is defined as:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [![7](assets/7.png)](#comarker7-2) 处，我们计算源顶点与每个 `Others` 成员之间的 Jaccard 相似性分数。给定两个集合
    A 和 B，*Jaccard*(A, B) 定义为：
- en: (intersection of A and B) / (size of A + size of B – intersection of A and B)
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (A 和 B 的交集) / (A 的大小 + B 的大小 - A 和 B 的交集)
- en: 'The efficient GSQL implementation is a little subtle. We will not go into line-by-line
    detail, but we will point out two paradigms:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 高效的 GSQL 实现略微复杂。我们不会逐行详细说明，但我们会指出两种范例：
- en: In our case, the sets are composed of neighbors of A and B. We do not start
    from sets A and B and then compute their intersection. We start from A, go to
    its neighbors, then go to their neighbors. This finds all B sets such that intersection(A,B)
    is not empty.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的情况下，集合由 A 和 B 的邻居组成。我们不是从集合 A 和 B 开始计算它们的交集，而是从 A 开始，然后进入其邻居，再进入它们的邻居。这样可以找到所有的
    B 集合，使得 intersection(A, B) 不为空。
- en: We use distributed processing to perform operations on multiple members of a
    set concurrently. The `ACCUM` and `POST-ACCUM` clauses in GSQL are implicit `FOREACH`
    loops, specifying what to do for each member of the iteration sets. The order
    of iteration is unspecified. The TigerGraph compute engine may operate on multiple
    iterations concurrently.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用分布式处理同时对一组成员执行操作。在 GSQL 中，`ACCUM` 和 `POST-ACCUM` 子句是隐式的 `FOREACH` 循环，指定了对每个迭代集的操作。迭代顺序未指定。TigerGraph
    计算引擎可以同时处理多个迭代。
- en: An `ACCUM` clause acts like a `FOREACH` loop on each set of connected vertices
    and edges that satisfy the preceding `FROM/SAMPLE/WHERE` clauses, that is, on
    each pattern tuple. In this `SELECT` block, `s` refers to a member of `Neighbors`,
    which is a `**Reaction**`, and `t` refers to a `**ReportedCase**` having that
    `**Reaction**`. A `POST-ACCUM` clause is another `FOREACH` loop, but it can only
    operate on one vertex alias (e.g., either `s` or `t`).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACCUM` 子句在满足前面的 `FROM/SAMPLE/WHERE` 子句的连接顶点和边的每组模式元组上充当 `FOREACH` 循环的角色。在这个
    `SELECT` 块中，`s` 表示 `Neighbors` 的成员，它是一个 `**Reaction**`，而 `t` 表示具有该 `**Reaction**`
    的 `**ReportedCase**`。`POST-ACCUM` 子句是另一个 `FOREACH` 循环，但它只能在一个顶点别名上操作（例如 `s` 或
    `t`）。'
- en: At [![7](assets/7.png)](#comarker7-2) we order the `Others` vertices by descending
    similarity score and then prune the set to include only the `top_k` vertices.
    Finally, we print all the vertices in `Others` and the `@@t_Size` value.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [![7](assets/7.png)](#comarker7-2) 处，我们按照降序相似性分数对 `Others` 顶点进行排序，然后将集合修剪为仅包括
    `top_k` 个顶点。最后，我们打印 `Others` 中的所有顶点以及 `@@t_Size` 的值。
- en: 'Running the query with suggested source case `100640876` and then viewing the
    results in tabular form, we discover three `**ReportedCase**` instances with a
    perfect similarity score of 1: `103126041`, `101749293`, and `102852841`. Then
    there are several others with similarity scores of 0.5.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用建议的源案例 `100640876` 运行查询，然后以表格形式查看结果，我们发现三个具有完美相似度分数 1 的 `**ReportedCase**`
    实例：`103126041`、`101749293` 和 `102852841`。然后还有一些其他的相似度分数为 0.5 的实例。
- en: Most reported drug for a company
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公司报告的最多的药物
- en: 'The `most_reported_drugs_for_company` query takes three parameters. The first
    parameter, `company_name`, selects the company for which we want to find the topmost
    reported drugs. The second parameter `k` determines how many drug types we wish
    to return. Lastly, the third parameter filters `DrugSequence` elements with the
    given `role` value:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`most_reported_drugs_for_company`查询有三个参数。 第一个参数`company_name`选择要查找其最多报道药物的公司。
    第二个参数`k`确定我们希望返回多少种药物类型。 最后一个参数用于过滤具有给定`role`值的`DrugSequence`元素：'
- en: '[PRE17]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Reflect on the words “most *reported drug* for a *company*.” We can logically
    conclude that the query must traverse `**ReportedCase**`, `**Drug**`, and `**PharmaCompany**`
    vertices. Take a look back at [Figure 3-14](#graph_schema_of_drug_information_data)
    to see how these vertex types are connected:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 反思“公司的最*报道药物*”。 我们可以推断出这个查询必须遍历`**ReportedCase**`、`**Drug**`和`**PharmaCompany**`顶点。
    回顾一下[图3-14](#graph_schema_of_drug_information_data)看看这些顶点类型是如何连接的：
- en: '`**Drug – DrugSequence – ReportedCase – PharmaCompany**`'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`**药物 – DrugSequence – ReportedCase – 制药公司**`'
- en: There are three hops from `**Drug**` to `**PharmaCompany**`; our query will
    perform its work in three stages. Composing GSQL as multistage procedures instead
    of multiple separate queries enables the use of accumulators as temporary storage
    values for both performance and functionality.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从`**药物**`到`**制药公司**`有三个跳跃；我们的查询将分三个阶段完成其工作。将GSQL组合为多阶段过程而不是多个单独的查询，可以使用累加器作为临时存储值，既提高性能又增强功能性。
- en: 'First, we find all the `**ReportedCase**` vertices that relate to the company
    given as an input parameter. Drilling down: we build a vertex set that contains
    all the `**Company**` vertices, because GSQL requires that a graph traversal begin
    with a vertex set. Then we select all the `**ReportedCase**` vertices that link
    to a `**Company**` vertex, as long as that company’s name matches the `company_name`
    argument:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们找到与输入参数中给定公司相关的所有`**ReportedCase**`顶点。 深入挖掘：我们构建一个包含所有`**Company**`顶点的顶点集，因为GSQL要求图遍历从一个顶点集开始。
    然后，我们选择所有链接到`**Company**`顶点的`**ReportedCase**`顶点，只要该公司的名称与`company_name`参数匹配：
- en: '[PRE18]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then traverse from the selected **`ReportedCase`** vertices from the set
    that we collected above to their associated `**DrugSequence**` vertices. After
    that, we filter the `**DrugSequence**` set to only include those whose role matches
    the query’s `role` argument:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从上面收集的选定的**`ReportedCase`**顶点开始遍历到其关联的`**DrugSequence**`顶点。 然后，我们过滤`**DrugSequence**`集合，只包括其角色与查询的`role`参数匹配的那些：
- en: '[PRE19]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the final part of the code, we connect the `**DrugSequence**` vertices that
    we selected in the second part with their associated `**Drug**` vertices. Of course,
    we need to do more than just find the drugs. We count how many cases feature a
    particular drug, then sort the drugs by decreasing count, and select the `k` most
    frequently mentioned drugs:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的最后部分，我们将第二部分中选择的`**DrugSequence**`顶点与其相关的`**Drug**`顶点连接起来。 当然，我们不仅仅是查找药物。
    我们统计了特定药物出现的案例数，然后按出现次数降序排序，并选择出现频率最高的`k`种药物：
- en: '[PRE20]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Running this query with default input values (`company_name="PFIZER", k=5, role="PS"`),
    we get the drugs Lyrica, Lipitor, Chantix, Celebrex, and Viagra. Looking at the
    JSON or tabular output, we see the number of cases are 2682, 1259, 1189 ,1022,
    and 847, respectively.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认输入值（`company_name="PFIZER", k=5, role="PS"`）运行此查询，我们得到Lyrica、Lipitor、Chantix、Celebrex和Viagra这些药物。
    查看JSON或表格输出，我们可以看到案例数分别为2682、1259、1189、1022和847。
- en: Top side effects for top drugs
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最受欢迎的药物的顶部副作用
- en: 'The query `top_side_effects_for_top_drugs` returns the top side effect for
    the most reported `**Drug**` of a given `**Company**`*.* Like the previous query,
    it also wants to find the most reported drug of a company, but it does additional
    work to count the side effects. Its parameter list looks the same as that of `most_reported_drugs_for_company`;
    however, here `k` refers to not only the topmost reported drugs but also the topmost
    frequent side effects:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 查询`top_side_effects_for_top_drugs`返回给定`**公司**`最多报道的`**药物**`的顶部副作用*.* 与之前的查询类似，它还想找到公司的最多报道药物，但也额外工作来计算副作用。
    其参数列表与`most_reported_drugs_for_company`相同，但这里`k`不仅指最多报道的药物，还指最频繁的副作用：
- en: '[PRE21]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we did for the previous query, let’s look at the name and description of
    the query to understand what vertex and edge types we must traverse. We can see
    that we need to include `**ReportedCase**`, `**Drug**`, and `**PharmaCompany**`,
    as well as `**Reaction**` (side effect). This sets up a Y-shaped graph traversal
    pattern:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为上一个查询所做的那样，让我们看一下查询的名称和描述，以了解我们必须遍历哪些顶点和边类型。我们可以看到，我们需要包括`**ReportedCase**`、`**Drug**`和`**PharmaCompany**`，以及`**Reaction**`（副作用）。这建立了一个Y形图遍历模式：
- en: '[PRE22]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This query has five stages. Stages 1, 3, and 4 of this query are the same or
    are slightly enhanced versions of Stages 1, 2, and 3 in the `most_reported_drugs_for_company`
    query.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询有五个阶段。这个查询的第1、3和4阶段与`most_reported_drugs_for_company`查询中的第1、2和3阶段相同或略有增强。
- en: 'Stage 1 is the same as Stage 1 of `most_reported_drugs_for_company`—find all
    the `**ReportedCase**` vertices that relate to the company given as an input parameter:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 第1阶段与`most_reported_drugs_for_company`中的第1阶段相同——查找与作为输入参数给定的公司相关的所有`**ReportedCase**`顶点：
- en: '[PRE23]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Stage 2 is new: now that we have a set of `**ReportedCase**` vertices, we can
    count their associated **`Reactions`**. We traverse all the `**ReportedCase**`
    `**–**` `**Reaction**` edges and then add each reaction type `r.pt` of a case
    `c` to a string list attached to that case `c`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第2阶段是新的：现在我们有了一组`**ReportedCase**`顶点，我们可以计算它们关联的**`Reactions`**。我们遍历所有`**ReportedCase**`
    `**–**` `**Reaction**`边，并将每个病例`c`的反应类型`r.pt`添加到附加到该病例`c`的字符串列表中：
- en: '[PRE24]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In Stage 3, we then traverse from the selected `**ReportedCase**` vertices
    from Stage 1 to their associated `**DrugSequence**` vertices. We perform the traversal
    first, and then filter the `**DrugSequence**` set to include only those whose
    role matches the query’s `role` argument. After that, we copy the list of reactions
    attached to `**ReportedCase**` vertices to their associated `**DrugSequences**`.
    This last step is a GSQL technique to move data to where we need it:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三阶段，我们从第一阶段选择的`**ReportedCase**`顶点开始遍历它们关联的`**DrugSequence**`顶点。我们首先执行遍历，然后过滤`**DrugSequence**`集合，仅包括其角色与查询的`role`参数匹配的部分。之后，我们将附加到`**ReportedCase**`顶点的反应列表复制到其关联的`**DrugSequences**`。这最后一步是一种GSQL技术，用于将数据移动到我们需要的位置：
- en: '[PRE25]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In Stage 4, we connect the `**DrugSequence**` vertices selected in Stage 2
    with their associated `**Drug**` vertices. Besides counting the number of cases
    for a drug, we also count the occurrences of each `**Reaction**`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4阶段，我们将第2阶段选择的`**DrugSequence**`顶点与其关联的`**Drug**`顶点连接起来。除了计算药物的病例数之外，我们还计算每个`**Reaction**`的发生次数：
- en: '[PRE26]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, in Stage 5, we take only the top `k` side effects. We do this by counting
    each `reaction` in `tally`, sorting them in descending order, and returning the
    top ones:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第5阶段，我们只取前`k`个副作用。我们通过计数`tally`中的每个`reaction`，按降序排序，并返回前几个：
- en: '[PRE27]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you run this query with the default inputs (which are the same as those
    of the previous query), the visual output looks the same. The difference is the
    `TopDrugs.@top_Reactions` accumulator. The best way to see this is to look at
    the JSON output. For Lyrica, the most reported drug from Pfizer, we have the following
    values:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用默认输入运行此查询（与上一个查询相同），则视觉输出看起来相同。区别在于`TopDrugs.@top_Reactions`累加器。最好的方法是查看JSON输出。对于来自辉瑞的最多报告的药物Lyrica，我们有以下数值：
- en: '[PRE28]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Chapter Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: In this chapter, we delved into two use cases to demonstrate the power of graphs
    to help users see the relationships in their data more clearly and completely.
    We introduced TigerGraph Starter Kits—demonstration databases and queries, preinstalled
    on TigerGraph Cloud instances—that show the basics of a variety of different use
    cases. We walked through the process of obtaining and installing a Customer 360
    starter kit. At the same time, we walked through the first several steps of using
    GraphStudio, TigerGraph’s graphical user interface.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了两个用例，以展示图形的强大之处，帮助用户更清晰、更全面地看到其数据中的关系。我们介绍了TigerGraph Starter Kits——预先安装在TigerGraph
    Cloud实例上的演示数据库和查询，展示了各种不同用例的基础知识。我们演示了获取和安装Customer 360 starter kit的过程。同时，我们还演示了使用GraphStudio的前几个步骤。
- en: We also introduced you to GSQL, the procedural SQL-like graph query language
    used by the TigerGraph graph database. Readers who know SQL and a conventional
    programming language should be able to learn GSQL without much trouble. To demonstrate
    how GSQL can help our analysis with graphs, we delved into two use cases. In the
    first use case, we defined a customer journey and described how sales groups benefit
    from recording and analyzing them. We then showed how a Customer 360 graph provides
    a powerful and flexible way to integrate customer data, which can then be represented
    as customer journeys. We walked through the three GSQL queries, which explore
    and analyze the customer journeys. In the second use case, we showed how a 360
    graph can be used to show all the possible interactions and correlations among
    drugs used for medical treatment. Such analysis is vital for detecting and then
    taking action on adverse side effects.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向您介绍了GSQL，这是TigerGraph图数据库使用的类SQL过程化图查询语言。了解SQL和传统编程语言的读者应该可以轻松学习GSQL。为了展示GSQL如何在我们的图分析中发挥作用，我们深入探讨了两个用例。在第一个用例中，我们定义了一个客户旅程，并描述了销售团队如何通过记录和分析客户旅程来获益。然后，我们展示了Customer
    360图如何提供一个强大而灵活的集成客户数据的方式，然后可以将其表示为客户旅程。我们详细介绍了三个GSQL查询，这些查询用于探索和分析客户旅程。在第二个用例中，我们展示了如何使用360图显示用于医疗治疗的药物之间所有可能的交互和相关性。这样的分析对于检测并采取有害副作用非常重要。
- en: ^([1](ch03.html#ch01fn4-marker)) “CRM Market Share—Salesforce Bright Future
    in 2020,” Nix United, February 19, 2020, [*https://nix-united.com/blog/crm-market-share-salesforce-bright-future-in-2020*](https://nix-united.com/blog/crm-market-share-salesforce-bright-future-in-2020).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#ch01fn4-marker)) “CRM Market Share—Salesforce Bright Future
    in 2020,” Nix United，2020年2月19日，[*https://nix-united.com/blog/crm-market-share-salesforce-bright-future-in-2020*](https://nix-united.com/blog/crm-market-share-salesforce-bright-future-in-2020)。
- en: ^([2](ch03.html#ch01fn5-marker)) “Market Share of CRM Leading Vendors Worldwide
    2016–2020,” Statista, June 13, 2022, [*https://www.statista.com/statistics/972598/crm-applications-vendors-market-share-worldwide*](https://www.statista.com/statistics/972598/crm-applications-vendors-market-share-worldwide).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.html#ch01fn5-marker)) “Market Share of CRM Leading Vendors Worldwide
    2016–2020,” Statista，2022年6月13日，[*https://www.statista.com/statistics/972598/crm-applications-vendors-market-share-worldwide*](https://www.statista.com/statistics/972598/crm-applications-vendors-market-share-worldwide)。
- en: ^([3](ch03.html#ch01fn6-marker)) “The Healthcare Data Explosion,” RBC Capital
    Markets, accessed May 21, 2023, [*https://www.rbccm.com/en/gib/healthcare/episode/the_healthcare_data_explosion*](https://www.rbccm.com/en/gib/healthcare/episode/the_healthcare_data_explosion).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.html#ch01fn6-marker)) “The Healthcare Data Explosion,” RBC Capital
    Markets，访问日期为2023年5月21日，[*https://www.rbccm.com/en/gib/healthcare/episode/the_healthcare_data_explosion*](https://www.rbccm.com/en/gib/healthcare/episode/the_healthcare_data_explosion)。
