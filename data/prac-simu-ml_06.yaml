- en: Chapter 4\. Creating a More Advanced Simulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章\. 创建更高级的模拟
- en: So far, you’ve been introduced to the basics of simulation and the basics of
    synthesis. It’s time to dive in a bit further and do some more simulation. Back
    in [Chapter 2](ch02.html#chapter-creating-first-simulation), we built a simple
    simulation environment that showed you how easy it is to assemble a scene in Unity
    and use it to train an agent.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解了模拟的基础知识和综合的基础知识。现在是时候深入一些，进行更多的模拟了。回到[第 2 章](ch02.html#chapter-creating-first-simulation)，我们建立了一个简单的模拟环境，向您展示了在
    Unity 中组装场景并用它来训练代理是多么容易。
- en: In this chapter, we’re going to build on the things you’ve already learned and
    create a slightly more advanced simulation using the same fundamental principles.
    The simulation environment we’re going to build is shown in [Figure 4-1](#fig:secondSim).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于您已经学到的东西，并使用相同的基本原理创建一个稍微更高级的模拟。我们将要构建的模拟环境如[图 4-1](#fig:secondSim)所示。
- en: '![psml 0401](assets/psml_0401.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0401](assets/psml_0401.png)'
- en: Figure 4-1\. The simulation we’ll be building
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 我们将构建的模拟
- en: This simulation will consist of a cube, which will again serve as our *agent*.
    The agent’s *goal* will be to *push a block into a goal* area as quickly as possible.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟将由一个立方体组成，它将再次充当我们的*代理*。代理的*目标*是尽快将一个块*推入一个目标*区域。
- en: By the end of this chapter, you’ll have continued to solidify your Unity skills
    for assembling simulation environments, and have a better handle on the components
    and features of the ML-Agents Toolkit.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将继续巩固 Unity 技能，用于组装模拟环境，并更好地掌握 ML-Agents Toolkit 的组件和特性。
- en: Setting Up the Block Pusher
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置推块代理
- en: For a full rundown and discussion of the tools you’ll need for simulation and
    machine learning, refer back to [Chapter 1](ch01.html#introducing-the-tools).
    This section will give you a quick summary of the bits and pieces you’ll need
    to accomplish *this particular activity*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取关于模拟和机器学习工具的全面介绍和讨论，请参考[第 1 章](ch01.html#introducing-the-tools)。本节将为您提供完成*这个特定活动*所需的各种工具的快速总结。
- en: 'Specifically, here we will do the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，这里我们将执行以下操作：
- en: Create a new Unity project and set it up for use with ML-Agents.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Unity 项目并为其配置 ML-Agents 的使用。
- en: Create the environment for our block pusher in a scene in that Unity project.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 项目的场景中创建我们的推块环境。
- en: Implement the necessary code to make our block pushing agent function in the
    environment and be trainable using reinforcement learning.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现必要的代码，使我们的推块代理在环境中运行并可以使用强化学习进行训练。
- en: And finally, train our agent in the environment and see how it runs.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在环境中训练我们的代理并查看其运行情况。
- en: Creating the Unity Project
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Unity 项目
- en: 'Once again, we’ll be creating a brand-new Unity project for this simulation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将为此模拟创建一个全新的 Unity 项目：
- en: Open the Unity Hub and create a new 3D project. We’ll name ours “BlockPusher.”
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Unity Hub 并创建一个新的 3D 项目。我们将其命名为“BlockPusher”。
- en: Install the ML-Agents Toolkit package. Refer back to [Chapter 2](ch02.html#chapter-creating-first-simulation)
    for instructions.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 ML-Agents Toolkit 包。请参考[第 2 章](ch02.html#chapter-creating-first-simulation)获取说明。
- en: That’s all! You’re ready to go ahead and make the environment for the block
    pusher agent to live in.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！您已经准备好为推块代理创建生存环境。
- en: The Environment
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境
- en: 'With our empty Unity project ready to go with ML-Agents, the next step is to
    create the simulation environment. In addition to the *agent* itself, our simulation
    environment for this chapter has the following requirements:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们准备好的空白 Unity 项目和 ML-Agents，下一步是创建模拟环境。除了*代理*本身之外，本章的模拟环境还具备以下要求：
- en: A *floor* for the agent to move around on
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*地板*，供代理移动
- en: A *block* for the agent to push around
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*块*，供代理推动
- en: A set of outer *walls* to prevent the agent from falling into the void
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组外部*墙壁*，防止代理掉入虚空
- en: A *goal* area for the agent to push the block into
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*目标*区域，供代理将块推入其中
- en: In the following few sections, we’ll create each of these pieces in the Unity
    Editor.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个部分中，我们将在 Unity 编辑器中创建每个部分。
- en: The Floor
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地板
- en: 'The floor is where our agent and the block it pushes will live. The floor is
    very similar to the one created in [Chapter 2](ch02.html#chapter-creating-first-simulation),
    but here we’ll also be building walls around it. With the new Unity project open
    in the editor, we’ll create a new scene and create the floor for our agent (and
    the block it pushes) to live on:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 地板是我们的代理和它推动的方块的生活场所。地板与[第二章](ch02.html#chapter-creating-first-simulation)中创建的相似，但这里我们还将围绕它建立墙壁。在编辑器中打开新的Unity项目后，我们将创建一个新场景，并为我们的代理（以及它推动的方块）创建地板：
- en: Open the GameObject menu → 3D Object → Cube. Click on the cube that you’ve created
    in the Hierarchy view, and as before set its name to “Floor” or something similar.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 GameObject 菜单 → 3D Object → 立方体。单击在层次视图中创建的立方体，并像之前一样将其名称设置为“地板”或类似的名称。
- en: With the new floor selected, set its position to something suitable, and its
    scale to `(20, 0.35, 20)` or something similar, so that it’s a big flat floor
    with a bit of thickness to it, as shown in [Figure 4-2](#fig3:newFloor).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新创建的地板后，将其位置设置为合适的值，比如 `(20, 0.35, 20)` 或类似的值，这样它就是一个平坦而略带厚度的大地板，如 [图 4-2](#fig3:newFloor)
    所示。
- en: '![psml 0402](assets/psml_0402.png)'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0402](assets/psml_0402.png)'
- en: Figure 4-2\. The floor for our simulation
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 我们模拟用的地板
- en: Tip
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The floor is the center of existence for this world. By centering the world
    on the floor, the floor’s position doesn’t really matter.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 地板是这个世界存在的中心。通过将世界的中心定位在地板上，地板的位置实际上并不重要。
- en: 'We want our floor to have a little more character this time, so we’re going
    to give it some color:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们希望地板有更多特色，所以我们打算给它上色：
- en: Open the Assets menu → Create → Material to create a new material asset in the
    project (you can see it in the Project view). Rename the material to “Material_Floor”
    or something similar by right-clicking and selecting Rename (or pressing Return
    while the material is selected).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Assets 菜单 → 创建 → 材质以在项目中创建一个新的材质资源（可以在项目视图中看到）。通过右键单击并选择重命名（或选中材质后按返回键），将材质重命名为“Material_Floor”或类似的名称。
- en: Ensure that the new material is selected in the Project view and use the Inspector
    to set the albedo color to something fancy. We recommend a nice orange color,
    but anything is fine. Your Inspector should look something like [Figure 4-3](#fig:floormaterial).
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在项目视图中选择了新的材料，并使用检查器将反射颜色设置为一些花哨的颜色。我们推荐一个漂亮的橙色，但任何颜色都可以。你的检查器应该看起来像 [图 4-3](#fig:floormaterial)
    一样。
- en: '![psml 0403](assets/psml_0403.png)'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0403](assets/psml_0403.png)'
- en: Figure 4-3\. The floor material
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-3\. 地板材质
- en: Select the floor in the Hierarchy view and drag the new material from the Project
    view directly onto either the floor’s entry in the Project view, or the empty
    space at the bottom of the floor’s Inspector. The floor should change color in
    the Scene view, and the Inspector for the floor should have a new component, as
    shown in [Figure 4-4](#fig:inspectorch).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次视图中选择地板，并从项目视图直接将新材料拖放到地板在项目视图中的条目或地板检查器底部的空白处。场景视图中地板的颜色应该会改变，并且地板的检查器应该有一个新的组件，如
    [图 4-4](#fig:inspectorch) 所示。
- en: '![psml 0404](assets/psml_0404.png)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0404](assets/psml_0404.png)'
- en: Figure 4-4\. The Inspector for the floor, showing the new Material component
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-4\. 地板的检查器，显示新的材料组件
- en: That’s it for the floor! Make sure you save the scene before continuing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 地板就这样了！确保在继续之前保存场景。
- en: The Walls
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 墙壁
- en: Next, we need to create some walls around the floor. Unlike in [Chapter 2](ch02.html#chapter-creating-first-simulation),
    we don’t want the agent to ever have the possibility of falling off the floor.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在地板周围创建一些墙壁。与[第二章](ch02.html#chapter-creating-first-simulation)不同，我们不希望代理有可能从地板上掉下来。
- en: 'To create walls, we’ll once again be using our old, versatile friend, the cube.
    Back in the Unity scene where you made the floor a moment ago, do the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建墙壁，我们将再次使用我们旧朋友——立方体。回到刚才创建地板的Unity场景中，进行以下操作：
- en: Create a new cube in the scene. Make it the same scale on the x-axis as the
    floor (so probably about `20`), `1` unit high on the y-axis, and around `0.25`
    on the z-axis. It should look something like [Figure 4-5](#fig:firstwall).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个新的立方体。使其在x轴上与地板相同的比例（大约是 `20`），在y轴上高 `1` 单位，在z轴上约 `0.25` 单位。它应该看起来像
    [图 4-5](#fig:firstwall) 一样。
- en: '![psml 0405](assets/psml_0405.png)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0405](assets/psml_0405.png)'
- en: Figure 4-5\. The first wall
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-5\. 第一面墙
- en: Create a new material for the walls, give it a nice color, and apply it to the
    wall you’ve created. Ours is shown in [Figure 4-6](#fig:wallmaterial).
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为墙壁创建新材质，给它一个漂亮的颜色，并将其应用到您创建的墙壁上。我们的示例显示在[图 4-6](#fig:wallmaterial)中。
- en: '![psml 0406](assets/psml_0406.png)'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0406](assets/psml_0406.png)'
- en: Figure 4-6\. The new wall material
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-6\. 新的墙壁材质
- en: Rename the cube “Wall” or something similar, and duplicate it once. These will
    be our walls on one axis. Don’t worry about moving them to the right position
    just yet.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将立方体重命名为“墙壁”或类似的名称，并再次复制它。这些将是我们在一个轴上的墙壁。目前不要担心将它们放置在正确的位置。
- en: Duplicate one of the walls again and, using the Inspector, rotate it `90` degrees
    on the y-axis. Once it’s there, duplicate it.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次复制其中一堵墙，并使用检查器在y轴上旋转`90`度。旋转完成后，再次复制它。
- en: Tip
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can switch to the move tool by pressing the W key on your keyboard.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以按键盘上的W键切换到移动工具。
- en: Position the walls by using the move tool while each wall is selected (in either
    the Scene view or the Hierarchy view) and holding the V key on your keyboard to
    enter vertex snapping mode. While the V key is held, mouse over the different
    vertices in the wall’s mesh. Mouse over one of the outer bottom-corner vertices
    of a wall, and then click and drag on the move handle to snap it to the appropriate
    upper-corner vertex on the floor. This process is shown in [Figure 4-7](#vertexsnapping).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用移动工具调整墙壁的位置，选择每个墙壁时（无论是在场景视图还是层次视图中），按住键盘上的V键进入顶点捕捉模式。在按住V键的同时，将鼠标悬停在墙壁网格的不同顶点上。将鼠标悬停在一个墙壁外底角的顶点上，然后单击并拖动移动手柄，以将其捕捉到地板上适当的上角顶点。该过程显示在[图 4-7](#vertexsnapping)中。
- en: '![psml 0407](assets/psml_0407.png)'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0407](assets/psml_0407.png)'
- en: Figure 4-7\. Vertex-snapping on the corner
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-7\. 在角落上进行顶点捕捉
- en: Tip
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can switch between different views in the Scene view using the widget in
    the upper-right corner, shown in [Figure 4-8](#scenewidget).
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用场景视图右上角的小部件切换到不同视图，如[图 4-8](#scenewidget)所示。
- en: '![psml 0408](assets/psml_0408.png)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0408](assets/psml_0408.png)'
- en: Figure 4-8\. The scene widget
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-8\. 场景小部件
- en: Repeat this for each wall segment. Some of the wall segments will overlap and
    intersect each other, and that’s fine.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个墙段重复这个步骤。一些墙段会重叠和相交，这没关系。
- en: When you’re done, your walls should look like [Figure 4-9](#fourwalls). As always,
    save your scene before you continue.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成后，您的墙壁应该看起来像[图 4-9](#fourwalls)。在继续之前，务必保存您的场景。
- en: '![psml 0409](assets/psml_0409.png)'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0409](assets/psml_0409.png)'
- en: Figure 4-9\. The four final walls
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-9\. 四个最终墙壁
- en: The Block
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方块
- en: 'The block, at this phase, is the simplest element that we need to create in
    the editor. Like many of us, it exists to be pushed around (in this case, by the
    agent). We’ll add the block in the Unity scene:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，方块是我们需要在编辑器中创建的最简单元素。像我们大多数人一样，它存在于被推动的状态（在这种情况下，由代理推动）。我们将在Unity场景中添加这个方块：
- en: Add a new cube to the scene, and rename it “Block.”
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向场景中添加一个新的立方体，并将其重命名为“方块”。
- en: Use the Inspector to add a Rigidbody component to the agent, setting its mass
    to `10` and its drag to `4`, and freezing its rotation on all three axes, as shown
    in [Figure 4-10](#inspector_block).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用检查器给代理添加刚体组件，将其质量设置为`10`，阻力设置为`4`，并且在所有三个轴上冻结其旋转，如[图 4-10](#inspector_block)所示。
- en: '![psml 0410](assets/psml_0410.png)'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0410](assets/psml_0410.png)'
- en: Figure 4-10\. The block’s parameters
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-10\. 方块的参数
- en: Position the block somewhere on the floor. Anywhere is fine.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将方块放置在地板上的任意位置。任何位置都可以。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you’re having trouble positioning the block precisely on the floor, you can
    use the move tool in vertex snapping mode, like you did for the walls, and snap
    the agent to one of the corners of the floor (where it will be intersecting with
    the walls). Then use the directional move tool (by clicking and dragging on the
    arrows coming out of the agent while it’s in move mode) or the Inspector to move
    it to the desired location.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您在精确定位方块的位置时遇到困难，可以像处理墙壁一样使用顶点捕捉模式的移动工具，并将代理捕捉到地板的一个角落（它将与墙壁相交）。然后使用方向移动工具（在移动模式下点击并拖动代理箭头上的箭头）或检查器将其移动到所需位置。
- en: The Goal
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: The goal is the location in the scene where the agent needs to push the block.
    It’s less of a physical thing and more of a concept. But concepts can’t be represented
    in video game engines, so how do we implement it? That’s a great question, dear
    reader! We make a plane—a flat area—that we set to a specific color so that the
    watching human (i.e., us) can tell where the goal area is. The color won’t be
    used by the agent at all, it’s just for us.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是场景中代理需要推动方块的位置。它不仅仅是一个物理事物，更是一个概念。但是概念在视频游戏引擎中无法表示，那么我们如何实现它呢？这是一个很棒的问题，亲爱的读者！我们创建一个平面——一个平坦的区域——并将其设置为特定的颜色，以便观察者（也就是我们）可以知道目标区域在哪里。这种颜色不会被代理使用，只是为了我们自己。
- en: The agent will use the collider we add, which is a big volume of space that
    exists above the colored ground area, and using C# code, we can know when something
    is inside that volume (hence the name “collider”).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 代理将使用我们添加的碰撞器，这是一个大的空间体，位于有色地面区域的上方，使用 C# 代码，我们可以知道某物体是否在这个空间体内（因此称为“碰撞器”）。
- en: 'Follow these steps to create the goal and its collider:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建目标及其碰撞器：
- en: Create a new plane in the scene and rename it “Goal” or something similar.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个新平面并将其重命名为“目标”或类似的名称。
- en: Create a new material for the goal and apply it. We recommend you use a color
    that will stand out, since this is the goal area that we want the agent to push
    the cube into. Apply the new material to the goal.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为目标创建新材料并应用它。我们建议您使用一种显眼的颜色，因为这是我们希望代理将方块推入的目标区域。将新材料应用于目标。
- en: Use the same trick with vertex snapping that you used earlier in [“The Walls”](#ch3-walls)
    to position the goal using the Rect tool (accessible using T on your keyboard)
    or via the tools selector, shown in [Figure 4-11](#toolselector). Position the
    goal roughly as shown in [Figure 4-12](#goal).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用顶点捕捉与您之前在[“墙壁”](#ch3-walls)中使用的相同技巧将目标使用 Rect 工具（可以通过键盘上的 T 键访问）或通过工具选择器定位，如[图
    4-11](#toolselector)所示。大致按[图 4-12](#goal)的显示位置放置目标。
- en: '![psml 0411](assets/psml_0411.png)'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0411](assets/psml_0411.png)'
- en: Figure 4-11\. The tool selector
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-11\. 工具选择器
- en: '![psml 0412](assets/psml_0412.png)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0412](assets/psml_0412.png)'
- en: Figure 4-12\. The goal in position
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-12\. 目标位置
- en: Using the inspector, remove the Mesh Collider component from the goal, and use
    the Add Component button to add a Box Collider component instead.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用检查器，从目标中删除 Mesh Collider 组件，并使用“添加组件”按钮添加 Box Collider 组件。
- en: With the goal selected in the Hierarchy, click the Edit Collider button in the
    Box Collider component of the goal’s Inspector (shown in [Figure 4-13](#colliderbutton).)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 Hierarchy 中的目标，在目标的 Inspector 中的 Box Collider 组件中点击“编辑碰撞器”按钮（如[图 4-13](#colliderbutton)所示）。
- en: '![psml 0413](assets/psml_0413.png)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0413](assets/psml_0413.png)'
- en: Figure 4-13\. Edit Collider button
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-13\. 编辑碰撞器按钮
- en: Use the small green square handles to size the collider of the goal so that
    it encompasses more of the environment’s volume, so if the agent enters the collider
    it will be detected. Ours is shown in [Figure 4-14](#colliderbig), but this is
    not a science; you just need to make it big! You might find it easier just to
    increase the Box Collider component’s size on its y-axis using the Inspector.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用小绿色方形手柄调整目标的碰撞器大小，以便它覆盖更多环境的体积，这样如果代理进入碰撞器，则会被检测到。我们的示例显示在[图 4-14](#colliderbig)，但这不是一门科学；你只需把它做大！你可能会发现，只需使用检查器中的
    Box Collider 组件增加其 Y 轴上的大小会更容易。
- en: '![psml 0414](assets/psml_0414.png)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0414](assets/psml_0414.png)'
- en: Figure 4-14\. Our large collider, showing the handles
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-14\. 我们的大碰撞器，显示手柄
- en: As before, don’t forget to save the scene.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，请不要忘记保存场景。
- en: The Agent
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理
- en: Finally (almost), we need to create the agent itself. Our agent is going to
    be a cube, with the appropriate script (which we’ll also create) attached to it,
    just like we did with the ball agent in [Chapter 2](ch02.html#chapter-creating-first-simulation).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后（差不多了），我们需要创建代理本身。我们的代理将是一个立方体，并附加适当的脚本（我们也会创建），就像我们在[第 2 章](ch02.html#chapter-creating-first-simulation)中使用球代理一样。
- en: 'Still in the Unity Editor, do the following in your scene:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在 Unity 编辑器中，在你的场景中执行以下操作：
- en: Create a new cube and name it “Agent” or something similar.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的立方体并命名为“代理”或类似的名称。
- en: In the agent’s Inspector, select the Add Component button and add a new script.
    Name it something like “BlockSorterAgent.”
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代理的检查器中，选择“添加组件”按钮并添加一个新的脚本。命名为类似“BlockSorterAgent”之类的名称。
- en: 'Open the newly created script and add the following import statements:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的脚本，并添加以下导入语句：
- en: '[PRE0]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Update the class to be a child of `Agent`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类更新为 `Agent` 的子类。
- en: 'Now you need some properties, starting with a handle for the floor and environment
    (we’ll get back to assigning these shortly). These go inside the class, before
    any methods:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你需要一些属性，首先是地板和环境的处理（我们稍后会回到分配这些）。这些放在任何方法之前的类内部：
- en: '[PRE1]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You also need something to represent the bounds of the floor:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要一些东西来表示地板的边界：
- en: '[PRE2]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And you need something to represent the goal area and the block that needs
    to be pushed to the goal:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要一些东西来代表目标区域和需要推到目标的块：
- en: '[PRE3]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now add some `Rigidbody`s to store the body of the block and the agent:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一些`Rigidbody`来存储块和代理的主体：
- en: '[PRE4]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When the agent is initialized, we need to do a few things, so the first thing
    we’ll make is the `Initialize()` function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当代理初始化时，我们需要做一些事情，所以我们首先要做的就是`Initialize()`函数：
- en: 'Add the `Initialize()` function:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Initialize()`函数：
- en: '[PRE5]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside, get a handle on the agent and block’s `Rigidbody`s:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内部，获取代理和块的`Rigidbody`：
- en: '[PRE6]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And finally, for the `Initialize()` function, get a handle on the bounds of
    the floor:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于`Initialize()`函数，获取地板边界的处理：
- en: '[PRE7]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we want to be able to randomly position the agent within the floor when
    it spawns (and for each training run), so we’ll make a `GetRandomStartPosition()`
    method. This method is entirely ours, and isn’t implementing a required piece
    of ML-Agents (like the methods we override):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要能够在代理生成时（以及每次训练运行时）在地板上随机放置代理，因此我们会创建一个`GetRandomStartPosition()`方法。这个方法完全是我们自己的，不是实现ML-Agents（像我们重写的方法）的必需部分：
- en: 'Add the `GetRandomStartPosition()` method:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`GetRandomStartPosition()`方法：
- en: '[PRE8]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ll call this method whenever we want to position something randomly within
    the floor that’s in our simulation. It will return a random usable position on
    the floor.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当我们想在模拟中的地板上随机放置东西时，我们将调用这个方法。它会返回地板上一个随机可用的位置。
- en: 'Inside `GetRandomStartPosition()`, get a handle on the bounds of the floor
    and the goal:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GetRandomStartPosition()`内部，获取地板和目标的边界：
- en: '[PRE9]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now create someplace to store the new point on the floor (we’ll return to this
    in a bit):'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个地板上新点的存储位置（稍后我们会回到这一点）：
- en: '[PRE10]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, make a timer so that you can see if this process takes too long for some
    reason:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，制作一个计时器，这样你就可以看到如果出于某种原因这个过程花费了太长时间：
- en: '[PRE11]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, add a variable to store a margin. We’ll use this to add and remove a
    small buffer from the random position that is picked:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个变量来存储边缘。我们将使用这个变量来从随机位置中添加和移除一个小缓冲区：
- en: '[PRE12]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now start a `do`-`while` that continues picking a random point if it picks
    one that is *inside the goal’s bounds*:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在开始一个`do`-`while`循环，继续选择一个随机点，如果选择的点在*目标边界内*，则继续：
- en: '[PRE13]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Inside the `do`, check if the timer has gone on too long, and throw an exception
    if it did:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`do`内部，检查计时器是否花费了太长时间，如果是，则抛出异常：
- en: '[PRE14]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, still inside the `do`, but below the `if` statement, pick a point on
    the top face of the floor:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`do`内部的`if`语句下面，选择地板顶面上的一个点：
- en: '[PRE15]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Add and remove the `margin` so that the box is always on the floor, and not
    in the walls or in space.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加和移除`margin`，这样箱子总是在地板上，而不是在墙壁或空间中：
- en: 'After the `do`-`while`, `return` the `pointOnFloor` that you created:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`do`-`while`之后，`return`你创建的`pointOnFloor`：
- en: '[PRE16]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That’s it for `GetRandomStartPosition()`. Next, we need a function to call
    when the agent gets the block to the goal. We’ll use this function to reward the
    agent for doing the right thing, reinforcing the policy that we want:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`GetRandomStartPosition()`就是这样。接下来，我们需要一个函数，当代理将块移到目标位置时调用。我们将使用这个函数奖励代理做正确的事情，加强我们想要的策略：
- en: 'Create the `GoalScored()` function:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`GoalScored()`函数：
- en: '[PRE17]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add a call to `AddReward()`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个调用`AddReward()`：
- en: '[PRE18]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And add a call to `EndEpisode()`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并添加一个调用`EndEpisode()`：
- en: '[PRE19]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we’ll implement `OnEpisodeBegin()`,the function that’s called when each
    training or inference *episode* begins:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`OnEpisodeBegin()`，这是在每个训练或推断*episode*开始时调用的函数：
- en: 'First, we’ll put the function in place:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们会放置函数在适当的位置：
- en: '[PRE20]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And we’ll get a random rotation and angle:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将获取一个随机的旋转和角度：
- en: '[PRE21]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we’ll get a random start position for the block, using the function we
    created:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将为块获取一个随机的起始位置，使用我们创建的函数：
- en: '[PRE22]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We’ll set the block’s velocity and angular velocity, using its `Rigidbody`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将设置块的速度和角速度，使用它的`Rigidbody`：
- en: '[PRE23]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We’ll get a random start position for the agent:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为代理获取一个随机的起始位置：
- en: '[PRE24]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And we’ll set the agent’s velocity and angular velocity, using its `Rigidbody`
    as well:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且我们将设置代理的速度和角速度，同样使用它的`Rigidbody`：
- en: '[PRE25]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we’ll rotate the whole environment. We do this so that the agent doesn’t
    learn the side that always has the goal:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将旋转整个环境。我们这样做是为了让代理不会只学习总是有目标的那一边：
- en: '[PRE26]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And that’s it for the `OnEpisodeBegin()` function. Save your code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `OnEpisodeBegin()` 函数的全部内容。保存你的代码。
- en: 'Next, we’re going to implement the `Heuristic()` function so that we can manually
    control the agent if we want to:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现 `Heuristic()` 函数，这样我们就可以手动控制代理：
- en: 'Create the function `Heuristic()`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `Heuristic()` 函数：
- en: '[PRE27]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Manual control of the agent here is entirely unrelated to the training process.
    It just exists so that we can verify the agent can move in the environment appropriately.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里对代理的手动控制与训练过程完全无关。它只是存在以便我们可以验证代理在环境中的移动是否恰当。
- en: 'Get a handle on the actions that the Unity ML-Agents Toolkit sends, and set
    the action to `0` so that you know you’ll always end up with a valid action or
    `0` by the end of the call to `Heuristic()`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 Unity ML-Agents Toolkit 发送的动作，并设置动作为 `0`，以便最终在调用 `Heuristic()` 结束时你知道你总是会得到一个有效的动作或
    `0`：
- en: '[PRE28]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, for each key—D, W, A, and S—check if it’s being used, and send the appropriate
    action:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然   然后，对于每个键（D、W、A 和 S），检查它是否被使用，并发送适当的动作：
- en: '[PRE29]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: These numbers are totally arbitrary. As long as they stay consistent and don’t
    overlap, it doesn’t matter what they are. One number consistently represents one
    direction (which corresponds to a keypress when under human control).
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些数字完全是任意的。只要它们保持一致并且不重叠，它们是无所谓的。一个数字始终代表一个方向（在人类控制下对应一个按键）。
- en: And that’s all for the `Heuristic()` function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `Heuristic()` 函数的全部内容。
- en: 'Next, we need to implement the `MoveAgent()` function, which will allow the
    ML-Agents framework to control the agent for both training and inference purposes:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现 `MoveAgent()` 函数，这将允许 ML-Agents 框架控制代理进行训练和推理：
- en: 'First, we’ll implement the function:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将实现这个函数：
- en: '[PRE30]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, inside, we’ll zero out the direction and rotation that will be used for
    the movement:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在内部，我们将清零用于移动的方向和旋转：
- en: '[PRE31]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And we’ll assign the action coming in from the Unity ML-Agents Toolkit to something
    a little more readable:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将从 Unity ML-Agents Toolkit 接收到的动作分配到更可读的东西上：
- en: '[PRE32]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we’ll switch on that action and set the direction or rotation appropriately:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将根据该动作进行切换，并相应地设置方向或旋转：
- en: '[PRE33]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, outside the `switch`, we’ll act on any rotation:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `switch` 外部，我们将根据任何旋转来行动：
- en: '[PRE34]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And we’ll also act on any direction, by applying a force to the agent’s `Rigidbody`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将根据任何方向对代理的 `Rigidbody` 应用力：
- en: '[PRE35]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And that’s all for `MoveAgent()`. Again, save your code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveAgent()` 就这些了。再次保存你的代码。'
- en: 'Finally, for now, we need to implement the `OnActionReceived()` function, which
    doesn’t do much more than pass the received action on to our `MoveAgent()` function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在，我们需要实现 `OnActionReceived()` 函数，它不做更多的事情，只是将接收到的动作传递给我们的 `MoveAgent()`
    函数：
- en: 'Create the function:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建函数：
- en: '[PRE36]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Call your own `MoveAgent()` function, passing in the discrete actions:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用你自己的 `MoveAgent()` 函数，传递离散动作：
- en: '[PRE37]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And punish the agent by setting a negative reward based on the step:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且根据步数设置负奖励来惩罚代理：
- en: '[PRE38]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This negative reward will hopefully encourage the agent to economize its movement
    and take as few moves as possible in order to maximize its reward and achieve
    the goal we want from it.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个负奖励希望能鼓励代理节约其移动并尽可能少地进行移动，以便最大化其奖励并实现我们从中期望的目标。
- en: That’s everything for now. Make sure your code is saved before you continue.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切就绪了。确保在继续之前保存你的代码。
- en: The Environment
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境
- en: 'We need to do a little more administrative work in setting up the environment
    before we continue, so switch back to your scene in the Unity Editor. We’ll start
    by creating a GameObject to hold the walls in, just to keep the Hierarchy clean:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要在设置环境方面做一些行政工作，所以切换回 Unity 编辑器中的场景。我们将首先创建一个 GameObject 来容纳墙壁，只是为了保持
    Hierarchy 的整洁：
- en: Right-click on the Hierarchy view and choose Create Empty. Rename the empty
    GameObject “Walls,” as shown in [Figure 4-15](#fig:walls).
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 视图上右键点击，选择 Create Empty。将空 GameObject 重命名为 “Walls”，如 [Figure 4-15](#fig:walls)
    所示。
- en: '![psml 0415](assets/psml_0415.png)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0415](assets/psml_0415.png)'
- en: Figure 4-15\. The walls object, named
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-15\. 命名为 Walls 的墙体对象
- en: Select all four walls (you can hold your Shift key and click them one by one,
    or hold Shift after clicking the first one and then click the last one) and drag
    them under the new walls object. It should look like [Figure 4-16](#finwalls).
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有四个墙壁（你可以依次点击它们，或者在点击第一个后按住 Shift 再点击最后一个），然后将它们拖放到新的墙壁对象下。此时应该看起来像 [图 4-16](#finwalls)
    这样。
- en: '![psml 0416](assets/psml_0416.png)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0416](assets/psml_0416.png)'
- en: Figure 4-16\. The walls are nicely encapsulated
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-16\. 墙壁被很好地封装
- en: 'Now we’ll create an empty GameObject in which to hold the entire environment:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个空的 GameObject 来容纳整个环境：
- en: Right-click in the Hierarchy view and choose Create Empty. Rename the empty
    GameObject “Environment.”
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次视图中右键单击，并选择创建空对象。将空的 GameObject 重命名为“环境”。
- en: In the Hierarchy view, drag the walls object we just made, plus the agent, floor,
    block, and goal, into the new environment object. It should look like [Figure 4-17](#fig:finenv)
    at this point.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次视图中，将我们刚刚创建的墙壁对象，以及代理、地板、块和目标，拖放到新的环境对象中。此时应该看起来像 [图 4-17](#fig:finenv) 这样。
- en: '![psml 0417](assets/psml_0417.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0417](assets/psml_0417.png)'
- en: Figure 4-17\. The environment, encapsulated
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-17\. 环境被封装
- en: 'Next, we need to configure some things on our agent:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的代理上配置一些东西：
- en: Select the agent in the Hierarchy view, and scroll down to the script you added
    in the Inspector view. Drag the floor object from the Hierarchy view into the
    Floor slot in the Inspector.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次视图中选择代理，并在检视器视图中向下滚动到你添加的脚本。从层次视图中将地板对象拖放到检视器中的 Floor 槽中。
- en: Do the same for the overall environment GameObject, the goal, and the block.
    Set the Max Steps to `5000` in the editor so that the agent doesn’t take forever
    to push a block to the goal. Your Inspector should look like [Figure 4-18](#fig:inspectorforagent).
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对整体环境 GameObject、目标和块执行相同操作。在编辑器中将 Max Steps 设置为`5000`，以便代理不会花费太长时间将块推向目标。你的检视器应该看起来像
    [图 4-18](#fig:inspectorforagent) 这样。
- en: '![psml 0418](assets/psml_0418.png)'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0418](assets/psml_0418.png)'
- en: Figure 4-18\. The agent script properties
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-18\. 代理脚本属性
- en: Now, using the Add Component button in the Inspector for the agent, add a DecisionRequester
    script and set its Decision Period to 5, as shown in [Figure 4-19](#fig:decreqagent).
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在代理的检视器中使用“添加组件”按钮，添加一个 DecisionRequester 脚本，并将其决策周期设置为 5，如 [图 4-19](#fig:decreqagent)
    所示。
- en: '![psml 0419](assets/psml_0419.png)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0419](assets/psml_0419.png)'
- en: Figure 4-19\. The Decision Requester component, added to the agent and appropriately
    configured
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-19\. 决策请求者组件已添加到代理并适当配置
- en: 'Add two Ray Perception Sensor 3D components, each with three detectable tags:
    block, goal, and wall, with the settings shown in [Figure 4-20](#fig:dualrays).'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个 Ray Perception Sensor 3D 组件，每个组件都具有三个可检测标签：block、goal 和 wall，并使用 [图 4-20](#fig:dualrays)
    中显示的设置。
- en: Back in [“Letting the Agent Observe the Environment”](ch02.html#ch02-observations),
    we said you can add observations via code or via components. There we did it all
    via code. Here we’re going to do it all via components. The components in question
    are the Ray Perception Sensor 3D components that we just added.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回到 [“让代理观察环境”](ch02.html#ch02-observations) ，我们说过你可以通过代码或组件添加观察。那时我们全都通过代码实现。而这次我们将全部通过组件实现。所涉及的组件是我们刚刚添加的
    Ray Perception Sensor 3D 组件。
- en: '![psml 0420](assets/psml_0420.png)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0420](assets/psml_0420.png)'
- en: Figure 4-20\. The two Ray Perception sensors
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-20\. 两个 Ray Perception 传感器
- en: Tip
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: We don’t even have a `CollectObservations` method in our agent this time, because
    all the observations are collected via the Ray Perception Sensor 3D components
    that we add in the editor.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次我们的代理甚至没有 `CollectObservations` 方法，因为所有的观察都是通过我们在编辑器中添加的 Ray Perception Sensor
    3D 组件收集的。
- en: We’ll need to add the tags we just used to the objects we actually want to tag.
    The tags allow us to refer to objects based on what they’re tagged with, so if
    something is tagged with “wall,” we can treat it as a wall, and so on. Select
    the block in the Hierarchy, and use the Inspector to add a new tag, as shown in
    [Figure 4-21](#fig:taggingtheobjects).
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将刚刚使用的标签添加到我们实际想要标记的对象中。标签允许我们根据它们的标记引用对象，因此，如果某物被标记为“wall”，我们可以将其视为墙壁等等。在层次结构中选择块，并使用检视器添加一个新标签，如
    [图 4-21](#fig:taggingtheobjects) 所示。
- en: '![psml 0421](assets/psml_0421.png)'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0421](assets/psml_0421.png)'
- en: Figure 4-21\. Adding a new tag
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-21\. 添加一个新标签
- en: Name the new tag “block,” as shown in [Figure 4-22](#fig:taggingtheobjects2).
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新标签命名为“block”，如 [图 4-22](#fig:taggingtheobjects2) 所示。
- en: '![psml 0422](assets/psml_0422.png)'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0422](assets/psml_0422.png)'
- en: Figure 4-22\. Naming a new tag
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-22\. 命名一个新标签
- en: And finally, attach the new tag to the block, as shown in [Figure 4-23](#fig:taggingtheobjects3).
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如图 [4-23](#fig:taggingtheobjects3) 所示，将新标签附加到块上。
- en: '![psml 0423](assets/psml_0423.png)'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0423](assets/psml_0423.png)'
- en: Figure 4-23\. Attaching the tag to an object
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-23\. 将标签附加到对象
- en: Repeat this for the goal, using a “goal” tag, and for all the wall components,
    using a “wall” tag. With these in place, the Ray Perception Sensor 3D components
    we added will only “see” things tagged with “block,” “goal,” or “wall.” As shown
    in [Figure 4-24](#fig:raysensors), we’ve added two layers of Ray Perception sensors,
    which case a line out from the object they’re attached to and report back on the
    first thing that line hits (in this case, only if it’s a wall, a goal, or a block).
    We’ve added two that are staggered at different angles. They’ll only be visible
    in the Unity Editor.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于目标，使用“goal”标签重复此操作，并对所有墙组件使用“wall”标签。有了这些，我们添加的射线感知传感器 3D 组件将仅“看到”使用“block”、“goal”或“wall”标记的物体。如图
    [4-24](#fig:raysensors) 所示，我们添加了两层射线感知器，它们从附加到它们的对象中发出一条线，并回报该线首次碰到的东西（在本例中，仅在它是墙、目标或块时）。我们添加了两个，它们被安置在不同的角度。它们只在
    Unity 编辑器中可见。
- en: '![psml 0424](assets/psml_0424.png)'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0424](assets/psml_0424.png)'
- en: Figure 4-24\. The Ray Perception Sensor 3D components
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-24\. 射线感知传感器 3D 组件
- en: Finally, add a Behavior Parameters component, using the Add Component button.
    Name the behavior “Push” and set the parameters as shown in [Figure 4-25](#fig:behaviourparameters11).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用“添加组件”按钮添加一个行为参数组件。将行为命名为“Push”，并按图 [4-25](#fig:behaviourparameters11)
    设置参数。
- en: '![psml 0425](assets/psml_0425.png)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0425](assets/psml_0425.png)'
- en: Figure 4-25\. The Behavior Parameters for the agent
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-25\. 代理的行为参数
- en: 'Save your scene in the Unity Editor. Now we’ll do some configuration on our
    block:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器中保存你的场景。现在我们将在我们的块上进行一些配置：
- en: Add a new script to the block, named something like “GoalScore.”
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的脚本到块中，命名为“GoalScore”。
- en: 'Open the script, and add a property to refer to the agent:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本，并添加一个属性以引用代理：
- en: '[PRE39]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The type of the property you create here should match the class name for the
    class attached to the agent.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里创建的属性类型应该与附加到代理的类的类名匹配。
- en: Tip
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You don’t need to change the parentage to `Agent` or import any ML-Agents components
    this time, as this script isn’t an agent. It’s just a regular script.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次不需要将父项更改为`Agent`或导入任何 ML-Agents 组件，因为这个脚本不是一个代理。它只是一个普通的脚本。
- en: 'Add an `OnCollisionEnter()` function:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `OnCollisionEnter()` 函数：
- en: '[PRE40]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Inside `OnCollisionEnter()`, add the following code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnCollisionEnter()` 内部，添加以下代码：
- en: '[PRE41]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Save the script and return to Unity, and with the block selected in the Hierarchy,
    drag the agent from the Hierarchy into the Agent slot in the new GoalScore script.
    This is shown in [Figure 4-26](#fig:goalscore).
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回到 Unity，在 Hierarchy 中选中块，将其从 Hierarchy 拖动到新的 GoalScore 脚本中的 Agent 槽位中。如图
    [4-26](#fig:goalscore) 所示。
- en: '![psml 0426](assets/psml_0426.png)'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0426](assets/psml_0426.png)'
- en: Figure 4-26\. The GoalScore script
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-26\. GoalScore 脚本
- en: Don’t forget to save the scene again.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记再次保存场景。
- en: Training and Testing
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练和测试
- en: 'With everything built in both Unity and C# scripts, it’s time to train the
    agent and see how the simulation works. We’ll be following the same process we
    followed in [“Training with the Simulation”](ch02.html#training-the-env): creating
    a new YAML file to serve as the hyperparameters for our training.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Unity 和 C# 脚本中构建了所有内容后，现在是训练代理并查看模拟工作的时候了。我们将按照 [“使用模拟进行训练”](ch02.html#training-the-env)
    中的相同过程进行操作：创建一个新的 YAML 文件，用作训练的超参数。
- en: 'Here’s how to set up the hyperparameters:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何设置超参数的：
- en: 'Create a new YAML file to serve as the hyperparameters for the training. Ours
    is called *Push.yaml* and includes the following hyperparameters and values:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 YAML 文件，用作训练的超参数。我们的称为 *Push.yaml*，包括以下超参数和值：
- en: '[PRE42]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, inside the `venv` we created earlier in [“Setting Up”](ch02.html#ch02-setup),
    fire up the training process by running the following command in your terminal:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在之前在 [“设置”](ch02.html#ch02-setup) 中创建的 `venv` 中，在终端中运行以下命令来启动训练过程：
- en: '[PRE43]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Replace `*config/Push.yaml*` with the path to the configuration file you just
    created.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`*config/Push.yaml*`替换为你刚创建的配置文件的路径。
- en: Once the command is up and running, you should see something that looks like
    [Figure 4-27](#fig:ch04_mlagentstraining). At this point, you can press the Play
    button in Unity.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦命令启动并运行，你应该会看到类似图 [4-27](#fig:ch04_mlagentstraining) 的东西。此时，你可以在 Unity 中按下播放按钮。
- en: '![psml 0222](assets/psml_0222.png)'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0222](assets/psml_0222.png)'
- en: Figure 4-27\. The ML-Agents process begins training
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-27\. ML-Agents 进程开始训练
- en: You’ll know the training process is working when you see output that looks like
    [Figure 4-28](#fig:ch04_mlagentstraining2).
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你看到类似于[图 4-28](#fig:ch04_mlagentstraining2)的输出时，说明训练过程正在进行。
- en: '![psml 0223](assets/psml_0223.png)'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0223](assets/psml_0223.png)'
- en: Figure 4-28\. The ML-Agents process during training
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-28\. 训练期间的 ML-Agents 过程
- en: When the training is complete, refer back to [“When the Training Is Complete”](ch02.html#training-complete)
    for a refresher on how to fine the *.nn* or *.onnx* file that’s been generated.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当训练完成后，请参考[“训练完成后”](ch02.html#training-complete)章节，了解如何找到生成的*.nn*或*.onnx*文件的详细信息。
- en: Use the model to run the agent, and watch it go!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模型来运行代理程序，看看它的表现！
