- en: Chapter 5\. Creating a Self-Driving Car
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。创建自动驾驶汽车
- en: The two simulations you’ve built so far have been fairly abstract concepts—balls
    that roll around a plane in a void, cubes that push other cubes around, and such—but
    simulation for machine learning is genuinely, practically useful (we promise).
    In this chapter, we’re going to make a very simple self-driving car in Unity and
    train it to drive using reinforcement learning. It’s not going to be practical
    in the sense that you can load up the ensuing trained model into a real, physical
    car, but it demonstrates that what you can do in a simulated environment can go
    beyond the abstract.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您构建的两个模拟都是相当抽象的概念——在虚空中滚动的球，推动其他立方体的立方体等——但是用于机器学习的模拟确实是真正实用的（我们保证）。 在本章中，我们将在Unity中制作一个非常简单的自动驾驶汽车，并使用强化学习来训练它驾驶。
    从实用的角度来说，您无法将随后训练的模型加载到真正的物理汽车中，但是它表明了您在模拟环境中可以超越抽象的能力。
- en: Your time has come! You basically, for the good of the world, are going to build
    your own self-driving car ([Figure 5-1](#fig:carshowing)).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是你的时候了！ 基本上，为了世界的利益，您将建造您自己的自动驾驶汽车（见[图5-1](#fig:carshowing)）。
- en: '![psml 0501](assets/psml_0501.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0501](assets/psml_0501.png)'
- en: Figure 5-1\. The self-driving car on its track. In his yurt. With his iPad.
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-1。 自动驾驶汽车在其赛道上。 在他的毡房中。 用他的iPad。
- en: Our self-driving car is only going to exist in a beautiful void of its own,
    instead of the pesky real world—so we get to avoid all those nasty ethical quandaries,
    such as what to do if there’s a human in front of us (we’ll tackle that, a little
    bit, later in the book).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自动驾驶车辆将仅存在于其自身的美丽虚空中，而不是烦人的现实世界——因此我们可以避开所有那些讨厌的伦理困境，比如如果面前有一个人该怎么办（我们稍后会在本书中详细讨论）。
- en: Our car is going to learn how to drive, and not much else. Ready?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的汽车将学会如何驾驶，但除此之外并不多。 准备好了吗？
- en: Creating the Environment
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建环境
- en: The first thing we need to make is the beautiful void our car exists in. It’s
    going to consist of a few things, the most important of which is the track the
    car will navigate. After we build the track, we’ll create the car itself, and
    then set everything up to work with the machine learning system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是我们汽车存在的美丽虚空。 它将包括几个部分，其中最重要的是汽车将要驾驶的赛道。 在我们建造赛道之后，我们将创建汽车本身，然后设置所有内容以与机器学习系统一起工作。
- en: The key pieces of the world are the track, the thing the car drives around,
    and the car itself. That’s it. It’s a pretty simple self-driving car, we admit.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 世界的关键部分是赛道，这是汽车绕行的东西，以及汽车本身。 就这些了。 我们承认这是一辆相当简单的自动驾驶汽车。
- en: We’ll do this work in the Unity Editor, in a scene, as we’ve done with our simulations
    so far. It will involve assembling the world our car lives in, and the car itself.
    A key difference between this and the earlier activities is that we’ll provide
    a downloadable set of assets with which to construct the car’s track.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Unity编辑器中进行这项工作，就像我们迄今为止完成的模拟一样。 它将涉及组装我们汽车生活的世界以及汽车本身。 与之前的活动之间的一个关键区别是，我们将提供一组可下载的资产，用于构建汽车的赛道。
- en: 'Before you move on, do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请执行以下操作：
- en: Create a new 3D Unity project (ours is named “SimpleCar”), as shown in [Figure 5-2](#fig:simplecar).
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity Hub中创建一个新的3D Unity项目（我们的项目名为“SimpleCar”），如[图5-2](#fig:simplecar)所示。
- en: '![psml 0502](assets/psml_0502.png)'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0502](assets/psml_0502.png)'
- en: Figure 5-2\. Creating a new 3D project in the Unity Hub
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-2。 在Unity Hub中创建新的3D项目
- en: Import the Unity ML-Agents package into the Unity project (see [“Creating the
    Unity Project”](ch02.html#creating-unity-project)).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Unity ML-Agents包导入Unity项目（参见[“创建Unity项目”](ch02.html#creating-unity-project)）。
- en: Make sure your Python environment is ready to go (see [“Setting Up”](ch02.html#ch02-setup)).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的Python环境已准备就绪（参见[“设置”](ch02.html#ch02-setup)）。
- en: The Track
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赛道
- en: 'The first thing we’re going to make is the track. Our track is going to be
    nice and simple, since we want to make sure it’s very obvious how our self-driving
    car works. There will be two basic pieces: a straight piece, as shown in [Figure 5-3](#fig:straight_piece),
    and a corner piece, as shown in [Figure 5-4](#fig:left_piece).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是赛道。 我们的赛道将非常简单，因为我们希望确保我们的自动驾驶汽车如何工作非常明显。 将有两个基本部分：如[图5-3](#fig:straight_piece)所示的直道部分，以及如[图5-4](#fig:left_piece)所示的转角部分。
- en: '![psml 0503](assets/psml_0503.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0503](assets/psml_0503.png)'
- en: Figure 5-3\. The straight piece of our track
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-3。 我们赛道的直道部分
- en: '![psml 0504](assets/psml_0504.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0504](assets/psml_0504.png)'
- en: Figure 5-4\. The corner piece of our track
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-4。 我们赛道的角落块
- en: 'Each piece of the track is made up of a floor and some barrier walls. Let’s
    make the straight piece now:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 赛道的每一部分由地板和一些隔离墙组成。现在让我们制作直道部件：
- en: Create a new plane. Name it “Track,” and tag it with “track.”
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新平面。命名为“Track”，并且使用“track”标签标记它。
- en: Create a material in the Project view, name it something like “TrackMaterial”
    so you know what it’s for, and give it a nice color for a road. Ours is black,
    but feel free to get creative. Assign this material to the track plane.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目视图中创建一个材质，命名为类似“TrackMaterial”的名称，以便知道它的用途，并给它一个适合道路的漂亮颜色。我们的是黑色，但你可以随意创意。将此材质分配给赛道平面。
- en: Create a new cube, and using the Inspector set its scale to `(1, 1, 10)`, making
    it long and thin. Position the cube along one edge of the plane with the snap
    tools you’ve previously used.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的立方体，并在检视器中将其缩放设置为`(1, 1, 10)`，使其变长而细。使用之前使用过的对齐工具将立方体沿平面的一条边放置。
- en: Create a material in the Project view, name it something like “WallMaterial,”
    and give it a nice color. Assign this material to the cube.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目视图中创建一个材质，命名为类似“WallMaterial”的名称，并给它一个漂亮的颜色。将此材质分配给立方体。
- en: Duplicate the cube, and move it to the other side of the plane. Your piece should
    look like [Figure 5-5](#fig:straight_piece_2).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制立方体，并将其移动到平面的另一侧。你的部件应该看起来像[图5-5](#fig:straight_piece_2)。
- en: '![psml 0503](assets/psml_0503.png)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0503](assets/psml_0503.png)'
- en: Figure 5-5\. The straight piece
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-5\. 直道部件
- en: Name the two wall pieces some variant of “Wall,” and assign them the tag “wall.”
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这两个墙片命名为“Wall”的某个变种，并将它们分配到“wall”标签。
- en: Create an empty GameObject, name it some variant of “Track_Piece,” and make
    it the parent of the track plane and the two walls, as shown in [Figure 5-6](#fig:hierarchytrackpiece).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的GameObject，命名为类似“Track_Piece”的变种，并将其设置为赛道平面和两堵墙的父对象，如[图5-6](#fig:hierarchytrackpiece)所示。
- en: '![psml 0506](assets/psml_0506.png)'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0506](assets/psml_0506.png)'
- en: Figure 5-6\. The track piece in the Hierarchy
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-6\. 层次结构中的赛道部件
- en: Next, select the track piece parent object, then choose the Assets menu → Create
    → Prefab, as shown in [Figure 5-7](#fig:createprefab).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择赛道部件的父对象，然后选择“Assets”菜单 → 创建 → Prefab，如[图5-7](#fig:createprefab)所示。
- en: '![psml 0507](assets/psml_0507.png)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0507](assets/psml_0507.png)'
- en: Figure 5-7\. Creating a prefab using the Assets menu
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-7\. 使用“Assets”菜单创建预制体
- en: You’ll now have a track prefab in your Project pane, which is a duplicatable
    piece of track. You can modify the prefab once and update all uses of it. We’ll
    be assembling our track using this prefab shortly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在你的项目面板中将会有一个赛道预制体，这是一个可复制的赛道部件。你可以修改一次预制体，然后更新所有使用它的地方。我们很快就会用这个预制体来组装我们的赛道。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can also click and drag from the parent object in the Hierarchy into the
    Project pane to create a prefab.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从层次结构中的父对象中拖动到项目面板中创建一个预制体。
- en: 'Next, we’ll make the corner piece:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将制作角落部件：
- en: In the scene, create another new plane. Name it “CornerTrack,” and tag it with
    “track” (use the same track tag as the previous piece). Assign the previously
    created track material to it.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建另一个新平面。命名为“CornerTrack”，并且使用“track”标签标记它（使用与之前部件相同的赛道标签）。将之前创建的赛道材质分配给它。
- en: Create a new cube, and using the Inspector, set its scale to `(1, 1, 10)`, making
    it long and thin. Position the cube along one edge of the plane with the snap
    tools you’ve previously used. Assign the previously created wall material to it.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的立方体，并在检视器中将其缩放设置为`(1, 1, 10)`，使其变长而细。使用之前使用过的对齐工具将立方体沿平面的一条边放置。将之前创建的墙体材质分配给它。
- en: Duplicate the cube and move it to one side of the plane, making a corner. Your
    piece should look like [Figure 5-8](#fig:cornerpiecestep).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制立方体并将其移动到平面的一侧，形成一个角落。你的部件应该看起来像[图5-8](#fig:cornerpiecestep)。
- en: '![psml 0508](assets/psml_0508.png)'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0508](assets/psml_0508.png)'
- en: Figure 5-8\. The corner piece so far
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-8\. 到目前为止的角落部件
- en: Create a new cube and place it in the opposing corner, as shown in [Figure 5-9](#fig:cornerpiece).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的立方体并放置在对角线上，如[图5-9](#fig:cornerpiece)所示。
- en: '![psml 0504](assets/psml_0504.png)'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0504](assets/psml_0504.png)'
- en: Figure 5-9\. The opposite corner, finalizing the corner piece
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-9\. 对角线上的对立角，最终角落部件
- en: Name the three wall pieces some variant of “Wall,” and assign all three of them
    the tag “wall,” the same as the walls in the previous piece.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这三个墙片命名为“Wall”的某个变种，并且将它们全部分配到“wall”标签，与之前部件中的墙壁相同。
- en: Create an empty GameObject, name it some variant of “Corner Piece,” and make
    it the parent of the track plane and the three walls, as shown in [Figure 5-10](#fig:cornerhierarchy).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的GameObject，命名为类似“Corner Piece”的变种，并将其设置为赛道平面和三堵墙的父对象，如[图5-10](#fig:cornerhierarchy)所示。
- en: '![psml 0510](assets/psml_0510.png)'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0510](assets/psml_0510.png)'
- en: Figure 5-10\. The hierarchy of the corner piece
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-10\. 角落部件的层级结构
- en: Next, select the corner piece parent object, then choose the Assets menu → Create
    → Prefab.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择角落部件的父对象，然后选择 Assets 菜单 → 创建 → Prefab。
- en: You’ll now have a corner prefab in your Project pane, alongside the track prefab.
    Ours are shown in [Figure 5-11](#fig:trackprefabs), with the materials they use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将在项目面板中看到一个角落预制件，以及轨道预制件。我们的显示在[图 5-11](#fig:trackprefabs)中，并附带它们使用的材料。
- en: '![psml 0511](assets/psml_0511.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0511](assets/psml_0511.png)'
- en: Figure 5-11\. The two track prefabs and their materials
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-11\. 两个轨道预制件及其材料
- en: Note
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re comfortable with Unity, you can make your own track pieces however
    you want! It’s beyond the scope of this book to teach you how, but it’s a good
    learning exercise. We recommend trying Blender, the fantastic open source 3D modeling
    tool. If you have Blender and Unity installed on the same machine and you drag
    a *.blend* file into Unity, you can use the file directly within Unity, and any
    changes you make and save in Blender will be reflected automatically.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 Unity 比较熟悉，可以按照自己的想法制作轨道部件！这本书不涵盖这方面的内容，但这是一个很好的学习练习。我们建议尝试 Blender，这是一个出色的开源
    3D 建模工具。如果你在同一台计算机上安装了 Blender 和 Unity，并且将 *.blend* 文件拖入 Unity，你可以直接在 Unity 中使用该文件，并且在
    Blender 中进行的任何更改并保存将自动反映在 Unity 中。
- en: Use Unity’s tools, as you did with the snapping in earlier activities, to place
    the pieces next to each other to lay out a track. Ours is shown in [Figure 5-12](#fig:track),
    but it doesn’t hugely matter what yours looks like right now. All you need to
    do is make a track of similar complexity to ours.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Unity 的工具，就像你在早些活动中使用捕捉工具一样，将部件放置在一起以铺设赛道。我们的赛道显示在[图 5-12](#fig:track)中，但你的外观目前并不重要。你只需要制作一个与我们类似复杂度的赛道即可。
- en: '![psml 0512](assets/psml_0512.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0512](assets/psml_0512.png)'
- en: Figure 5-12\. Our training track
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-12\. 我们的训练赛道
- en: Note
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t feel comfortable making your own track, you can find a premade
    one in the assets available for this book. After you’ve downloaded the assets,
    you can use the track by opening the file *CarPremadeTrack.unitypackage* and importing
    it into your Unity project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太愿意自己制作赛道，可以在本书提供的资产中找到预制赛道。下载资产后，你可以通过打开 *CarPremadeTrack.unitypackage*
    文件并将其导入到 Unity 项目中来使用该赛道。
- en: The Car
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汽车
- en: Next, naturally, we need a car. Our car does not need to be complex, and it
    won’t be rigged or animated in any way (i.e., the wheels won’t move, the lights
    won’t work). It could even be shaped like a cube, but for fun, we’ll make it look
    like a car.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，自然地，我们需要一辆汽车。我们的汽车不需要很复杂，并且不会以任何方式进行装配或动画（即，车轮不会转动，灯光不会工作）。它甚至可以是立方体形状，但为了好玩，我们将其设计成汽车样式。
- en: 'To get the car and get it into the scene, follow these steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取汽车并将其放入场景中，请按照以下步骤操作：
- en: Download a nice car from Sketchfab, as shown in [Figure 5-13](#fig:sketchfabcar).
    The one we used is available [here](https://oreil.ly/puzjd), but any car is fine.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Sketchfab 下载一辆漂亮的汽车，如[图 5-13](#fig:sketchfabcar)所示。我们使用的那辆汽车可以在[这里](https://oreil.ly/puzjd)找到，但任何汽车都可以。
- en: '![psml 0513](assets/psml_0513.png)'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0513](assets/psml_0513.png)'
- en: Figure 5-13\. The car we’re going to use
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-13\. 我们将要使用的汽车
- en: Import the car into your Unity project by dropping the *.blend* file into the
    Assets view.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将汽车导入到 Unity 项目中，方法是将 *.blend* 文件拖放到 Assets 视图中。
- en: Next, create an empty GameObject in the Hierarchy, and name it “Car.”
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在层级中创建一个空的 GameObject，并命名为“Car”。
- en: Add a Rigidbody component to the car, as shown in [Figure 5-14](#fig:carrigidbody).
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个 Rigidbody 组件添加到汽车上，如[图 5-14](#fig:carrigidbody)所示。
- en: '![psml 0514](assets/psml_0514.png)'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0514](assets/psml_0514.png)'
- en: Figure 5-14\. The car’s Rigidbody component
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-14\. 汽车的 Rigidbody 组件
- en: Add a Box Collider to the car, as shown in [Figure 5-15](#fig:carboxcollider).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个盒型碰撞体添加到汽车上，如[图 5-15](#fig:carboxcollider)所示。
- en: '![psml 0515](assets/psml_0515.png)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0515](assets/psml_0515.png)'
- en: Figure 5-15\. The car’s Box Collider
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-15\. 汽车的盒型碰撞体
- en: Drag the newly added car model inside the car GameObject, as shown in [Figure 5-16](#fig:cargameobject).
    Make sure the car model *inside* the GameObject is positioned at `(0,0,0)`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新添加的汽车模型拖入汽车 GameObject 中，如[图 5-16](#fig:cargameobject)所示。确保位于 GameObject 中的汽车模型位于`(0,0,0)`位置。
- en: '![psml 0516](assets/psml_0516.png)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0516](assets/psml_0516.png)'
- en: Figure 5-16\. The car’s GameObject, with the model inside it
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-16\. 汽车的 GameObject，包含其中的模型
- en: Warning
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Make sure the Rigidbody and Box Collider components are attached to the uppermost
    car GameObject (the one you created), and not to the internal GameObject that’s
    created by adding the model to the scene.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保 Rigidbody 和 Box Collider 组件附加到最上层的汽车 GameObject 上（即你创建的那个），而不是添加模型到场景时创建的内部
    GameObject 上。
- en: Position the car GameObject on the track, centered, at a location to be your
    starting spot (it doesn’t matter specifically where it is). Ours is shown in [Figure 5-17](#fig:carontrack).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将汽车 GameObject 定位在赛道上的中心位置，作为你的起始点（具体位置不重要）。我们的位置如 [图 5-17](#fig:carontrack)
    所示。
- en: '![psml 0517](assets/psml_0517.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0517](assets/psml_0517.png)'
- en: Figure 5-17\. The car on the track, in its starting position
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-17\. 赛道上的汽车，处于起始位置
- en: That’s everything for the environment in the scene, so don’t forget to save
    it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是场景中环境的全部内容，所以不要忘记保存。
- en: Setting Up for ML
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置机器学习环境
- en: 'Next, we need to set the project up to be an ML simulation. We’ll do this,
    as we have before, by installing the ML-Agents Unity package, and adding some
    components to the GameObjects in the Unity Editor:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置项目为一个机器学习模拟。我们会像之前一样，通过安装 ML-Agents Unity 包，并在 Unity 编辑器中的 GameObject
    上添加一些组件来实现这一点：
- en: Use the Unity Package Manager to install the Unity ML-Agents Toolkit. Refer
    back to [Chapter 2](ch02.html#chapter-creating-first-simulation) if you need a
    reminder on how to do this.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Unity Package Manager 安装 Unity ML-Agents Toolkit。如果需要提醒，请参考 [第 2 章](ch02.html#chapter-creating-first-simulation)。
- en: Once it’s installed, add a Behavior Parameters component to the car’s GameObject,
    as shown in [Figure 5-18](#fig:carbehpar).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，向汽车的 GameObject 添加一个 Behavior Parameters 组件，如 [图 5-18](#fig:carbehpar)
    所示。
- en: '![psml 0518](assets/psml_0518.png)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0518](assets/psml_0518.png)'
- en: Figure 5-18\. The car’s new Behavior Parameters component
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-18\. 汽车的新行为参数组件
- en: Next, add a Decision Requester component to the car’s GameObject, as shown in
    [Figure 5-19](#fig:decrec).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个决策请求器组件到汽车的 GameObject 上，如 [图 5-19](#fig:decrec) 所示。
- en: '![psml 0519](assets/psml_0519.png)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0519](assets/psml_0519.png)'
- en: Figure 5-19\. The Decision Requester component, added to the car
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-19\. 决策请求器组件，添加到汽车上
- en: 'You should probably save your Unity scene at this point. With that done, it’s
    time to make the car’s script:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能应该保存你的 Unity 场景。完成后，现在是时候制作汽车的脚本了：
- en: Create a new script in the Unity Editor by adding a component to the car’s GameObject.
    Name it “CarAgent,” or something similar.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在汽车的 GameObject 上添加组件在 Unity 编辑器中创建一个新的脚本。命名为“CarAgent”或类似的名称。
- en: 'Open the newly created CarAgent script asset, and inside, import the appropriate
    pieces of the Unity ML-Agents Toolkit in addition to the boilerplate imports:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的 CarAgent 脚本资源，在内部导入适当的 Unity ML-Agents Toolkit 部分，除了样板导入之外：
- en: '[PRE0]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Update the `CarAgent` to inherit from `Agent`, removing all the boilerplate
    code provided by Unity:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `CarAgent`，使其继承自 `Agent`，移除 Unity 提供的所有样板代码：
- en: '[PRE1]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As with the previous simulations, in order to be an agent, our car needs to
    inherit from `Agent`, which comes from the Unity ML-Agents package.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和之前的模拟一样，为了成为一个智能体，我们的汽车需要继承自来自 Unity ML-Agents 包的 `Agent`。
- en: 'Add a few variables:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些变量：
- en: '[PRE2]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’ll be storing the `speed` and `torque` of the car so that we can tweak them,
    as well as a `progressScore`. This allows us to display and use the score (progress
    along the track) if we wish to.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将存储汽车的 `speed` 和 `torque`，以便我们可以调整它们，还有一个 `progressScore`。这允许我们显示和使用分数（沿着赛道的进度），如果我们希望的话。
- en: We’ll also create a place to store the `trackTransform`, which we’ll update
    based on where on the track the car is. The `Transform` type represents a position
    in the 3D scene you’ve created, and is a type that comes from Unity.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还将创建一个地方来存储 `trackTransform`，我们将根据汽车所在的赛道位置来更新它。`Transform` 类型表示你创建的 3D 场景中的位置，并且是
    Unity 中的一种类型。
- en: 'Implement the `Heuristic()` method so that the car can be tested and controlled
    by you, a human, as needed:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `Heuristic()` 方法，以便根据需要由你作为人类进行测试和控制汽车：
- en: '[PRE3]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This `Heuristic()` method is very similar to what we’ve done in earlier simulations:
    it allows us to take the two elements of the `actionsOut` array and assign them
    to Unity’s input system on the `Horizontal` and `Vertical` axes, respectively.
    Whatever keys are assigned to `Horizontal` and `Vertical` axes in the Unity input
    system will control what goes into `actionsOut`.'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 `Heuristic()` 方法与我们在之前的模拟中所做的非常相似：它允许我们将 `actionsOut` 数组的两个元素分配给 Unity 输入系统的
    `Horizontal` 和 `Vertical` 轴。无论在 Unity 输入系统中为 `Horizontal` 和 `Vertical` 轴分配了什么键，都将控制输入到
    `actionsOut`。
- en: Tip
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: We’re using Unity’s “Classic” input system here. It’s technically been superceded
    by a new input system, but as with most things in game engines, nothing is ever
    removed, and there’s no advantage to the added complexity of using the new input
    system here. You can learn about the Classic input system [in the Unity documentation](https://oreil.ly/RimPC),
    and find out about the [Input Manager](https://oreil.ly/EDMPw), which allows you
    to configure what keys are assigned to the axes.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里使用的是Unity的“Classic”输入系统。技术上已被新输入系统取代，但是像游戏引擎中的大多数事物一样，从不会删除任何东西，并且在这里使用新输入系统的增加复杂性没有任何优势。您可以在Unity文档中了解关于经典输入系统的信息[链接](https://oreil.ly/RimPC)，并了解Input
    Manager [链接](https://oreil.ly/EDMPw)，该管理器允许您配置分配给轴的键。
- en: You can choose which keys are assigned to the axes by choosing the Edit menu
    → Project Settings, and choosing Input Manager from the sidebar of the resulting
    dialog. By default, the arrow keys on the keyboard will be assigned.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过选择编辑菜单 → 项目设置，并从对话框的侧边栏中选择输入管理器，来选择为轴分配哪些键。默认情况下，键盘上的箭头键已分配。
- en: 'Create a `PerformMove()` method that takes three floats—for horizontal movement,
    vertical movement, and delta time—and translates and rotates the car appropriately:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`PerformMove()`方法，该方法接受三个浮点数——水平移动、垂直移动和增量时间——并适当地进行车辆的平移和旋转：
- en: '[PRE4]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We’ll be using this `PerformMove()` method to move the car, either via human
    control or the machine learning *brain*. The only thing happening here is that
    we call `Translate` and `Rotate` on the transform (the position) of the car (because
    this script is attached to the car agent in the scene, as a component), in order
    to move it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个`PerformMove()`方法来移动车辆，无论是通过人工控制还是机器学习的*brain*。这里发生的唯一事情就是在车辆的变换上调用`Translate`和`Rotate`（因为此脚本作为组件附加到场景中的车辆代理），以便移动它。
- en: 'Override the `OnActionReceived()` method, which is a required part of being
    an `Agent` via the Unity ML-Agents framework:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`OnActionReceived()`方法是Unity ML-Agents框架中`Agent`所必需的一部分：
- en: '[PRE5]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our `OnActionReceived()` method uses the two `vectorAction` actions received
    from the ML-Agents framework, mapping to horizontal and vertical, gets the last
    or current premoving position, and calls the `PerformMove()` function that we
    created a moment ago to action the move.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的`OnActionReceived()`方法使用从ML-Agents框架接收的两个`vectorAction`动作，映射到水平和垂直方向，获取上一个或当前的预移动位置，并调用我们之前创建的`PerformMove()`函数来执行移动操作。
- en: We’ll be adding some reward functionality to this method shortly, but we’ll
    leave it as is for now.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们很快将在这个方法中添加一些奖励功能，但现在我们将其保持不变。
- en: 'Next, implement `CollectObservations()`, another override of an ML-Agents framework
    method:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现`CollectObservations()`，这是ML-Agents框架方法的另一个覆盖：
- en: '[PRE6]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`CollectObservations()` is used to supply information about the environment
    to the ML-Agents system. Observations are the information the agent knows about
    the world it lives in, and it’s entirely up to you as to how much information
    you supply.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectObservations()`用于向ML-Agents系统提供关于环境的信息。观察是代理所知道的关于其所处世界的信息，您可以决定提供多少信息。'
- en: 'In the car agent’s case, the only thing we’re doing in `CollectObservations()`
    is comparing the direction of the car with the track’s direction. This uses the
    `trackTransform` that we created earlier, which holds the current position of
    the car. This initial observation gives the car something to work with: it needs
    to minimize this angle in order to follow the track. It’s a signed angle, between
    `-180` and `180`, in order to tell the car whether it needs to steer left or right.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于车辆代理，我们在`CollectObservations()`中唯一要做的就是比较车辆的方向与赛道的方向。这使用我们之前创建的`trackTransform`，该变量保存车辆的当前位置。这个初始观察给了车辆需要处理的东西：它需要最小化这个角度以便跟随赛道。这是一个带符号的角度，范围在`-180`到`180`之间，用于告诉车辆是否需要向左或向右转向。
- en: 'Now we’ll briefly jump back to the Unity Editor to add some additional observations
    via components. As we’ve said before, not all observations have to arrive via
    code; some can be added via components in the Unity Editor. Save your code and
    return to your Unity scene:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将暂时返回Unity编辑器，通过组件添加一些额外的观察。正如我们之前所说，不是所有的观察都必须通过代码到达；有些可以通过Unity编辑器中的组件添加。保存您的代码，然后返回Unity场景：
- en: Select the agent’s parent object in the Hierarchy, and use the Add Component
    button in the Inspector to add two Ray Perception Sensor 3D components.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择代理的父对象，并在检视器中使用“添加组件”按钮添加两个Ray Perception Sensor 3D组件。
- en: Give them sensible names (e.g., “RayPerceptionSensor1,” “RayPerceptionSensor2”).
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给它们取一个合理的名字（例如，“RayPerceptionSensor1”，“RayPerceptionSensor2”）。
- en: Set one of them to the parameters shown in [Figure 5-20](#fig:firstraysensor).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其中一个设置为[图5-20](#fig:firstraysensor)中显示的参数。
- en: '![psml 0520](assets/psml_0520.png)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0520](assets/psml_0520.png)'
- en: Figure 5-20\. The first of two Ray Perception Sensor 3D components
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-20。两个三维射线感知传感器组件中的第一个
- en: This sensor sends four rays out from either side of the car and one from the
    front, as shown in [Figure 5-21](#fig:carsensor1).
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个传感器从汽车两侧各发送四条射线，从前方发送一条，如[图5-21](#fig:carsensor1)所示。
- en: '![psml 0521](assets/psml_0521.png)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0521](assets/psml_0521.png)'
- en: Figure 5-21\. The first sensor’s raycasts
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-21。第一个传感器的射线
- en: Set the other Ray Perception Sensor 3D component to the parameters shown in
    [Figure 5-22](#fig:secondraysensor).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个三维射线感知传感器组件设置为[图5-22](#fig:secondraysensor)中显示的参数。
- en: '![psml 0522](assets/psml_0522.png)'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0522](assets/psml_0522.png)'
- en: Figure 5-22\. The second of two Ray Perception Sensor 3D components
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-22。两个三维射线感知传感器组件中的第二个
- en: Note
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important that both of these sensors are set to only detect things tagged
    with “wall.”
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要的是这两个传感器都设置为只检测标记为“wall”的物体。
- en: This sensor sends one ray out from the front of the car and one directly from
    the back, as shown in [Figure 5-23](#fig:carsensor2).
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个传感器从汽车前方发送一条射线和从后方直接发送一条射线，如[图5-23](#fig:carsensor2)所示。
- en: Tip
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If we didn’t override `CollectObservations()` and implement it in code, we could
    still exclusively supply observations to our agent via components in the editor
    if we wanted to.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们没有重写`CollectObservations()`并在代码中实现它，如果我们愿意，我们仍然可以通过编辑器中的组件专门为我们的代理提供观察。
- en: '![psml 0523](assets/psml_0523.png)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0523](assets/psml_0523.png)'
- en: Figure 5-23\. The second sensor’s raycasts
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-23。第二个传感器的射线
- en: Save the scene, and return to the agent script in your code editor.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景，并返回到代码编辑器中的代理脚本。
- en: 'Now we’ll implement our own function, named `TrackProgress()`. It will be used
    to figure out a reward system:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现自己的函数，名为`TrackProgress()`。它将用于制定奖励系统：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`TrackProgress()` will return `1` if we’re moving in a forward direction to
    a new part of the road, `-1` if we move backward, and `0` in other situations.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrackProgress()`如果我们向前移动到道路的新部分，将返回`1`，如果向后移动，则返回`-1`，其他情况返回`0`。'
- en: 'It does this by employing the following logic:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过采用以下逻辑来实现：
- en: It casts a ray from the middle of the car object down into the ground.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从汽车对象的中心向下投射一条射线到地面。
- en: Using the information from that ray, it knows which tile of the track the car
    is currently on.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用从那个射线获取的信息，它知道汽车当前在赛道的哪个瓷砖上。
- en: If the current tile is not the same as the last one, it calculates the angle
    between the direction of the tile and the position of the car (with respect to
    the tile).
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前的瓷砖与上一个不同，它会计算瓷砖方向与汽车位置（相对于瓷砖）之间的角度。
- en: If that angle is less than 90 degrees, it moved forward; otherwise, it went
    backward.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果那个角度小于90度，它就向前移动；否则，它就向后移动。
- en: 'It’s important to provide the car with the ability to know whether it’s progressing;
    otherwise, it won’t know when to be rewarded. That’s what this function is for.
    Next, we need to create some new methods:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要让汽车具备判断是否在前进的能力；否则，它就不会知道何时应该受到奖励。这就是这个函数的作用。接下来，我们需要创建一些新方法：
- en: 'First we need to implement `OnEpisodeBegin()`, another override of the ML-Agents
    framework:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要实现`OnEpisodeBegin()`，这是ML-Agents框架的另一个重写：
- en: '[PRE8]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We’re not doing much here: just setting the car’s local position and rotation
    to `zero` and `identity`, respectively. This function is called at the beginning
    of each episode, hence we’re using it to reset the car’s local position and rotation.'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里做的不多：只是将汽车的本地位置和旋转设置为`zero`和`identity`。这个函数在每个episode开始时被调用，因此我们在这里用它来重置汽车的本地位置和旋转。
- en: 'The next method to implement is `OnCollisionEnter()`, which we’ll use to make
    sure that the car agent is penalized accordingly for colliding with the walls:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来要实现的方法是`OnCollisionEnter()`，我们将用它来确保汽车代理在与墙碰撞时受到相应的惩罚：
- en: '[PRE9]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`OnCollisionEnter()` is a standard part of Unity objects, and is called whenever
    something collides with another object in the scene. In this case, we check to
    see if the thing that was collided with is tagged with “wall.” We’ll tag the objects
    in the environment with “wall,” and some other useful tags, shortly in the Unity
    Editor. If the car agent does collide with a wall, it’s penalized with a `-1`
    reward, and the `EndEpisode()` function, which is part of ML-Agents, is called
    to start a new episode.'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`OnCollisionEnter()` 是 Unity 对象的标准部分，并在场景中的物体碰撞时调用。在这种情况下，我们检查碰撞的物体是否被标记为 “wall”。我们将在
    Unity 编辑器中很快为环境中的物体添加 “wall” 和其他一些有用的标记。如果汽车代理与墙壁相撞，它会受到 `-1` 奖励的惩罚，并且调用了属于 ML-Agents
    的 `EndEpisode()` 函数以开始新的一集。'
- en: 'Next, we’ll add an `Initialize()` method, which calls `TrackProgress()` for
    the first time:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个 `Initialize()` 方法，该方法首次调用 `TrackProgress()`：
- en: '[PRE10]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Initialize()` is part of Unity, and is called when an object is first instantiated.'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Initialize()` 是 Unity 的一部分，在对象首次实例化时调用。'
- en: 'Returning to `OnActionReceived()`, at the end of the previous code we wrote,
    after the call to `PerformMove()`, we’ll add some more code:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `OnActionReceived()`，在我们之前编写的代码结尾，在调用 `PerformMove()` 之后，我们将添加一些代码：
- en: '[PRE11]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code first stores the position before the car moves, and then calls `T⁠r⁠a⁠c⁠k​P⁠r⁠o⁠g⁠r⁠e⁠s⁠s⁠()`
    to check if the tile we’re on has changed.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码首先在汽车移动前存储位置，然后调用 `TrackProgress()` 检查我们所在的瓦片是否发生了改变。
- en: Using those two pieces of information, we compute a vector, `dirMoved`, that
    represents the direction we moved in, and we use that to get the angle between
    the current track piece and the agent.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 利用这两个信息，我们计算一个代表我们移动方向的向量 `dirMoved`，然后用它来获取当前赛道片段与代理之间的角度。
- en: 'Because the angle we get is between 0 and 180 degrees, it’s easier if we map
    it to something smaller: 0–2\. We do that by dividing it by 90\. Subtracting this
    from 1 gives a small bonus (that decreases while the angle increases). If our
    angle is greater than 90 degrees, it becomes negative.'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为我们获取的角度在 0 到 180 度之间，如果我们将其映射到更小的范围 0–2，会更容易：我们通过 90 进行除法。从 1 中减去这个值会给出一个小的奖励（当角度增加时会减小）。如果我们的角度大于
    90 度，则会变成负数。
- en: The result is multiplied by the vertical speed (which is positive), and thus
    we have a reward. We multiply the whole thing by the time (`Time.fixedDeltaTime`)
    so that we only get one reward per second, at the most.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果乘以垂直速度（为正），因此我们有了一个奖励。我们将整个结果乘以时间 (`Time.fixedDeltaTime`)，以便我们每秒最多只获得一个奖励。
- en: Don’t forget to save the code in your code editor, and the scene in the Unity
    Editor.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在代码编辑器中保存代码和在 Unity 编辑器中保存场景。
- en: Training the Simulation
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练仿真
- en: With everything built, we’re going to set things up to train, and then we’ll
    see how our simple self-driving car works in practice. The first step is to set
    the behavior to heuristic so that we can test the car using keyboard controls,
    then we’ll move to training.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在一切都建好之后，我们将设置训练环境，然后看看我们简单的自动驾驶汽车在实践中是如何工作的。第一步是将行为设置为启发式，这样我们就可以使用键盘控制汽车进行测试，然后我们将进行训练。
- en: To set your car agent’s behavior type to heuristic, open the scene in the Unity
    Editor, select the agent in the Hierarchy and change the behavior type to Heuristic
    as shown in [Figure 5-24](#fig:heurbeh), then play the scene in Unity.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要将汽车代理的行为类型设置为启发式，请在 Unity 编辑器中打开场景，选择 Hierarchy 中的代理并将行为类型更改为启发式，如 [图 5-24](#fig:heurbeh)
    中所示，然后在 Unity 中运行场景。
- en: '![psml 0524](assets/psml_0524.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0524](assets/psml_0524.png)'
- en: Figure 5-24\. Setting the behavior type to Heuristic
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-24\. 将行为类型设置为启发式
- en: You’ll be able to use your keyboard (arrow and WASD keys, in all likelihood—unless
    you modified them in the Unity input system) to drive the car around the track.
    Amazing, right?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用键盘（箭头和WASD键，很可能会使用这些键，除非您在Unity输入系统中修改了它们）来驾驶汽车在赛道上行驶。很神奇，对吧？
- en: Warning
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: It will probably be quite difficult to drive well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 驾驶可能会非常困难。
- en: Training
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 训练
- en: 'As with the previous chapters, training a simulation requires a configuration
    file and some ML-Agents scripts to read them:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，训练仿真需要一个配置文件和一些 ML-Agents 脚本来读取它们：
- en: 'First, we’ll need the customary YAML file to serve as the hyperparameters for
    our training. Create a new file named *CarAgent.yaml*, and include the following
    hyperparameters and values:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个传统的 YAML 文件作为我们的训练超参数。创建一个名为 *CarAgent.yaml* 的新文件，并包含以下超参数和值：
- en: '[PRE12]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, select the car agent in the Hierarchy panel, and choose Default from the
    Behavior Type drop-down menu in the Behavior Parameters component, as shown in
    [Figure 5-25](#fig:defaultbehtype).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在层级面板中选择汽车代理，然后在行为参数组件的行为类型下拉菜单中选择默认，如[图 5-25](#fig:defaultbehtype)所示。
- en: '![psml 0525](assets/psml_0525.png)'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0525](assets/psml_0525.png)'
- en: Figure 5-25\. Setting Behavior Type to Default
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-25\. 将行为类型设置为默认
- en: 'With that, you’re ready to train. Fire up the virtual environment we created
    earlier and start the training process by running the following command in your
    terminal:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好开始训练了。启动之前创建的虚拟环境，并通过在终端中运行以下命令开始训练过程：
- en: '[PRE13]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You will need to replace the path to the YAML file with the path to the configuration
    file that was created a moment ago.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要用刚刚创建的配置文件的路径替换到 YAML 文件的路径。
- en: Once your system has executed `mlagents-learn`, you should see something that
    looks a lot like [Figure 5-26](#fig:startingtrainingcar). Press the Play button
    in the Unity Editor.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦系统执行了 `mlagents-learn`，你应该会看到类似于[图 5-26](#fig:startingtrainingcar)的东西。在 Unity
    编辑器中按下播放按钮。
- en: '![psml 0526](assets/psml_0526.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0526](assets/psml_0526.png)'
- en: Figure 5-26\. Getting ready to start training the car
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-26\. 准备开始训练汽车
- en: The training will run for `1.0e6` steps (also known as `1,000,000` steps). You
    can monitor the training with TensorBoard if you’d like. Refer back to [“Monitoring
    the Training with TensorBoard”](ch02.html#ch02-tensorboard-intro) for details
    on that.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 训练将运行 `1.0e6` 步（也就是 `1,000,000` 步）。如果愿意，你可以使用 TensorBoard 监控训练进度。有关详细信息，请参阅[“使用
    TensorBoard 监控训练”](ch02.html#ch02-tensorboard-intro)。
- en: When the Training Is Complete
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当训练完成时
- en: Eventually the training will complete, and you will have an *.onnx* or *.nn*
    file, as shown in [Figure 5-27](#fig:wrotenn).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，训练将完成，你将获得一个 *.onnx* 或 *.nn* 文件，如[图 5-27](#fig:wrotenn)所示。
- en: '![psml 0527](assets/psml_0527.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![psml 0527](assets/psml_0527.png)'
- en: Figure 5-27\. The .onnx file is written out when training is completed
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-27\. 当训练完成时，会生成 .onnx 文件。
- en: 'Next, we need to attach the newly trained machine learning model (stored in
    the *.nn* or *.onnx* file) to the agent:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将新训练的机器学习模型（存储在 *.nn* 或 *.onnx* 文件中）附加到代理程序：
- en: Drag the new model file into the Project pane in the Unity Editor and then attach
    it to your agent, as shown in [Figure 5-28](#fig:nnfile).
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新模型文件拖到 Unity 编辑器中的项目窗格中，然后将其附加到你的代理程序，如[图 5-28](#fig:nnfile)所示。
- en: '![psml 0528](assets/psml_0528.png)'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![psml 0528](assets/psml_0528.png)'
- en: Figure 5-28\. The model file attached in the Unity Editor
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-28\. 在 Unity 编辑器中附加的模型文件
- en: Run the project, and watch your self-driving car self-drive itself around your
    track! Amazing.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目，看着你的自动驾驶汽车在赛道上自动驾驶！令人惊叹。
