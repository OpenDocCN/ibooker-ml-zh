<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 7. Handling Dates and Times" data-type="chapter" epub:type="chapter"><div class="chapter" id="handling-dates-and-times">
<h1><span class="label">Chapter 7. </span>Handling Dates and Times</h1>
<section data-pdf-bookmark="7.0 Introduction" data-type="sect1"><div class="sect1" id="id173">
<h1>7.0 Introduction</h1>
<p>Dates and <a data-primary="dates and times (datetimes)" data-type="indexterm" id="ix_dt_time_ch7"/>times (datetimes), such as the time of a particular sale or the date of a public health statistic, are frequently encountered during preprocessing for machine learning. <em>Longitudinal data</em> (or <em>time series data</em>) is data that’s collected repeatedly for the same variables over points in time. In this chapter, we will build a toolbox of strategies for handling time series data, including tackling time zones and creating lagged time features. Specifically, we will focus on the time series tools in the pandas <a data-primary="datetime library" data-type="indexterm" id="id1333"/>library, which centralizes the functionality of many other general libraries such as <code>datetime</code>.</p>
</div></section>
<section data-pdf-bookmark="7.1 Converting Strings to Dates" data-type="sect1"><div class="sect1" id="converting-strings-to-dates">
<h1>7.1 Converting Strings to Dates</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id487">
<h2>Problem</h2>
<p>Given a <a data-primary="dates and times (datetimes)" data-secondary="converting strings to dates" data-type="indexterm" id="ix_dt_conv_string"/><a data-primary="strings" data-secondary="converting to dates" data-type="indexterm" id="ix_string_conv_date"/>vector of strings representing dates and times, you want to transform them into time series data.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id174">
<h2>Solution</h2>
<p>Use <a data-primary="to_datetime method" data-type="indexterm" id="ix_to_datetime_meth"/>pandas’ <code>to_datetime</code> with the format of the date and/or time
specified in the <code>format</code> parameter:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Load libraries</code>
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>

<code class="c1"># Create strings</code>
<code class="n">date_strings</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="s1">'03-04-2005 11:35 PM'</code><code class="p">,</code>
                         <code class="s1">'23-05-2010 12:01 AM'</code><code class="p">,</code>
                         <code class="s1">'04-09-2009 09:09 PM'</code><code class="p">])</code>

<code class="c1"># Convert to datetimes</code>
<code class="p">[</code><code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code><code class="n">date</code><code class="p">,</code> <code class="nb">format</code><code class="o">=</code><code class="s1">'</code><code class="si">%d</code><code class="s1">-</code><code class="si">%m</code><code class="s1">-</code><code class="si">%Y</code><code class="s1"> %I:</code><code class="si">%M</code><code class="s1"> %p'</code><code class="p">)</code> <code class="k">for</code> <code class="n">date</code> <code class="ow">in</code> <code class="n">date_strings</code><code class="p">]</code></pre>
<pre data-type="programlisting">[Timestamp('2005-04-03 23:35:00'),
 Timestamp('2010-05-23 00:01:00'),
 Timestamp('2009-09-04 21:09:00')]</pre>
<p>We <a data-primary="error handling" data-secondary="converting strings to dates" data-type="indexterm" id="id1334"/>might also want to add an argument to the <code>errors</code> parameter to
handle problems:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Convert to datetimes</code>
<code class="p">[</code><code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code><code class="n">date</code><code class="p">,</code> <code class="nb">format</code><code class="o">=</code><code class="s2">"</code><code class="si">%d</code><code class="s2">-</code><code class="si">%m</code><code class="s2">-</code><code class="si">%Y</code><code class="s2"> %I:</code><code class="si">%M</code><code class="s2"> %p"</code><code class="p">,</code> <code class="n">errors</code><code class="o">=</code><code class="s2">"coerce"</code><code class="p">)</code>
<code class="k">for</code> <code class="n">date</code> <code class="ow">in</code> <code class="n">date_strings</code><code class="p">]</code></pre>
<pre data-type="programlisting">[Timestamp('2005-04-03 23:35:00'),
 Timestamp('2010-05-23 00:01:00'),
 Timestamp('2009-09-04 21:09:00')]</pre>
<p>If <code>errors="coerce"</code>, then any problem that occurs will not raise an
error (the default behavior) but instead will set the value causing the
error to <code>NaT</code> (a missing value). This allows you to deal with outliers by filling them with null values, as opposed to troubleshooting errors for individual records in the data.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id175">
<h2>Discussion</h2>
<p>When dates and times come as strings, we need to convert them into a
data type Python can understand. While there are a number of Python
tools for converting strings to datetimes, following our use of pandas
in other recipes we can use 
<span class="keep-together"><code>to_datetime</code></span> to conduct the transformation. One obstacle to using strings to represent dates and times is that the format of the strings can vary significantly between data sources. For example, one vector of dates might represent March 23, 2015 as “03-23-15” while another might use “3|23|2015”. We can use the <code>format</code> parameter to specify the exact format of the string. Here are some common date and time formatting codes:<a data-primary="" data-startref="ix_to_datetime_meth" data-type="indexterm" id="id1335"/><a data-primary="" data-startref="ix_dt_conv_string" data-type="indexterm" id="id1336"/><a data-primary="" data-startref="ix_string_conv_date" data-type="indexterm" id="id1337"/></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
<th>Example</th>
</tr></thead>
<tbody>
<tr>
<td><code>%Y</code></td>
<td>Full year</td>
<td><code>2001</code></td>
</tr>
<tr>
<td><code>%m</code></td>
<td>Month w/ zero padding</td>
<td><code>04</code></td>
</tr>
<tr>
<td><code>%d</code></td>
<td>Day of the month w/ zero padding</td>
<td><code>09</code></td>
</tr>
<tr>
<td><code>%I</code></td>
<td>Hour (12hr clock) w/ zero padding</td>
<td><code>02</code></td>
</tr>
<tr>
<td><code>%p</code></td>
<td>AM or PM</td>
<td><code>AM</code></td>
</tr>
<tr>
<td><code>%M</code></td>
<td>Minute w/ zero padding</td>
<td><code>05</code></td>
</tr>
<tr>
<td><code>%S</code></td>
<td>Second w/ zero padding</td>
<td><code>09</code></td>
</tr></tbody>
</table>
</div></section>
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1338">
<h2>See Also</h2>
<ul>
<li>
<p><a href="https://oreil.ly/4-tN6">Python strftime Cheatsheet (complete list of Python string time codes)</a></p>
</li>
</ul>
</div></section>
</div></section>
<section data-pdf-bookmark="7.2 Handling Time Zones" data-type="sect1"><div class="sect1" id="handling-time-zones">
<h1>7.2 Handling Time Zones</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id176">
<h2>Problem</h2>
<p>You have time series data and want to add or change <a data-primary="time zones, handling" data-type="indexterm" id="ix_time_zones"/><a data-primary="dates and times (datetimes)" data-secondary="time zones" data-type="indexterm" id="ix_dt_time_tz"/>time zone
information.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id177">
<h2>Solution</h2>
<p>Unless specified, pandas objects have no time zone. We can add
a time zone using <code>tz</code> during creation:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Load library</code>
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>

<code class="c1"># Create datetime</code>
<code class="n">pd</code><code class="o">.</code><code class="n">Timestamp</code><code class="p">(</code><code class="s1">'2017-05-01 06:00:00'</code><code class="p">,</code> <code class="n">tz</code><code class="o">=</code><code class="s1">'Europe/London'</code><code class="p">)</code></pre>
<pre data-type="programlisting">Timestamp('2017-05-01 06:00:00+0100', tz='Europe/London')</pre>
<p>We <a data-primary="tz_localize" data-type="indexterm" id="id1339"/>can add a time zone to a previously created datetime using
<code>tz_localize</code>:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Create datetime</code>
<code class="n">date</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Timestamp</code><code class="p">(</code><code class="s1">'2017-05-01 06:00:00'</code><code class="p">)</code>

<code class="c1"># Set time zone</code>
<code class="n">date_in_london</code> <code class="o">=</code> <code class="n">date</code><code class="o">.</code><code class="n">tz_localize</code><code class="p">(</code><code class="s1">'Europe/London'</code><code class="p">)</code>

<code class="c1"># Show datetime</code>
<code class="n">date_in_london</code></pre>
<pre data-type="programlisting">Timestamp('2017-05-01 06:00:00+0100', tz='Europe/London')</pre>
<p>We also can <a data-primary="tz_convert" data-type="indexterm" id="id1340"/>convert to a different time zone:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Change time zone</code>
<code class="n">date_in_london</code><code class="o">.</code><code class="n">tz_convert</code><code class="p">(</code><code class="s1">'Africa/Abidjan'</code><code class="p">)</code></pre>
<pre data-type="programlisting">Timestamp('2017-05-01 05:00:00+0000', tz='Africa/Abidjan')</pre>
<p>Finally, the pandas <code>Series</code> objects can apply <code>tz_localize</code>
and <code>tz_convert</code> to every element:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Create three dates</code>
<code class="n">dates</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">(</code><code class="n">pd</code><code class="o">.</code><code class="n">date_range</code><code class="p">(</code><code class="s1">'2/2/2002'</code><code class="p">,</code> <code class="n">periods</code><code class="o">=</code><code class="mi">3</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s1">'M'</code><code class="p">))</code>

<code class="c1"># Set time zone</code>
<code class="n">dates</code><code class="o">.</code><code class="n">dt</code><code class="o">.</code><code class="n">tz_localize</code><code class="p">(</code><code class="s1">'Africa/Abidjan'</code><code class="p">)</code></pre>
<pre data-type="programlisting">0   2002-02-28 00:00:00+00:00
1   2002-03-31 00:00:00+00:00
2   2002-04-30 00:00:00+00:00
dtype: datetime64[ns, Africa/Abidjan]</pre>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id178">
<h2>Discussion</h2>
<p>pandas supports two sets of strings representing timezones; however, I suggest using the <code>pytz</code> library <a data-primary="pytz library" data-type="indexterm" id="id1341"/>strings. We can see all the strings used to represent time zones by importing <code>all_timezones</code>:<a data-primary="" data-startref="ix_dt_time_tz" data-type="indexterm" id="id1342"/><a data-primary="" data-startref="ix_time_zones" data-type="indexterm" id="id1343"/></p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Load library</code>
<code class="kn">from</code> <code class="nn">pytz</code> <code class="kn">import</code> <code class="n">all_timezones</code>

<code class="c1"># Show two time zones</code>
<code class="n">all_timezones</code><code class="p">[</code><code class="mi">0</code><code class="p">:</code><code class="mi">2</code><code class="p">]</code></pre>
<pre data-type="programlisting">['Africa/Abidjan', 'Africa/Accra']</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="7.3 Selecting Dates and Times" data-type="sect1"><div class="sect1" id="selecting-dates-and-times">
<h1>7.3 Selecting Dates and Times</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id488">
<h2>Problem</h2>
<p>You have a <a data-primary="dates and times (datetimes)" data-secondary="selecting dates and times" data-type="indexterm" id="ix_dt_time_sel"/>vector of dates and you want to select one or more.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id179">
<h2>Solution</h2>
<p>Use two boolean conditions as the start and end dates:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Load library</code>
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>

<code class="c1"># Create data frame</code>
<code class="n">dataframe</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">()</code>

<code class="c1"># Create datetimes</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s1">'date'</code><code class="p">]</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">date_range</code><code class="p">(</code><code class="s1">'1/1/2001'</code><code class="p">,</code> <code class="n">periods</code><code class="o">=</code><code class="mi">100000</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s1">'H'</code><code class="p">)</code>

<code class="c1"># Select observations between two datetimes</code>
<code class="n">dataframe</code><code class="p">[(</code><code class="n">dataframe</code><code class="p">[</code><code class="s1">'date'</code><code class="p">]</code> <code class="o">&gt;</code> <code class="s1">'2002-1-1 01:00:00'</code><code class="p">)</code> <code class="o">&amp;</code>
          <code class="p">(</code><code class="n">dataframe</code><code class="p">[</code><code class="s1">'date'</code><code class="p">]</code> <code class="o">&lt;=</code> <code class="s1">'2002-1-1 04:00:00'</code><code class="p">)]</code></pre>
<table>
<thead>
<tr>
<th/>
<th>date</th>
</tr>
</thead>
<tbody>
<tr>
<th>8762</th>
<td>2002-01-01 02:00:00</td>
</tr>
<tr>
<th>8763</th>
<td>2002-01-01 03:00:00</td>
</tr>
<tr>
<th>8764</th>
<td>2002-01-01 04:00:00</td>
</tr>
</tbody>
</table>
<p>Alternatively, we can set the date column as the DataFrame’s index and
then <a data-primary="index slicing, selecting dates and times" data-type="indexterm" id="id1344"/><a data-primary="loc method" data-type="indexterm" id="id1345"/>slice using <code>loc</code>:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Set index</code>
<code class="n">dataframe</code> <code class="o">=</code> <code class="n">dataframe</code><code class="o">.</code><code class="n">set_index</code><code class="p">(</code><code class="n">dataframe</code><code class="p">[</code><code class="s1">'date'</code><code class="p">])</code>

<code class="c1"># Select observations between two datetimes</code>
<code class="n">dataframe</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="s1">'2002-1-1 01:00:00'</code><code class="p">:</code><code class="s1">'2002-1-1 04:00:00'</code><code class="p">]</code></pre>
<table>
<thead>
<tr>
<th>date</th>
<th>date</th>
</tr>
</thead>
<tbody>
<tr>
<th>2002-01-01 01:00:00</th>
<td>2002-01-01 01:00:00</td>
</tr>
<tr>
<th>2002-01-01 02:00:00</th>
<td>2002-01-01 02:00:00</td>
</tr>
<tr>
<th>2002-01-01 03:00:00</th>
<td>2002-01-01 03:00:00</td>
</tr>
<tr>
<th>2002-01-01 04:00:00</th>
<td>2002-01-01 04:00:00</td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id180">
<h2>Discussion</h2>
<p>Whether we use <a data-primary="boolean conditions" data-secondary="selecting dates and times" data-type="indexterm" id="id1346"/>boolean conditions or index slicing is situation
dependent. If we wanted to do some complex time series manipulation, it
might be worth the overhead of setting the date column as the index of
the DataFrame, but if we wanted to do some simple data wrangling, the boolean conditions might be easier.<a data-primary="" data-startref="ix_dt_time_sel" data-type="indexterm" id="id1347"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="7.4 Breaking Up Date Data into Multiple Features" data-type="sect1"><div class="sect1" id="breaking-up-date-data-into-multiple-features">
<h1>7.4 Breaking Up Date Data into Multiple Features</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id489">
<h2>Problem</h2>
<p>You have a <a data-primary="dates and times (datetimes)" data-secondary="breaking up date data into multiple features" data-type="indexterm" id="id1348"/>column of dates and times and you want to create features for
year, month, day, hour, and minute.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id181">
<h2>Solution</h2>
<p>Use the time properties in <a data-primary="Series.dt" data-type="indexterm" id="id1349"/>pandas <code>Series.dt</code>:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Load library</code>
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>

<code class="c1"># Create data frame</code>
<code class="n">dataframe</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">()</code>

<code class="c1"># Create five dates</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s1">'date'</code><code class="p">]</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">date_range</code><code class="p">(</code><code class="s1">'1/1/2001'</code><code class="p">,</code> <code class="n">periods</code><code class="o">=</code><code class="mi">150</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s1">'W'</code><code class="p">)</code>

<code class="c1"># Create features for year, month, day, hour, and minute</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s1">'year'</code><code class="p">]</code> <code class="o">=</code> <code class="n">dataframe</code><code class="p">[</code><code class="s1">'date'</code><code class="p">]</code><code class="o">.</code><code class="n">dt</code><code class="o">.</code><code class="n">year</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s1">'month'</code><code class="p">]</code> <code class="o">=</code> <code class="n">dataframe</code><code class="p">[</code><code class="s1">'date'</code><code class="p">]</code><code class="o">.</code><code class="n">dt</code><code class="o">.</code><code class="n">month</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s1">'day'</code><code class="p">]</code> <code class="o">=</code> <code class="n">dataframe</code><code class="p">[</code><code class="s1">'date'</code><code class="p">]</code><code class="o">.</code><code class="n">dt</code><code class="o">.</code><code class="n">day</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s1">'hour'</code><code class="p">]</code> <code class="o">=</code> <code class="n">dataframe</code><code class="p">[</code><code class="s1">'date'</code><code class="p">]</code><code class="o">.</code><code class="n">dt</code><code class="o">.</code><code class="n">hour</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s1">'minute'</code><code class="p">]</code> <code class="o">=</code> <code class="n">dataframe</code><code class="p">[</code><code class="s1">'date'</code><code class="p">]</code><code class="o">.</code><code class="n">dt</code><code class="o">.</code><code class="n">minute</code>

<code class="c1"># Show three rows</code>
<code class="n">dataframe</code><code class="o">.</code><code class="n">head</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code></pre>
<table>
<thead>
<tr>
<th/>
<th>date</th>
<th>year</th>
<th>month</th>
<th>day</th>
<th>hour</th>
<th>minute</th>
</tr>
</thead>
<tbody>
<tr>
<th>0</th>
<td>2001-01-07</td>
<td>2001</td>
<td>1</td>
<td>7</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<th>1</th>
<td>2001-01-14</td>
<td>2001</td>
<td>1</td>
<td>14</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<th>2</th>
<td>2001-01-21</td>
<td>2001</td>
<td>1</td>
<td>21</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id1350">
<h2>Discussion</h2>
<p>Sometimes it can be useful to break up a column of dates into
components. For example, we might want a feature that includes just the
year of the observation or we might want to consider only the month of some observations so we can compare them regardless of year.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="7.5 Calculating the Difference Between Dates" data-type="sect1"><div class="sect1" id="calculating-the-difference-between-dates">
<h1>7.5 Calculating the Difference Between Dates</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id490">
<h2>Problem</h2>
<p>You have two <a data-primary="dates and times (datetimes)" data-secondary="differences between dates" data-type="indexterm" id="id1351"/>datetime features and want to calculate the time between
them for each observation.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id1352">
<h2>Solution</h2>
<p>Subtract the two date features using pandas:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Load library</code>
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>

<code class="c1"># Create data frame</code>
<code class="n">dataframe</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">()</code>

<code class="c1"># Create two datetime features</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s1">'Arrived'</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="n">pd</code><code class="o">.</code><code class="n">Timestamp</code><code class="p">(</code><code class="s1">'01-01-2017'</code><code class="p">),</code> <code class="n">pd</code><code class="o">.</code><code class="n">Timestamp</code><code class="p">(</code><code class="s1">'01-04-2017'</code><code class="p">)]</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s1">'Left'</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="n">pd</code><code class="o">.</code><code class="n">Timestamp</code><code class="p">(</code><code class="s1">'01-01-2017'</code><code class="p">),</code> <code class="n">pd</code><code class="o">.</code><code class="n">Timestamp</code><code class="p">(</code><code class="s1">'01-06-2017'</code><code class="p">)]</code>

<code class="c1"># Calculate duration between features</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s1">'Left'</code><code class="p">]</code> <code class="o">-</code> <code class="n">dataframe</code><code class="p">[</code><code class="s1">'Arrived'</code><code class="p">]</code></pre>
<pre data-type="programlisting">0   0 days
1   2 days
dtype: timedelta64[ns]</pre>
<p>Often we will want to remove the <code>days</code> output and keep only the
numerical value:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Calculate duration between features</code>
<code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">(</code><code class="n">delta</code><code class="o">.</code><code class="n">days</code> <code class="k">for</code> <code class="n">delta</code> <code class="ow">in</code> <code class="p">(</code><code class="n">dataframe</code><code class="p">[</code><code class="s1">'Left'</code><code class="p">]</code> <code class="o">-</code> <code class="n">dataframe</code><code class="p">[</code><code class="s1">'Arrived'</code><code class="p">]))</code></pre>
<pre data-type="programlisting">0    0
1    2
dtype: int64</pre>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id182">
<h2>Discussion</h2>
<p>There are times when the feature we want is the change (delta) between
two points in time. For example, we might have the dates a customer
checks in and checks out of a hotel, but the feature we want is the
duration of the customer’s stay. <a data-primary="TimeDelta data type" data-type="indexterm" id="id1353"/>pandas makes this calculation easy using the
<code>TimeDelta</code> data type.</p>
</div></section>
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1354">
<h2>See Also</h2>
<ul>
<li>
<p><a href="https://oreil.ly/fbgp-">pandas documentation: Time Deltas</a></p>
</li>
</ul>
</div></section>
</div></section>
<section data-pdf-bookmark="7.6 Encoding Days of the Week" data-type="sect1"><div class="sect1" id="encoding-days-of-the-week">
<h1>7.6 Encoding Days of the Week</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id183">
<h2>Problem</h2>
<p>You have a vector of dates and want to know the <a data-primary="days of the week, encoding" data-type="indexterm" id="id1355"/><a data-primary="dates and times (datetimes)" data-secondary="days of the week" data-type="indexterm" id="id1356"/>day of the week for each
date.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id184">
<h2>Solution</h2>
<p>Use the <a data-primary="Series.dt" data-type="indexterm" id="id1357"/><a data-primary="day_name method" data-type="indexterm" id="id1358"/>pandas <code>Series.dt</code> method <code>day_name()</code>:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Load library</code>
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>

<code class="c1"># Create dates</code>
<code class="n">dates</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">(</code><code class="n">pd</code><code class="o">.</code><code class="n">date_range</code><code class="p">(</code><code class="s2">"2/2/2002"</code><code class="p">,</code> <code class="n">periods</code><code class="o">=</code><code class="mi">3</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s2">"M"</code><code class="p">))</code>

<code class="c1"># Show days of the week</code>
<code class="n">dates</code><code class="o">.</code><code class="n">dt</code><code class="o">.</code><code class="n">day_name</code><code class="p">()</code></pre>
<pre data-type="programlisting">0    Thursday
1      Sunday
2     Tuesday
dtype: object</pre>
<p>If we want the output to be a numerical value and therefore more
usable as a machine learning feature, we can use <code>weekday</code> where the
days of the week are represented as integers (Monday is 0):</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Show days of the week</code>
<code class="n">dates</code><code class="o">.</code><code class="n">dt</code><code class="o">.</code><code class="n">weekday</code></pre>
<pre data-type="programlisting">0    3
1    6
2    1
dtype: int64</pre>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id1359">
<h2>Discussion</h2>
<p>Knowing the weekday can be helpful if, for instance, we wanted to
compare total sales on Sundays for the past three years. pandas makes
creating a feature vector containing weekday information easy.</p>
</div></section>
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1360">
<h2>See Also</h2>
<ul>
<li>
<p><a href="https://oreil.ly/3Au86">pandas Series datetimelike properties</a></p>
</li>
</ul>
</div></section>
</div></section>
<section data-pdf-bookmark="7.7 Creating a Lagged Feature" data-type="sect1"><div class="sect1" id="creating-a-lagged-feature">
<h1>7.7 Creating a Lagged Feature</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id185">
<h2>Problem</h2>
<p>You want to create a feature that is <a data-primary="dates and times (datetimes)" data-secondary="lagged feature" data-type="indexterm" id="id1361"/><a data-primary="lagged feature" data-type="indexterm" id="id1362"/>lagged <em>n</em> time
periods.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id186">
<h2>Solution</h2>
<p>Use the <a data-primary="shift method" data-type="indexterm" id="id1363"/>pandas <code>shift</code> method:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Load library</code>
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>

<code class="c1"># Create data frame</code>
<code class="n">dataframe</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">()</code>

<code class="c1"># Create data</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s2">"dates"</code><code class="p">]</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">date_range</code><code class="p">(</code><code class="s2">"1/1/2001"</code><code class="p">,</code> <code class="n">periods</code><code class="o">=</code><code class="mi">5</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s2">"D"</code><code class="p">)</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s2">"stock_price"</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mf">1.1</code><code class="p">,</code><code class="mf">2.2</code><code class="p">,</code><code class="mf">3.3</code><code class="p">,</code><code class="mf">4.4</code><code class="p">,</code><code class="mf">5.5</code><code class="p">]</code>

<code class="c1"># Lagged values by one row</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s2">"previous_days_stock_price"</code><code class="p">]</code> <code class="o">=</code> <code class="n">dataframe</code><code class="p">[</code><code class="s2">"stock_price"</code><code class="p">]</code><code class="o">.</code><code class="n">shift</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>

<code class="c1"># Show data frame</code>
<code class="n">dataframe</code></pre>
<table>
<thead>
<tr>
<th/>
<th>dates</th>
<th>stock_price</th>
<th>previous_days_stock_price</th>
</tr>
</thead>
<tbody>
<tr>
<th>0</th>
<td>2001-01-01</td>
<td>1.1</td>
<td>NaN</td>
</tr>
<tr>
<th>1</th>
<td>2001-01-02</td>
<td>2.2</td>
<td>1.1</td>
</tr>
<tr>
<th>2</th>
<td>2001-01-03</td>
<td>3.3</td>
<td>2.2</td>
</tr>
<tr>
<th>3</th>
<td>2001-01-04</td>
<td>4.4</td>
<td>3.3</td>
</tr>
<tr>
<th>4</th>
<td>2001-01-05</td>
<td>5.5</td>
<td>4.4</td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id1364">
<h2>Discussion</h2>
<p>Very often data is based on regularly spaced time periods (e.g., every
day, every hour, every three hours) and we are interested in using values in the past to make predictions (often called <em>lagging</em> a feature). For example, we might want to predict a stock’s price using
the price it was the day before. With pandas we can use <code>shift</code> to lag values by one row, creating a new feature containing past values.</p>
<p>In our solution, the first row for <code>previous_days_stock_price</code> is a
missing value because there is no previous <code>stock_price</code> value.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="7.8 Using Rolling Time Windows" data-type="sect1"><div class="sect1" id="using-rolling-time-windows">
<h1>7.8 Using Rolling Time Windows</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id187">
<h2>Problem</h2>
<p>Given time series data, you want to calculate a statistic for a
rolling<a data-primary="dates and times (datetimes)" data-secondary="rolling time windows" data-type="indexterm" id="ix_dt_time_roll_time"/><a data-primary="rolling time windows" data-type="indexterm" id="ix_roll_time_win"/> time.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id188">
<h2>Solution</h2>
<p>Use the <a data-primary="rolling method" data-type="indexterm" id="ix_roll_meth"/>pandas DataFrame <code>rolling</code> method:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Load library</code>
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>

<code class="c1"># Create datetimes</code>
<code class="n">time_index</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">date_range</code><code class="p">(</code><code class="s2">"01/01/2010"</code><code class="p">,</code> <code class="n">periods</code><code class="o">=</code><code class="mi">5</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s2">"M"</code><code class="p">)</code>

<code class="c1"># Create data frame, set index</code>
<code class="n">dataframe</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">index</code><code class="o">=</code><code class="n">time_index</code><code class="p">)</code>

<code class="c1"># Create feature</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s2">"Stock_Price"</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">]</code>

<code class="c1"># Calculate rolling mean</code>
<code class="n">dataframe</code><code class="o">.</code><code class="n">rolling</code><code class="p">(</code><code class="n">window</code><code class="o">=</code><code class="mi">2</code><code class="p">)</code><code class="o">.</code><code class="n">mean</code><code class="p">()</code></pre>
<table>
<thead>
<tr>
<th/>
<th>Stock_Price</th>
</tr>
</thead>
<tbody>
<tr>
<th>2010-01-31</th>
<td>NaN</td>
</tr>
<tr>
<th>2010-02-28</th>
<td>1.5</td>
</tr>
<tr>
<th>2010-03-31</th>
<td>2.5</td>
</tr>
<tr>
<th>2010-04-30</th>
<td>3.5</td>
</tr>
<tr>
<th>2010-05-31</th>
<td>4.5</td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id189">
<h2>Discussion</h2>
<p><em>Rolling</em> (also called <em>moving</em>) <em>time windows</em> are <a data-primary="moving time windows" data-type="indexterm" id="id1365"/>conceptually simple but
can be difficult to understand at first. Imagine we have monthly
observations for a stock’s price. It is often useful to have a time
window of a certain number of months and then move over the observations
calculating a statistic for all observations in the time window.</p>
<p>For example, if we have a time window of three months and we want a
rolling mean, we would calculate:</p>
<ol>
<li>
<p><code>mean(January, February, March)</code></p>
</li>
<li>
<p><code>mean(February, March, April)</code></p>
</li>
<li>
<p><code>mean(March, April, May)</code></p>
</li>
<li>
<p>etc.</p>
</li>
</ol>
<p>Another way to put it: our three-month time window “walks” over the
observations, calculating the window’s mean at each step.</p>
<p>The pandas <code>rolling</code> method allows us to specify the size of the window by using
<code>window</code> and then quickly calculate some common statistics, including
the max value (<code>max()</code>), mean value (<code>mean()</code>), count of values
(<code>count()</code>), and rolling correlation (<code>corr()</code>).</p>
<p>Rolling means are often used to smooth time series data because
using the mean of the entire time window dampens the effect of
short-term fluctuations.<a data-primary="" data-startref="ix_dt_time_roll_time" data-type="indexterm" id="id1366"/><a data-primary="" data-startref="ix_roll_meth" data-type="indexterm" id="id1367"/><a data-primary="" data-startref="ix_roll_time_win" data-type="indexterm" id="id1368"/></p>
</div></section>
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1369">
<h2>See Also</h2>
<ul>
<li>
<p><a href="https://oreil.ly/a5gZQ">pandas documentation: Rolling Windows</a></p>
</li>
<li>
<p><a href="https://oreil.ly/aoOSe">What Are Moving Average or Smoothing Techniques?</a></p>
</li>
</ul>
</div></section>
</div></section>
<section data-pdf-bookmark="7.9 Handling Missing Data in Time Series" data-type="sect1"><div class="sect1" id="handling-missing-data-in-time-series">
<h1>7.9 Handling Missing Data in Time Series</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id491">
<h2>Problem</h2>
<p>You have missing values in <a data-primary="missing data" data-secondary="time series" data-type="indexterm" id="ix_miss_data_time"/><a data-primary="dates and times (datetimes)" data-secondary="missing data in time series" data-type="indexterm" id="ix_dt_time_miss_data"/>time series data.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id190">
<h2>Solution</h2>
<p>In addition to the missing data strategies previously discussed, when we
have time series data we can use <a data-primary="interpolation of missing data" data-type="indexterm" id="id1370"/>interpolation to fill gaps caused by
missing values:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Load libraries</code>
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>

<code class="c1"># Create date</code>
<code class="n">time_index</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">date_range</code><code class="p">(</code><code class="s2">"01/01/2010"</code><code class="p">,</code> <code class="n">periods</code><code class="o">=</code><code class="mi">5</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s2">"M"</code><code class="p">)</code>

<code class="c1"># Create data frame, set index</code>
<code class="n">dataframe</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">index</code><code class="o">=</code><code class="n">time_index</code><code class="p">)</code>

<code class="c1"># Create feature with a gap of missing values</code>
<code class="n">dataframe</code><code class="p">[</code><code class="s2">"Sales"</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mf">1.0</code><code class="p">,</code><code class="mf">2.0</code><code class="p">,</code><code class="n">np</code><code class="o">.</code><code class="n">nan</code><code class="p">,</code><code class="n">np</code><code class="o">.</code><code class="n">nan</code><code class="p">,</code><code class="mf">5.0</code><code class="p">]</code>

<code class="c1"># Interpolate missing values</code>
<code class="n">dataframe</code><code class="o">.</code><code class="n">interpolate</code><code class="p">()</code></pre>
<table>
<thead>
<tr>
<th/>
<th>Sales</th>
</tr>
</thead>
<tbody>
<tr>
<th>2010-01-31</th>
<td>1.0</td>
</tr>
<tr>
<th>2010-02-28</th>
<td>2.0</td>
</tr>
<tr>
<th>2010-03-31</th>
<td>3.0</td>
</tr>
<tr>
<th>2010-04-30</th>
<td>4.0</td>
</tr>
<tr>
<th>2010-05-31</th>
<td>5.0</td>
</tr>
</tbody>
</table>
<p>Alternatively, we can <a data-primary="forward filling missing values" data-type="indexterm" id="id1371"/>replace missing values with the last known value
(i.e., forward filling):</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Forward fill</code>
<code class="n">dataframe</code><code class="o">.</code><code class="n">ffill</code><code class="p">()</code></pre>
<table>
<thead>
<tr>
<th/>
<th>Sales</th>
</tr>
</thead>
<tbody>
<tr>
<th>2010-01-31</th>
<td>1.0</td>
</tr>
<tr>
<th>2010-02-28</th>
<td>2.0</td>
</tr>
<tr>
<th>2010-03-31</th>
<td>2.0</td>
</tr>
<tr>
<th>2010-04-30</th>
<td>2.0</td>
</tr>
<tr>
<th>2010-05-31</th>
<td>5.0</td>
</tr>
</tbody>
</table>
<p>We can also <a data-primary="backfilling missing values" data-type="indexterm" id="id1372"/>replace missing values with the latest known value (i.e.,
backfilling):</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Backfill</code>
<code class="n">dataframe</code><code class="o">.</code><code class="n">bfill</code><code class="p">()</code></pre>
<table>
<thead>
<tr>
<th/>
<th>Sales</th>
</tr>
</thead>
<tbody>
<tr>
<th>2010-01-31</th>
<td>1.0</td>
</tr>
<tr>
<th>2010-02-28</th>
<td>2.0</td>
</tr>
<tr>
<th>2010-03-31</th>
<td>5.0</td>
</tr>
<tr>
<th>2010-04-30</th>
<td>5.0</td>
</tr>
<tr>
<th>2010-05-31</th>
<td>5.0</td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id191">
<h2>Discussion</h2>
<p><em>Interpolation</em> is a technique for filling gaps caused by missing values by, in effect, drawing a line or curve between the known values bordering the gap and using that line or curve to predict reasonable values. Interpolation can be particularly useful when the time intervals are constant, the data is not prone to noisy
fluctuations, and the gaps caused by missing values are small. For
example, in our solution, a gap of two missing values was bordered by
<code>2.0</code> and <code>5.0</code>. By fitting a line starting at <code>2.0</code> and ending at
<code>5.0</code>, we can make reasonable guesses for the two missing values between <code>3.0</code> and <code>4.0</code>.</p>
<p>If we believe the line between the two known points is nonlinear, we
can use 
<span class="keep-together"><code>interpolate</code>’s</span> <code>method</code> parameter to specify the interpolation method:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Interpolate missing values</code>
<code class="n">dataframe</code><code class="o">.</code><code class="n">interpolate</code><code class="p">(</code><code class="n">method</code><code class="o">=</code><code class="s2">"quadratic"</code><code class="p">)</code></pre>
<table>
<thead>
<tr>
<th/>
<th>Sales</th>
</tr>
</thead>
<tbody>
<tr>
<th>2010-01-31</th>
<td>1.000000</td>
</tr>
<tr>
<th>2010-02-28</th>
<td>2.000000</td>
</tr>
<tr>
<th>2010-03-31</th>
<td>3.059808</td>
</tr>
<tr>
<th>2010-04-30</th>
<td>4.038069</td>
</tr>
<tr>
<th>2010-05-31</th>
<td>5.000000</td>
</tr>
</tbody>
</table>
<p>Finally, we may have large gaps of missing values
but do not want to interpolate values across the entire gap. <a data-primary="limit method" data-type="indexterm" id="id1373"/>In these
cases we can use <code>limit</code> to restrict the number of interpolated values
and <code>limit_direction</code> to set whether to interpolate values forward from the last known value before the gap or vice versa:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Interpolate missing values</code>
<code class="n">dataframe</code><code class="o">.</code><code class="n">interpolate</code><code class="p">(</code><code class="n">limit</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code> <code class="n">limit_direction</code><code class="o">=</code><code class="s2">"forward"</code><code class="p">)</code></pre>
<table>
<thead>
<tr>
<th/>
<th>Sales</th>
</tr>
</thead>
<tbody>
<tr>
<th>2010-01-31</th>
<td>1.0</td>
</tr>
<tr>
<th>2010-02-28</th>
<td>2.0</td>
</tr>
<tr>
<th>2010-03-31</th>
<td>3.0</td>
</tr>
<tr>
<th>2010-04-30</th>
<td>NaN</td>
</tr>
<tr>
<th>2010-05-31</th>
<td>5.0</td>
</tr>
</tbody>
</table>
<p>Backfilling and forward filling are forms of naive
interpolation, where we draw a flat line from a known value and use it
to fill in missing values.<a data-primary="" data-startref="ix_dt_time_ch7" data-type="indexterm" id="id1374"/><a data-primary="" data-startref="ix_dt_time_miss_data" data-type="indexterm" id="id1375"/><a data-primary="" data-startref="ix_miss_data_time" data-type="indexterm" id="id1376"/> One (minor) advantage back filling and
forward filling have over interpolation is that they don’t require known values on <em>both</em> sides of missing values.</p>
</div></section>
</div></section>
</div></section></div></body></html>