<html><head></head><body><section data-pdf-bookmark="Chapter 7. Preprocess Data" data-type="chapter" epub:type="chapter"><div class="chapter" id="idm46066901741848">&#13;
<h1><span class="label">Chapter 7. </span>Preprocess Data</h1>&#13;
&#13;
&#13;
<p><a data-primary="preprocessing data" data-type="indexterm" id="ix_ch07-asciidoc0"/>This chapter will explore common preprocessing steps using this data:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">X2</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code>&#13;
<code class="gp">... </code>    <code class="p">{</code>&#13;
<code class="gp">... </code>        <code class="s">"a"</code><code class="p">:</code> <code class="nb">range</code><code class="p">(</code><code class="mi">5</code><code class="p">),</code>&#13;
<code class="gp">... </code>        <code class="s">"b"</code><code class="p">:</code> <code class="p">[</code><code class="o">-</code><code class="mi">100</code><code class="p">,</code> <code class="o">-</code><code class="mi">50</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">200</code><code class="p">,</code> <code class="mi">1000</code><code class="p">],</code>&#13;
<code class="gp">... </code>    <code class="p">}</code>&#13;
<code class="gp">... </code><code class="p">)</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">X2</code>&#13;
<code class="go">   a     b</code>&#13;
<code class="go">0  0  -100</code>&#13;
<code class="go">1  1   -50</code>&#13;
<code class="go">2  2     0</code>&#13;
<code class="go">3  3   200</code>&#13;
<code class="go">4  4  1000</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Standardize" data-type="sect1"><div class="sect1" id="idm46066899443672">&#13;
<h1>Standardize</h1>&#13;
&#13;
<p><a data-primary="preprocessing data" data-secondary="standardizing" data-type="indexterm" id="idm46066899295720"/><a data-primary="standardizing data" data-type="indexterm" id="idm46066899294520"/>Some algorithms, such as SVM, perform better when the data is <em>standardized</em>. Each&#13;
column should have a mean value of 0 and standard deviation of 1.&#13;
<a data-primary="sklearn" data-secondary="data standardization" data-type="indexterm" id="idm46066899293336"/>Sklearn provides a <code>.fit_transform</code> method that combines both <code>.fit</code> and&#13;
<code>.transform</code>:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="kn">from</code> <code class="nn">sklearn</code> <code class="kn">import</code> <code class="n">preprocessing</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">std</code> <code class="o">=</code> <code class="n">preprocessing</code><code class="o">.</code><code class="n">StandardScaler</code><code class="p">()</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">std</code><code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">X2</code><code class="p">)</code>&#13;
<code class="go">array([[-1.41421356, -0.75995002],</code>&#13;
<code class="go">       [-0.70710678, -0.63737744],</code>&#13;
<code class="go">       [ 0.        , -0.51480485],</code>&#13;
<code class="go">       [ 0.70710678, -0.02451452],</code>&#13;
<code class="go">       [ 1.41421356,  1.93664683]])</code></pre>&#13;
&#13;
<p>After fitting, there are various attributes we can inspect:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">std</code><code class="o">.</code><code class="n">scale_</code>&#13;
<code class="go">array([  1.41421356, 407.92156109])</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">std</code><code class="o">.</code><code class="n">mean_</code>&#13;
<code class="go">array([  2., 210.])</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">std</code><code class="o">.</code><code class="n">var_</code>&#13;
<code class="go">array([2.000e+00, 1.664e+05])</code></pre>&#13;
&#13;
<p><a data-primary="pandas" data-secondary="data standardization" data-type="indexterm" id="idm46066899387192"/>Here is a pandas version. Remember that you will need to track the original mean and standard deviation if you use this for preprocessing. Any sample that you will use to predict later will need to be standardized with those same values:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">X_std</code> <code class="o">=</code> <code class="p">(</code><code class="n">X2</code> <code class="o">-</code> <code class="n">X2</code><code class="o">.</code><code class="n">mean</code><code class="p">())</code> <code class="o">/</code> <code class="n">X2</code><code class="o">.</code><code class="n">std</code><code class="p">()</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">X_std</code>&#13;
<code class="go">          a         b</code>&#13;
<code class="go">0 -1.264911 -0.679720</code>&#13;
<code class="go">1 -0.632456 -0.570088</code>&#13;
<code class="go">2  0.000000 -0.460455</code>&#13;
<code class="go">3  0.632456 -0.021926</code>&#13;
<code class="go">4  1.264911  1.732190</code>&#13;
&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">X_std</code><code class="o">.</code><code class="n">mean</code><code class="p">()</code>&#13;
<code class="go">a    4.440892e-17</code>&#13;
<code class="go">b    0.000000e+00</code>&#13;
<code class="go">dtype: float64</code>&#13;
&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">X_std</code><code class="o">.</code><code class="n">std</code><code class="p">()</code>&#13;
<code class="go">a    1.0</code>&#13;
<code class="go">b    1.0</code>&#13;
<code class="go">dtype: float64</code></pre>&#13;
&#13;
<p class="pagebreak-before">The fastai library also implements this:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">X3</code> <code class="o">=</code> <code class="n">X2</code><code class="o">.</code><code class="n">copy</code><code class="p">()</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="kn">from</code> <code class="nn">fastai.structured</code> <code class="kn">import</code> <code class="n">scale_vars</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">scale_vars</code><code class="p">(</code><code class="n">X3</code><code class="p">,</code> <code class="n">mapper</code><code class="o">=</code><code class="bp">None</code><code class="p">)</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">X3</code><code class="o">.</code><code class="n">std</code><code class="p">()</code>&#13;
<code class="go">a    1.118034</code>&#13;
<code class="go">b    1.118034</code>&#13;
<code class="go">dtype: float64</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">X3</code><code class="o">.</code><code class="n">mean</code><code class="p">()</code>&#13;
<code class="go">a    0.000000e+00</code>&#13;
<code class="go">b    4.440892e-17</code>&#13;
<code class="go">dtype: float64</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Scale to Range" data-type="sect1"><div class="sect1" id="idm46066899181800">&#13;
<h1>Scale to Range</h1>&#13;
&#13;
<p><a data-primary="preprocessing data" data-secondary="scaling to range" data-type="indexterm" id="idm46066899104104"/><a data-primary="scaling data to range" data-type="indexterm" id="idm46066899103128"/>Scaling to range is translating data so it is between 0 and 1, inclusive.&#13;
Having the data bounded may be useful. However, if you have outliers,&#13;
<a data-primary="sklearn" data-secondary="scaling data to range" data-type="indexterm" id="idm46066899102168"/>you probably want to be careful using this:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="kn">from</code> <code class="nn">sklearn</code> <code class="kn">import</code> <code class="n">preprocessing</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">mms</code> <code class="o">=</code> <code class="n">preprocessing</code><code class="o">.</code><code class="n">MinMaxScaler</code><code class="p">()</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">mms</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">X2</code><code class="p">)</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">mms</code><code class="o">.</code><code class="n">transform</code><code class="p">(</code><code class="n">X2</code><code class="p">)</code>&#13;
<code class="go">array([[0.     , 0.     ],</code>&#13;
<code class="go">       [0.25   , 0.04545],</code>&#13;
<code class="go">       [0.5    , 0.09091],</code>&#13;
<code class="go">       [0.75   , 0.27273],</code>&#13;
<code class="go">       [1.     , 1.     ]])</code></pre>&#13;
&#13;
<p><a data-primary="pandas" data-secondary="scaling data to range" data-type="indexterm" id="idm46066899100104"/>Here is a pandas version:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="p">(</code><code class="n">X2</code> <code class="o">-</code> <code class="n">X2</code><code class="o">.</code><code class="n">min</code><code class="p">())</code> <code class="o">/</code> <code class="p">(</code><code class="n">X2</code><code class="o">.</code><code class="n">max</code><code class="p">()</code> <code class="o">-</code> <code class="n">X2</code><code class="o">.</code><code class="n">min</code><code class="p">())</code>&#13;
<code class="go">      a         b</code>&#13;
<code class="go">0  0.00  0.000000</code>&#13;
<code class="go">1  0.25  0.045455</code>&#13;
<code class="go">2  0.50  0.090909</code>&#13;
<code class="go">3  0.75  0.272727</code>&#13;
<code class="go">4  1.00  1.000000</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dummy Variables" data-type="sect1"><div class="sect1" id="idm46066899017784">&#13;
<h1>Dummy Variables</h1>&#13;
&#13;
<p><a data-primary="dummy variables" data-type="indexterm" id="idm46066899027768"/><a data-primary="pandas" data-secondary="dummy variable creation" data-type="indexterm" id="idm46066899027064"/><a data-primary="preprocessing data" data-secondary="dummy variables" data-type="indexterm" id="idm46066899026120"/>We can use pandas to create dummy variables from categorical data.&#13;
This is also referred to as one-hot encoding, or indicator encoding.&#13;
Dummy variables are especially useful if the data is nominal (unordered). The&#13;
<code>get_dummies</code> function in pandas creates multiple columns for a categorical column, each with a&#13;
1 or 0 if the original column had that value:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">X_cat</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code>&#13;
<code class="gp">... </code>    <code class="p">{</code>&#13;
<code class="gp">... </code>        <code class="s">"name"</code><code class="p">:</code> <code class="p">[</code><code class="s">"George"</code><code class="p">,</code> <code class="s">"Paul"</code><code class="p">],</code>&#13;
<code class="gp">... </code>        <code class="s">"inst"</code><code class="p">:</code> <code class="p">[</code><code class="s">"Bass"</code><code class="p">,</code> <code class="s">"Guitar"</code><code class="p">],</code>&#13;
<code class="gp">... </code>    <code class="p">}</code>&#13;
<code class="gp">... </code><code class="p">)</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">X_cat</code>&#13;
<code class="go">     name    inst</code>&#13;
<code class="go">0  George    Bass</code>&#13;
<code class="go">1    Paul  Guitar</code></pre>&#13;
&#13;
<p>Here is the pandas version. Note the <code>drop_first</code> option&#13;
can be used to eliminate a column (one of the dummy columns&#13;
is a linear combination of the other columns):</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">pd</code><code class="o">.</code><code class="n">get_dummies</code><code class="p">(</code><code class="n">X_cat</code><code class="p">,</code> <code class="n">drop_first</code><code class="o">=</code><code class="bp">True</code><code class="p">)</code>&#13;
<code class="go">   name_Paul  inst_Guitar</code>&#13;
<code class="go">0          0            0</code>&#13;
<code class="go">1          1            1</code></pre>&#13;
&#13;
<p><a data-primary="pyjanitor" data-secondary="splitting columns" data-type="indexterm" id="idm46066898918920"/>The pyjanitor library also has the ability to split columns with the&#13;
<code>expand_column</code> function:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">X_cat2</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code>&#13;
<code class="gp">... </code>    <code class="p">{</code>&#13;
<code class="gp">... </code>        <code class="s">"A"</code><code class="p">:</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="bp">None</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code>&#13;
<code class="gp">... </code>        <code class="s">"names"</code><code class="p">:</code> <code class="p">[</code>&#13;
<code class="gp">... </code>            <code class="s">"Fred,George"</code><code class="p">,</code>&#13;
<code class="gp">... </code>            <code class="s">"George"</code><code class="p">,</code>&#13;
<code class="gp">... </code>            <code class="s">"John,Paul"</code><code class="p">,</code>&#13;
<code class="gp">... </code>        <code class="p">],</code>&#13;
<code class="gp">... </code>    <code class="p">}</code>&#13;
<code class="gp">... </code><code class="p">)</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">jn</code><code class="o">.</code><code class="n">expand_column</code><code class="p">(</code><code class="n">X_cat2</code><code class="p">,</code> <code class="s">"names"</code><code class="p">,</code> <code class="n">sep</code><code class="o">=</code><code class="s">","</code><code class="p">)</code>&#13;
<code class="go">     A        names  Fred  George  John  Paul</code>&#13;
<code class="go">0  1.0  Fred,George     1       1     0     0</code>&#13;
<code class="go">1  NaN       George     0       1     0     0</code>&#13;
<code class="go">2  3.0    John,Paul     0       0     1     1</code></pre>&#13;
&#13;
<p>If we have high cardinality nominal data, we can use <em>label encoding</em>.&#13;
This is introduced in the next section.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Label Encoder" data-type="sect1"><div class="sect1" id="idm46066904186712">&#13;
<h1>Label Encoder</h1>&#13;
&#13;
<p><a data-primary="label encoding" data-type="indexterm" id="idm46066898789512"/><a data-primary="preprocessing data" data-secondary="label encoding" data-type="indexterm" id="idm46066898788808"/>An alternative to dummy variable encoding is label encoding. This will&#13;
take categorical data and assign each value a number. It is useful&#13;
for high cardinality data. This encoder imposes&#13;
ordinality, which may or may not be desired. It can take up less space&#13;
than one-hot encoding, and some (tree) algorithms can deal with this encoding.</p>&#13;
&#13;
<p>The label encoder can only deal with one column at a time:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="kn">from</code> <code class="nn">sklearn</code> <code class="kn">import</code> <code class="n">preprocessing</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">lab</code> <code class="o">=</code> <code class="n">preprocessing</code><code class="o">.</code><code class="n">LabelEncoder</code><code class="p">()</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">lab</code><code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">X_cat</code><code class="p">)</code>&#13;
<code class="go">array([0,1])</code></pre>&#13;
&#13;
<p>If you have encoded values, applying the <code>.inverse_transform</code> method decodes them:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">lab</code><code class="o">.</code><code class="n">inverse_transform</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">])</code>&#13;
<code class="go">array(['Guitar', 'Guitar', 'Bass'], dtype=object)</code></pre>&#13;
&#13;
<p><a data-primary="pandas" data-secondary="label encoding" data-type="indexterm" id="idm46066898777416"/>You can also use pandas to label encode. First, you convert the&#13;
column to a categorical column type, and then pull out the&#13;
numeric code from it.</p>&#13;
&#13;
<p>This code will create a new series of numeric data from a pandas&#13;
series. We use the <code>.as_ordered</code> method to ensure that the&#13;
category is ordered:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">X_cat</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code>&#13;
<code class="gp">... </code>    <code class="s">"category"</code>&#13;
<code class="gp">... </code><code class="p">)</code><code class="o">.</code><code class="n">cat</code><code class="o">.</code><code class="n">as_ordered</code><code class="p">()</code><code class="o">.</code><code class="n">cat</code><code class="o">.</code><code class="n">codes</code> <code class="o">+</code> <code class="mi">1</code>&#13;
<code class="go">0    1</code>&#13;
<code class="go">1    2</code>&#13;
<code class="go">dtype: int8</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Frequency Encoding" data-type="sect1"><div class="sect1" id="idm46066898765064">&#13;
<h1>Frequency Encoding</h1>&#13;
&#13;
<p><a data-primary="frequency encoding" data-type="indexterm" id="idm46066898678744"/><a data-primary="preprocessing data" data-secondary="frequency encoding" data-type="indexterm" id="idm46066898648248"/>Another option for handling high cardinality categorical data is to&#13;
<em>frequency encode</em> it. This means replacing the name of the category&#13;
with the count it had in the training data.&#13;
<a data-primary="pandas" data-secondary="frequency encoding" data-type="indexterm" id="idm46066898646680"/>We will use pandas to do this. First, we will use the pandas <code>.value_counts</code>&#13;
method to make a mapping (a pandas series that maps strings to counts).&#13;
With the mapping we can use the <code>.map</code> method to do the encoding:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">mapping</code> <code class="o">=</code> <code class="n">X_cat</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">value_counts</code><code class="p">()</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">X_cat</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">map</code><code class="p">(</code><code class="n">mapping</code><code class="p">)</code>&#13;
<code class="go">0    1</code>&#13;
<code class="go">1    1</code>&#13;
<code class="go">Name: name, dtype: int64</code></pre>&#13;
&#13;
<p>Make sure you store the training mapping so you can encode future&#13;
data with the same data.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Pulling Categories from Strings" data-type="sect1"><div class="sect1" id="idm46066898632984">&#13;
<h1>Pulling Categories from Strings</h1>&#13;
&#13;
<p><a data-primary="categories, pulling from strings" data-type="indexterm" id="ix_ch07-asciidoc1"/><a data-primary="preprocessing data" data-secondary="pulling categories from strings" data-type="indexterm" id="ix_ch07-asciidoc2"/><a data-primary="strings, pulling categories from" data-type="indexterm" id="ix_ch07-asciidoc3"/>One way to increase the accuracy of the Titanic model is to pull out titles&#13;
from the names. A quick hack to find the most common triples is to&#13;
use the <code>Counter</code> class:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="kn">from</code> <code class="nn">collections</code> <code class="kn">import</code> <code class="n">Counter</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">c</code> <code class="o">=</code> <code class="n">Counter</code><code class="p">()</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="k">def</code> <code class="nf">triples</code><code class="p">(</code><code class="n">val</code><code class="p">):</code>&#13;
<code class="gp">... </code>    <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">val</code><code class="p">)):</code>&#13;
<code class="gp">... </code>        <code class="n">c</code><code class="p">[</code><code class="n">val</code><code class="p">[</code><code class="n">i</code> <code class="p">:</code> <code class="n">i</code> <code class="o">+</code> <code class="mi">3</code><code class="p">]]</code> <code class="o">+=</code> <code class="mi">1</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">apply</code><code class="p">(</code><code class="n">triples</code><code class="p">)</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">c</code><code class="o">.</code><code class="n">most_common</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>&#13;
<code class="go">[(', M', 1282),</code>&#13;
<code class="go"> (' Mr', 954),</code>&#13;
<code class="go"> ('r. ', 830),</code>&#13;
<code class="go"> ('Mr.', 757),</code>&#13;
<code class="go"> ('s. ', 460),</code>&#13;
<code class="go"> ('n, ', 320),</code>&#13;
<code class="go"> (' Mi', 283),</code>&#13;
<code class="go"> ('iss', 261),</code>&#13;
<code class="go"> ('ss.', 261),</code>&#13;
<code class="go"> ('Mis', 260)]</code></pre>&#13;
&#13;
<p>We can see that “Mr.” and “Miss.” are very common.</p>&#13;
&#13;
<p><a data-primary="regular expressions" data-type="indexterm" id="idm46066898590216"/>Another option is to use a regular expression to pull out&#13;
the capital letter followed by lowercase letters and a period:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">extract</code><code class="p">(</code>&#13;
<code class="gp">... </code>    <code class="s">"([A-Za-z]+)\."</code><code class="p">,</code> <code class="n">expand</code><code class="o">=</code><code class="bp">False</code>&#13;
<code class="gp">... </code><code class="p">)</code><code class="o">.</code><code class="n">head</code><code class="p">()</code>&#13;
<code class="go">0      Miss</code>&#13;
<code class="go">1    Master</code>&#13;
<code class="go">2      Miss</code>&#13;
<code class="go">3        Mr</code>&#13;
<code class="go">4       Mrs</code>&#13;
<code class="go">Name: name, dtype: object</code></pre>&#13;
&#13;
<p>We can use <code>.value_counts</code> to see the frequency of these:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">extract</code><code class="p">(</code>&#13;
<code class="gp">... </code>    <code class="s">"([A-Za-z]+)\."</code><code class="p">,</code> <code class="n">expand</code><code class="o">=</code><code class="bp">False</code>&#13;
<code class="gp">... </code><code class="p">)</code><code class="o">.</code><code class="n">value_counts</code><code class="p">()</code>&#13;
<code class="go">Mr          757</code>&#13;
<code class="go">Miss        260</code>&#13;
<code class="go">Mrs         197</code>&#13;
<code class="go">Master       61</code>&#13;
<code class="go">Dr            8</code>&#13;
<code class="go">Rev           8</code>&#13;
<code class="go">Col           4</code>&#13;
<code class="go">Mlle          2</code>&#13;
<code class="go">Ms            2</code>&#13;
<code class="go">Major         2</code>&#13;
<code class="go">Dona          1</code>&#13;
<code class="go">Don           1</code>&#13;
<code class="go">Lady          1</code>&#13;
<code class="go">Countess      1</code>&#13;
<code class="go">Capt          1</code>&#13;
<code class="go">Sir           1</code>&#13;
<code class="go">Mme           1</code>&#13;
<code class="go">Jonkheer      1</code>&#13;
<code class="go">Name: name, dtype: int64</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>A complete discussion of regular expressions is beyond the scope of this book.&#13;
This expression captures a group with one or more alphabetic characters. This&#13;
group will be followed by a period.</p>&#13;
</div>&#13;
&#13;
<p>Using these manipulations and pandas, you can create dummy variables&#13;
or combine columns with low counts into other categories (or drop them).<a data-startref="ix_ch07-asciidoc3" data-type="indexterm" id="idm46066898368072"/><a data-startref="ix_ch07-asciidoc2" data-type="indexterm" id="idm46066898367432"/><a data-startref="ix_ch07-asciidoc1" data-type="indexterm" id="idm46066898366760"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other Categorical Encoding" data-type="sect1"><div class="sect1" id="idm46066898632392">&#13;
<h1>Other Categorical Encoding</h1>&#13;
&#13;
<p><a data-primary="categorical encoding" data-type="indexterm" id="idm46066898364552"/><a data-primary="preprocessing data" data-secondary="and categorical_encoding library" data-type="indexterm" id="idm46066898363848"/><a data-primary="preprocessing data" data-secondary="various categorical encoding approaches" data-type="indexterm" id="idm46066898362936"/><a data-primary="scikit-learn" data-secondary="categorical encoding" data-type="indexterm" id="idm46066898361976"/>The <a href="https://oreil.ly/JbxWG">categorical_encoding library</a> is a set of scikit-learn transformers used to convert categorical data into numeric data. A nice feature of this library is that it supports outputting pandas DataFrames (unlike scikit-learn, which transforms them into numpy arrays).</p>&#13;
&#13;
<p><a data-primary="hash encoder" data-type="indexterm" id="idm46066898359704"/>One algorithm implemented in the library is a hash encoder. This is useful if you&#13;
don’t know how many categories you have ahead of time or if you are using a bag&#13;
of words to represent text. This will hash the categorical columns into <code>n_components</code>. If you are using online learning (models that can be updated), this can be very useful:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="kn">import</code> <code class="nn">category_encoders</code> <code class="kn">as</code> <code class="nn">ce</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">he</code> <code class="o">=</code> <code class="n">ce</code><code class="o">.</code><code class="n">HashingEncoder</code><code class="p">(</code><code class="n">verbose</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">he</code><code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">X_cat</code><code class="p">)</code>&#13;
<code class="go">   col_0  col_1  col_2  col_3  col_4  col_5  col_6  col_7</code>&#13;
<code class="go">0      0      0      0      1      0      1      0      0</code>&#13;
<code class="go">1      0      2      0      0      0      0      0      0</code></pre>&#13;
&#13;
<p><a data-primary="ordinal encoder" data-type="indexterm" id="idm46066898337352"/>The ordinal encoder can convert categorical columns that have order to a&#13;
single column of numbers. Here we convert the size column to ordinal&#13;
numbers. If a value is missing from the mapping dictionary, the default&#13;
value of <code>-1</code> is used:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">size_df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code>&#13;
<code class="gp">... </code>    <code class="p">{</code>&#13;
<code class="gp">... </code>        <code class="s">"name"</code><code class="p">:</code> <code class="p">[</code><code class="s">"Fred"</code><code class="p">,</code> <code class="s">"John"</code><code class="p">,</code> <code class="s">"Matt"</code><code class="p">],</code>&#13;
<code class="gp">... </code>        <code class="s">"size"</code><code class="p">:</code> <code class="p">[</code><code class="s">"small"</code><code class="p">,</code> <code class="s">"med"</code><code class="p">,</code> <code class="s">"xxl"</code><code class="p">],</code>&#13;
<code class="gp">... </code>    <code class="p">}</code>&#13;
<code class="gp">... </code><code class="p">)</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">ore</code> <code class="o">=</code> <code class="n">ce</code><code class="o">.</code><code class="n">OrdinalEncoder</code><code class="p">(</code>&#13;
<code class="gp">... </code>    <code class="n">mapping</code><code class="o">=</code><code class="p">[</code>&#13;
<code class="gp">... </code>        <code class="p">{</code>&#13;
<code class="gp">... </code>            <code class="s">"col"</code><code class="p">:</code> <code class="s">"size"</code><code class="p">,</code>&#13;
<code class="gp">... </code>            <code class="s">"mapping"</code><code class="p">:</code> <code class="p">{</code>&#13;
<code class="gp">... </code>                <code class="s">"small"</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code>&#13;
<code class="gp">... </code>                <code class="s">"med"</code><code class="p">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
<code class="gp">... </code>                <code class="s">"lg"</code><code class="p">:</code> <code class="mi">3</code><code class="p">,</code>&#13;
<code class="gp">... </code>            <code class="p">},</code>&#13;
<code class="gp">... </code>        <code class="p">}</code>&#13;
<code class="gp">... </code>    <code class="p">]</code>&#13;
<code class="gp">... </code><code class="p">)</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">ore</code><code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">size_df</code><code class="p">)</code>&#13;
<code class="go">   name  size</code>&#13;
<code class="go">0  Fred   1.0</code>&#13;
<code class="go">1  John   2.0</code>&#13;
<code class="go">2  Matt  -1.0</code></pre>&#13;
&#13;
<p>This <a href="https://oreil.ly/JUtYh">reference</a> explains many of the algorithms of the categorical_encoding library.</p>&#13;
&#13;
<p><a data-primary="Bayesian encoders" data-type="indexterm" id="idm46066898296296"/>If you have high cardinality data (a large number of unique values) consider using one of the Bayesian encoders that output a single column per categorical column. These are <code>TargetEncoder</code>, <code>LeaveOneOutEncoder</code>, <code>WOEEncoder</code>, <code>JamesSteinEncoder</code>, and <code>MEstimateEncoder</code>.</p>&#13;
&#13;
<p>For example, to convert the Titanic survival column to a blend of posterior probability of the target and the prior probability given the title (categorical) information, use the following code:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="k">def</code> <code class="nf">get_title</code><code class="p">(</code><code class="n">df</code><code class="p">):</code>&#13;
<code class="gp">... </code>    <code class="k">return</code> <code class="n">df</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">extract</code><code class="p">(</code>&#13;
<code class="gp">... </code>        <code class="s">"([A-Za-z]+)\."</code><code class="p">,</code> <code class="n">expand</code><code class="o">=</code><code class="bp">False</code>&#13;
<code class="gp">... </code>    <code class="p">)</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">te</code> <code class="o">=</code> <code class="n">ce</code><code class="o">.</code><code class="n">TargetEncoder</code><code class="p">(</code><code class="n">cols</code><code class="o">=</code><code class="s">"Title"</code><code class="p">)</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">te</code><code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code>&#13;
<code class="gp">... </code>    <code class="n">df</code><code class="o">.</code><code class="n">assign</code><code class="p">(</code><code class="n">Title</code><code class="o">=</code><code class="n">get_title</code><code class="p">),</code> <code class="n">df</code><code class="o">.</code><code class="n">survived</code>&#13;
<code class="gp">... </code><code class="p">)[</code><code class="s">"Title"</code><code class="p">]</code><code class="o">.</code><code class="n">head</code><code class="p">()</code>&#13;
<code class="go">0    0.676923</code>&#13;
<code class="go">1    0.508197</code>&#13;
<code class="go">2    0.676923</code>&#13;
<code class="go">3    0.162483</code>&#13;
<code class="go">4    0.786802</code>&#13;
<code class="go">Name: Title, dtype: float64</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Date Feature Engineering" data-type="sect1"><div class="sect1" id="idm46066898365496">&#13;
<h1>Date Feature Engineering</h1>&#13;
&#13;
<p><a data-primary="date feature engineering" data-type="indexterm" id="idm46066898151992"/><a data-primary="fastai" data-type="indexterm" id="idm46066898045144"/><a data-primary="feature engineering" data-secondary="date feature engineering" data-type="indexterm" id="idm46066898044472"/><a data-primary="preprocessing data" data-secondary="date feature engineering" data-type="indexterm" id="idm46066898043512"/>The fastai library has an <code>add_datepart</code> function that will generate date&#13;
attribute columns based on a datetime column. This is useful as most&#13;
machine learning algorithms would not be able to infer this type of&#13;
signal from a numeric representation of a date:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="kn">from</code> <code class="nn">fastai.tabular.transform</code> <code class="kn">import</code> <code class="p">(</code>&#13;
<code class="gp">... </code>    <code class="n">add_datepart</code><code class="p">,</code>&#13;
<code class="gp">... </code><code class="p">)</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">dates</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code>&#13;
<code class="gp">... </code>    <code class="p">{</code>&#13;
<code class="gp">... </code>        <code class="s">"A"</code><code class="p">:</code> <code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code>&#13;
<code class="gp">... </code>            <code class="p">[</code><code class="s">"9/17/2001"</code><code class="p">,</code> <code class="s">"Jan 1, 2002"</code><code class="p">]</code>&#13;
<code class="gp">... </code>        <code class="p">)</code>&#13;
<code class="gp">... </code>    <code class="p">}</code>&#13;
<code class="gp">... </code><code class="p">)</code>&#13;
&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">add_datepart</code><code class="p">(</code><code class="n">dates</code><code class="p">,</code> <code class="s">"A"</code><code class="p">)</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">dates</code><code class="o">.</code><code class="n">T</code>&#13;
<code class="go">                            0           1</code>&#13;
<code class="go">AYear                    2001        2002</code>&#13;
<code class="go">AMonth                      9           1</code>&#13;
<code class="go">AWeek                      38           1</code>&#13;
<code class="go">ADay                       17           1</code>&#13;
<code class="go">ADayofweek                  0           1</code>&#13;
<code class="go">ADayofyear                260           1</code>&#13;
<code class="go">AIs_month_end           False       False</code>&#13;
<code class="go">AIs_month_start         False        True</code>&#13;
<code class="go">AIs_quarter_end         False       False</code>&#13;
<code class="go">AIs_quarter_start       False        True</code>&#13;
<code class="go">AIs_year_end            False       False</code>&#13;
<code class="go">AIs_year_start          False        True</code>&#13;
<code class="go">AElapsed           1000684800  1009843200</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p><code>add_datepart</code> mutates the DataFrame, which pandas can do, but normally&#13;
doesn’t!</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Add col_na Feature" data-type="sect1"><div class="sect1" id="idm46066897949656">&#13;
<h1>Add col_na Feature</h1>&#13;
&#13;
<p><a data-primary="col_na feature" data-type="indexterm" id="idm46066897948248"/><a data-primary="preprocessing data" data-secondary="col_na feature" data-type="indexterm" id="idm46066897947544"/>The fastai library used to have a function for creating a column to fill a&#13;
missing value (with the median) and indicate that a value was missing.&#13;
There might be some signal in knowing that a value was missing. Here is a copy of the function and an example using it:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="kn">from</code> <code class="nn">pandas.api.types</code> <code class="kn">import</code> <code class="n">is_numeric_dtype</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="k">def</code> <code class="nf">fix_missing</code><code class="p">(</code><code class="n">df</code><code class="p">,</code> <code class="n">col</code><code class="p">,</code> <code class="n">name</code><code class="p">,</code> <code class="n">na_dict</code><code class="p">):</code>&#13;
<code class="gp">... </code>    <code class="k">if</code> <code class="n">is_numeric_dtype</code><code class="p">(</code><code class="n">col</code><code class="p">):</code>&#13;
<code class="gp">... </code>        <code class="k">if</code> <code class="n">pd</code><code class="o">.</code><code class="n">isnull</code><code class="p">(</code><code class="n">col</code><code class="p">)</code><code class="o">.</code><code class="n">sum</code><code class="p">()</code> <code class="ow">or</code> <code class="p">(</code>&#13;
<code class="gp">... </code>            <code class="n">name</code> <code class="ow">in</code> <code class="n">na_dict</code>&#13;
<code class="gp">... </code>        <code class="p">):</code>&#13;
<code class="gp">... </code>            <code class="n">df</code><code class="p">[</code><code class="n">name</code> <code class="o">+</code> <code class="s">"_na"</code><code class="p">]</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">isnull</code><code class="p">(</code><code class="n">col</code><code class="p">)</code>&#13;
<code class="gp">... </code>            <code class="n">filler</code> <code class="o">=</code> <code class="p">(</code>&#13;
<code class="gp">... </code>                <code class="n">na_dict</code><code class="p">[</code><code class="n">name</code><code class="p">]</code>&#13;
<code class="gp">... </code>                <code class="k">if</code> <code class="n">name</code> <code class="ow">in</code> <code class="n">na_dict</code>&#13;
<code class="gp">... </code>                <code class="k">else</code> <code class="n">col</code><code class="o">.</code><code class="n">median</code><code class="p">()</code>&#13;
<code class="gp">... </code>            <code class="p">)</code>&#13;
<code class="gp">... </code>            <code class="n">df</code><code class="p">[</code><code class="n">name</code><code class="p">]</code> <code class="o">=</code> <code class="n">col</code><code class="o">.</code><code class="n">fillna</code><code class="p">(</code><code class="n">filler</code><code class="p">)</code>&#13;
<code class="gp">... </code>            <code class="n">na_dict</code><code class="p">[</code><code class="n">name</code><code class="p">]</code> <code class="o">=</code> <code class="n">filler</code>&#13;
<code class="gp">... </code>    <code class="k">return</code> <code class="n">na_dict</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">({</code><code class="s">"A"</code><code class="p">:</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="bp">None</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">100</code><code class="p">]})</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">fix_missing</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">data</code><code class="o">.</code><code class="n">A</code><code class="p">,</code> <code class="s">"A"</code><code class="p">,</code> <code class="p">{})</code>&#13;
<code class="go">{'A': 5.0}</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">data</code>&#13;
<code class="go">       A   A_na</code>&#13;
<code class="go">0    0.0  False</code>&#13;
<code class="go">1    5.0   True</code>&#13;
<code class="go">2    5.0  False</code>&#13;
<code class="go">3  100.0  False</code></pre>&#13;
&#13;
<p>Here is a pandas version:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">({</code><code class="s">"A"</code><code class="p">:</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="bp">None</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">100</code><code class="p">]})</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">data</code><code class="p">[</code><code class="s">"A_na"</code><code class="p">]</code> <code class="o">=</code> <code class="n">data</code><code class="o">.</code><code class="n">A</code><code class="o">.</code><code class="n">isnull</code><code class="p">()</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">data</code><code class="p">[</code><code class="s">"A"</code><code class="p">]</code> <code class="o">=</code> <code class="n">data</code><code class="o">.</code><code class="n">A</code><code class="o">.</code><code class="n">fillna</code><code class="p">(</code><code class="n">data</code><code class="o">.</code><code class="n">A</code><code class="o">.</code><code class="n">median</code><code class="p">())</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Manual Feature Engineering" data-type="sect1"><div class="sect1" id="idm46066897643656">&#13;
<h1>Manual Feature Engineering</h1>&#13;
&#13;
<p><a data-primary="feature engineering" data-secondary="manual" data-type="indexterm" id="idm46066897725816"/><a data-primary="manual feature engineering" data-type="indexterm" id="idm46066897724872"/><a data-primary="pandas" data-secondary="manual feature engineering" data-type="indexterm" id="idm46066897724232"/><a data-primary="preprocessing data" data-secondary="manual feature engineering" data-type="indexterm" id="idm46066897723320"/>We can use pandas to generate new features. For the Titanic dataset,&#13;
we can add aggregate cabin data (maximum age per cabin, mean age per cabin, etc.).&#13;
To get aggregate data per&#13;
cabin and merge it back in, use the pandas <code>.groupby</code> method to create the data.&#13;
Then align it back to the original data using the <code>.merge</code> method:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="n">agg</code> <code class="o">=</code> <code class="p">(</code>&#13;
<code class="gp">... </code>    <code class="n">df</code><code class="o">.</code><code class="n">groupby</code><code class="p">(</code><code class="s">"cabin"</code><code class="p">)</code>&#13;
<code class="gp">... </code>    <code class="o">.</code><code class="n">agg</code><code class="p">(</code><code class="s">"min,max,mean,sum"</code><code class="o">.</code><code class="n">split</code><code class="p">(</code><code class="s">","</code><code class="p">))</code>&#13;
<code class="gp">... </code>    <code class="o">.</code><code class="n">reset_index</code><code class="p">()</code>&#13;
<code class="gp">... </code><code class="p">)</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">agg</code><code class="o">.</code><code class="n">columns</code> <code class="o">=</code> <code class="p">[</code>&#13;
<code class="gp">... </code>    <code class="s">"_"</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">c</code><code class="p">)</code><code class="o">.</code><code class="n">strip</code><code class="p">(</code><code class="s">"_"</code><code class="p">)</code>&#13;
<code class="gp">... </code>    <code class="k">for</code> <code class="n">c</code> <code class="ow">in</code> <code class="n">agg</code><code class="o">.</code><code class="n">columns</code><code class="o">.</code><code class="n">values</code>&#13;
<code class="gp">... </code><code class="p">]</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">agg_df</code> <code class="o">=</code> <code class="n">df</code><code class="o">.</code><code class="n">merge</code><code class="p">(</code><code class="n">agg</code><code class="p">,</code> <code class="n">on</code><code class="o">=</code><code class="s">"cabin"</code><code class="p">)</code></pre>&#13;
&#13;
<p>If you wanted to sum up “good” or “bad” columns, you could create a new&#13;
column that is the sum of the aggregated columns (or another mathematical&#13;
operation). This is somewhat of an art and also requires understanding&#13;
the data.<a data-startref="ix_ch07-asciidoc0" data-type="indexterm" id="idm46066897719208"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>