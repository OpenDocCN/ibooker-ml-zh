- en: Chapter 7\. Handling Dates and Times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 7.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dates and times (datetimes), such as the time of a particular sale or the date
    of a public health statistic, are frequently encountered during preprocessing
    for machine learning. *Longitudinal data* (or *time series data*) is data that’s
    collected repeatedly for the same variables over points in time. In this chapter,
    we will build a toolbox of strategies for handling time series data, including
    tackling time zones and creating lagged time features. Specifically, we will focus
    on the time series tools in the pandas library, which centralizes the functionality
    of many other general libraries such as `datetime`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 Converting Strings to Dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given a vector of strings representing dates and times, you want to transform
    them into time series data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use pandas’ `to_datetime` with the format of the date and/or time specified
    in the `format` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We might also want to add an argument to the `errors` parameter to handle problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If `errors="coerce"`, then any problem that occurs will not raise an error (the
    default behavior) but instead will set the value causing the error to `NaT` (a
    missing value). This allows you to deal with outliers by filling them with null
    values, as opposed to troubleshooting errors for individual records in the data.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When dates and times come as strings, we need to convert them into a data type
    Python can understand. While there are a number of Python tools for converting
    strings to datetimes, following our use of pandas in other recipes we can use
    `to_datetime` to conduct the transformation. One obstacle to using strings to
    represent dates and times is that the format of the strings can vary significantly
    between data sources. For example, one vector of dates might represent March 23,
    2015 as “03-23-15” while another might use “3|23|2015”. We can use the `format`
    parameter to specify the exact format of the string. Here are some common date
    and time formatting codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%Y` | Full year | `2001` |'
  prefs: []
  type: TYPE_TB
- en: '| `%m` | Month w/ zero padding | `04` |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | Day of the month w/ zero padding | `09` |'
  prefs: []
  type: TYPE_TB
- en: '| `%I` | Hour (12hr clock) w/ zero padding | `02` |'
  prefs: []
  type: TYPE_TB
- en: '| `%p` | AM or PM | `AM` |'
  prefs: []
  type: TYPE_TB
- en: '| `%M` | Minute w/ zero padding | `05` |'
  prefs: []
  type: TYPE_TB
- en: '| `%S` | Second w/ zero padding | `09` |'
  prefs: []
  type: TYPE_TB
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Python strftime Cheatsheet (complete list of Python string time codes)](https://oreil.ly/4-tN6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.2 Handling Time Zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have time series data and want to add or change time zone information.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unless specified, pandas objects have no time zone. We can add a time zone
    using `tz` during creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add a time zone to a previously created datetime using `tz_localize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We also can convert to a different time zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the pandas `Series` objects can apply `tz_localize` and `tz_convert`
    to every element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'pandas supports two sets of strings representing timezones; however, I suggest
    using the `pytz` library strings. We can see all the strings used to represent
    time zones by importing `all_timezones`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 7.3 Selecting Dates and Times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a vector of dates and you want to select one or more.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use two boolean conditions as the start and end dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|  | date |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 8762 | 2002-01-01 02:00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| 8763 | 2002-01-01 03:00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| 8764 | 2002-01-01 04:00:00 |'
  prefs: []
  type: TYPE_TB
- en: 'Alternatively, we can set the date column as the DataFrame’s index and then
    slice using `loc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '| date | date |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2002-01-01 01:00:00 | 2002-01-01 01:00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| 2002-01-01 02:00:00 | 2002-01-01 02:00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| 2002-01-01 03:00:00 | 2002-01-01 03:00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| 2002-01-01 04:00:00 | 2002-01-01 04:00:00 |'
  prefs: []
  type: TYPE_TB
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether we use boolean conditions or index slicing is situation dependent. If
    we wanted to do some complex time series manipulation, it might be worth the overhead
    of setting the date column as the index of the DataFrame, but if we wanted to
    do some simple data wrangling, the boolean conditions might be easier.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Breaking Up Date Data into Multiple Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a column of dates and times and you want to create features for year,
    month, day, hour, and minute.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the time properties in pandas `Series.dt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|  | date | year | month | day | hour | minute |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 2001-01-07 | 2001 | 1 | 7 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2001-01-14 | 2001 | 1 | 14 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2001-01-21 | 2001 | 1 | 21 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes it can be useful to break up a column of dates into components. For
    example, we might want a feature that includes just the year of the observation
    or we might want to consider only the month of some observations so we can compare
    them regardless of year.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5 Calculating the Difference Between Dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have two datetime features and want to calculate the time between them for
    each observation.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Subtract the two date features using pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Often we will want to remove the `days` output and keep only the numerical
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when the feature we want is the change (delta) between two points
    in time. For example, we might have the dates a customer checks in and checks
    out of a hotel, but the feature we want is the duration of the customer’s stay.
    pandas makes this calculation easy using the `TimeDelta` data type.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[pandas documentation: Time Deltas](https://oreil.ly/fbgp-)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.6 Encoding Days of the Week
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a vector of dates and want to know the day of the week for each date.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the pandas `Series.dt` method `day_name()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want the output to be a numerical value and therefore more usable as
    a machine learning feature, we can use `weekday` where the days of the week are
    represented as integers (Monday is 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Knowing the weekday can be helpful if, for instance, we wanted to compare total
    sales on Sundays for the past three years. pandas makes creating a feature vector
    containing weekday information easy.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[pandas Series datetimelike properties](https://oreil.ly/3Au86)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.7 Creating a Lagged Feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a feature that is lagged *n* time periods.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the pandas `shift` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|  | dates | stock_price | previous_days_stock_price |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 2001-01-01 | 1.1 | NaN |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2001-01-02 | 2.2 | 1.1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2001-01-03 | 3.3 | 2.2 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 2001-01-04 | 4.4 | 3.3 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 2001-01-05 | 5.5 | 4.4 |'
  prefs: []
  type: TYPE_TB
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Very often data is based on regularly spaced time periods (e.g., every day,
    every hour, every three hours) and we are interested in using values in the past
    to make predictions (often called *lagging* a feature). For example, we might
    want to predict a stock’s price using the price it was the day before. With pandas
    we can use `shift` to lag values by one row, creating a new feature containing
    past values.
  prefs: []
  type: TYPE_NORMAL
- en: In our solution, the first row for `previous_days_stock_price` is a missing
    value because there is no previous `stock_price` value.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8 Using Rolling Time Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given time series data, you want to calculate a statistic for a rolling time.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the pandas DataFrame `rolling` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|  | Stock_Price |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-01-31 | NaN |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-02-28 | 1.5 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-03-31 | 2.5 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-04-30 | 3.5 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-05-31 | 4.5 |'
  prefs: []
  type: TYPE_TB
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Rolling* (also called *moving*) *time windows* are conceptually simple but
    can be difficult to understand at first. Imagine we have monthly observations
    for a stock’s price. It is often useful to have a time window of a certain number
    of months and then move over the observations calculating a statistic for all
    observations in the time window.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have a time window of three months and we want a rolling
    mean, we would calculate:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mean(January, February, March)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mean(February, March, April)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mean(March, April, May)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: etc.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another way to put it: our three-month time window “walks” over the observations,
    calculating the window’s mean at each step.'
  prefs: []
  type: TYPE_NORMAL
- en: The pandas `rolling` method allows us to specify the size of the window by using
    `window` and then quickly calculate some common statistics, including the max
    value (`max()`), mean value (`mean()`), count of values (`count()`), and rolling
    correlation (`corr()`).
  prefs: []
  type: TYPE_NORMAL
- en: Rolling means are often used to smooth time series data because using the mean
    of the entire time window dampens the effect of short-term fluctuations.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[pandas documentation: Rolling Windows](https://oreil.ly/a5gZQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What Are Moving Average or Smoothing Techniques?](https://oreil.ly/aoOSe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.9 Handling Missing Data in Time Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have missing values in time series data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the missing data strategies previously discussed, when we have
    time series data we can use interpolation to fill gaps caused by missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|  | Sales |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-01-31 | 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-02-28 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-03-31 | 3.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-04-30 | 4.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-05-31 | 5.0 |'
  prefs: []
  type: TYPE_TB
- en: 'Alternatively, we can replace missing values with the last known value (i.e.,
    forward filling):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|  | Sales |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-01-31 | 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-02-28 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-03-31 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-04-30 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-05-31 | 5.0 |'
  prefs: []
  type: TYPE_TB
- en: 'We can also replace missing values with the latest known value (i.e., backfilling):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|  | Sales |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-01-31 | 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-02-28 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-03-31 | 5.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-04-30 | 5.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-05-31 | 5.0 |'
  prefs: []
  type: TYPE_TB
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Interpolation* is a technique for filling gaps caused by missing values by,
    in effect, drawing a line or curve between the known values bordering the gap
    and using that line or curve to predict reasonable values. Interpolation can be
    particularly useful when the time intervals are constant, the data is not prone
    to noisy fluctuations, and the gaps caused by missing values are small. For example,
    in our solution, a gap of two missing values was bordered by `2.0` and `5.0`.
    By fitting a line starting at `2.0` and ending at `5.0`, we can make reasonable
    guesses for the two missing values between `3.0` and `4.0`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we believe the line between the two known points is nonlinear, we can use
    `interpolate`’s `method` parameter to specify the interpolation method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|  | Sales |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-01-31 | 1.000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-02-28 | 2.000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-03-31 | 3.059808 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-04-30 | 4.038069 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-05-31 | 5.000000 |'
  prefs: []
  type: TYPE_TB
- en: 'Finally, we may have large gaps of missing values but do not want to interpolate
    values across the entire gap. In these cases we can use `limit` to restrict the
    number of interpolated values and `limit_direction` to set whether to interpolate
    values forward from the last known value before the gap or vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|  | Sales |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-01-31 | 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-02-28 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-03-31 | 3.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-04-30 | NaN |'
  prefs: []
  type: TYPE_TB
- en: '| 2010-05-31 | 5.0 |'
  prefs: []
  type: TYPE_TB
- en: Backfilling and forward filling are forms of naive interpolation, where we draw
    a flat line from a known value and use it to fill in missing values. One (minor)
    advantage back filling and forward filling have over interpolation is that they
    don’t require known values on *both* sides of missing values.
  prefs: []
  type: TYPE_NORMAL
