- en: Chapter 6\. Group Segmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html#Chapter_5), we introduced clustering, an unsupervised
    learning approach to identify the underlying structure in data and grouping points
    based on similarity. These groups (known as clusters) should be homogeneous and
    distinct. In other words, the members within a group should be very similar to
    each other and very distinct from members of any other group.
  prefs: []
  type: TYPE_NORMAL
- en: From an applied perspective, the ability to segment members into groups based
    on similarity and without any guidance from labels is very powerful. For example,
    such a technique could be applied to find different consumer groups for online
    retailers, customizing a marketing strategy for each of the distinct groups (i.e.,
    budget shoppers, fashionistas, sneakerheads, techies, audiophiles, etc.). Group
    segmentation could improve targeting in online advertising and improve recommendations
    in recommender systems for movies, music, news, social networking, dating, etc.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build an applied unsupervised learning solution using
    the clustering algorithms from the previous chapter—more specifically, we will
    perform group segmentation.
  prefs: []
  type: TYPE_NORMAL
- en: Lending Club Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we will use loan data from Lending Club, a US peer-to-peer
    lending company. Borrowers on the platform can borrow between $1,000 to $40,000
    in the form of unsecured personal loans, for a term of either three or five years.
  prefs: []
  type: TYPE_NORMAL
- en: Investors can browse the loan applications and choose to finance the loans based
    on the credit history of the borrower, the amount of the loan, the loan grade,
    and the purpose of the loan. Investors earn money through interest paid on the
    loans, and Lending Club makes money from loan origination fees and service charges.
  prefs: []
  type: TYPE_NORMAL
- en: The loan data we will use is from 2007–2011 and is publicly available on [the
    Lending Club website](http://bit.ly/2FYN2zX). A data dictionary is also available
    there.
  prefs: []
  type: TYPE_NORMAL
- en: Data Preparation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like in previous chapters, let’s prepare the environment to work with the Lending
    Club data.
  prefs: []
  type: TYPE_NORMAL
- en: Load libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let’s load the necessary libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Explore the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let’s load the loan data and designate which of the columns to keep:'
  prefs: []
  type: TYPE_NORMAL
- en: The original loan data file has 144 columns, but most of these columns are empty
    and are of little value to us. Therefore, we will designate a subset of the columns
    that are mostly populated and are worth using in our clustering application. These
    fields include attributes of the loan such as the amount requested, the amount
    funded, the term, the interest rate, the loan grade, etc., and attributes of the
    borrower such as employment length, home ownership status, annual income, address,
    and purpose for borrowing money.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also explore the data a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The data has 42,542 loans and 37 features (42,542, 37).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-1](#first_few_rows_of_the_loan_data) previews the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1\. First few rows of the loan data
  prefs: []
  type: TYPE_NORMAL
- en: '|  | loan_amnt | funded_amnt | funded_amnt_inv | term | int_rate | instsallment
    | grade |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 5000.0 | 5000.0 | 4975.0 | 36 months | 10.65% | 162.87 | B |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2500.0 | 2500.0 | 2500.0 | 60 months | 15.27% | 59.83 | C |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2400.0 | 2400.0 | 2400.0 | 35 months | 15.96% | 84.33 | C |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 10000.0 | 10000.0 | 10000.0 | 36 months | 13.49% | 339.31 | C |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 3000.0 | 3000.0 | 3000.0 | 60 months | 12.69% | 67.79 | B |'
  prefs: []
  type: TYPE_TB
- en: Transform String Format to Numerical Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A few of the features—the term of the loan, the interest rate of the loan,
    employment length of the borrower, and revolving utilization of the borrower—need
    to be altered from a string format to a numerical format. Let’s perform the transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For our clustering application, we will consider just the numerical features
    and ignore all the categorical features because nonnumerical features cannot be
    handled by our clustering algorithms in their current form.
  prefs: []
  type: TYPE_NORMAL
- en: Impute Missing Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s find these numerical features and count the number of NaNs per feature.
    We will then impute these NaNs with either the mean of the feature or, in some
    cases, just the number zero, depending on what the feature represents from a business
    perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the number of NaNs by feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Most features have a few NaNs, and some—such as the months since last delinquency
    and last change in record—have many.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s impute these so we do not have to deal with any NaNs during the clustering
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let’s recalculate the NaNs to make sure no NaNs remain.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now safe. All the NaNs have been filled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Engineer Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s also engineer a few more features to add to the existing feature set.
    These new features are mostly ratios between loan amount, revolving balance, payments,
    and the borrower’s annual income:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Select Final Set of Features and Perform Scaling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will generate the training dataframe and scale the features for our
    clustering algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Designate Labels for Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clustering is an unsupervised learning approach, and, therefore, labels are
    not used. However, to judge the goodness of our clustering algorithm at finding
    distinct and homogeneous groups of borrowers in this Lending Club dataset, we
    will use the loan grade as a proxy label.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loan grade is currently graded by letters, with loan grade “A” as the most
    credit-worthy and safe and loan grade “G” as the least:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some NaNs in the loan grade. We will fill these with a value of “Z”
    and then use the `LabelEncoder` from Scikit-Learn to transform the letter grades
    to numerical grades. To remain consistent, we will load these labels into a “y_train”
    Python series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Table 6-2\. Numerical versus letter loan grades
  prefs: []
  type: TYPE_NORMAL
- en: '|  | grade | grade |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | B |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2 | C |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 | C |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 2 | C |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 1 | B |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 0 | A |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 2 | C |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 4 | E |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 5 | F |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 1 | B |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 2 | C |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 1 | B |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 2 | C |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | 1 | B |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | 1 | B |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | 3 | D |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | 2 | C |'
  prefs: []
  type: TYPE_TB
- en: As you can see from [Table 6-2](#numerical_versus_letter_loan_grades), all the
    “A” grades have been transformed into 0, the “B” grades into 1, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also check whether grade “A” loans generally have the lowest interest
    rate charged, since they are the least risky and other loans are charged progressively
    higher rates of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 6-3](#grade_versus_interest_rate) confirms this. Higher letter grade
    loans have higher interest rates.^([1](ch06.html#idm140637543541600))'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-3\. Grade versus interest rate
  prefs: []
  type: TYPE_NORMAL
- en: '| grade | int_rate |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0.0 | 734.270844 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0 | 1101.420857 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.0 | 1349.988902 |'
  prefs: []
  type: TYPE_TB
- en: '| 3.0 | 1557.714927 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.0 | 1737.676783 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0 | 1926.530361 |'
  prefs: []
  type: TYPE_TB
- en: '| 6.0 | 2045.125000 |'
  prefs: []
  type: TYPE_TB
- en: '| 7.0 | 1216.501563 |'
  prefs: []
  type: TYPE_TB
- en: Goodness of the Clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now the data is ready. We have an X_train with all of our 34 numerical features,
    and a y_train with the numerical loan grades, which we use only to validate the
    results, not to train with the algorithm as you would do in a supervised machine
    learning problem. Before we build our first clustering application, let’s introduce
    a function to analyze the goodness of the clusters we generate using the clustering
    algorithms. Specifically, we will use the concept of homogeneity to assess the
    goodness of each cluster.
  prefs: []
  type: TYPE_NORMAL
- en: If the clustering algorithm does a good job separating the borrowers in the
    Lending Club dataset, each cluster should have borrowers that are very similar
    to each other and dissimilar to those in other groups. Presumably, borrowers that
    are similar to each other and grouped together should have similar credit profiles—in
    other words, their creditworthiness should be similar.
  prefs: []
  type: TYPE_NORMAL
- en: If this is the case (and with real-world problems, a lot of these assumptions
    are only partially true), borrowers in a given cluster should generally be assigned
    the same numerical loan grade, which we will validate using the numerical loan
    grades we set aside in y_train. The higher the percentage of borrowers that have
    the most frequently occurring numerical loan grade in each and every cluster,
    the better the clustering application.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider a cluster with one hundred borrowers. If 30 borrowers
    have a numerical loan grade of 0, 25 borrowers have a loan grade of 1, 20 borrowers
    have a loan grade of 2, and the remaining borrowers have loan grades ranging from
    3 to 7, we would say that the cluster has a 30% accuracy, given that the most
    frequently occuring loan grade for that cluster applies to just 30% of the borrowers
    in that cluster.
  prefs: []
  type: TYPE_NORMAL
- en: If we did not have a y_train with the numerical loan grades to validate the
    goodness of the clusters, we could use an alternative approach. We could sample
    a few borrowers in each cluster, determine the numerical loan grade for them by
    hand, and determine if we would give roughly the same numerical loan grade to
    those borrowers. If yes, then the cluster is a good cluster—it is homogeneous
    enough that we would give roughly the same numerical loan grade to the borrowers
    we sampled. If not, then the cluster is not good enough—the borrowers are too
    heterogeneous, and we should try to improve the solution using more data, a different
    clustering algorithm, etc.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t have to sample and manually hand-label the borrowers, though, given
    that we have the numerical loan grades already, but this is important to keep
    in mind in case you do not have labels for your particular problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function to analyze the clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: k-Means Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first clustering application using this Lending Club dataset will use *k*-means,
    which we introduced in [Chapter 5](ch05.html#Chapter_5). Recall that in *k*-means
    clustering, we need to specify the desired clusters *k*, and the algorithm will
    assign each borrower to exactly one of these *k* clusters.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm will accomplish this by minimizing the within-cluster variation,
    which is also known as inertia, such that the sum of the within-cluster variations
    across all *k* clusters is as small as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of specifying just one value of *k*, we will run an experiment where
    we set *k* from a range of 10 to 30 and plot the results of the accuracy measure
    we defined in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on which *k* measure performs best, we can build the pipeline for clustering
    using this best-performing *k* measure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 6-1](#overall_accuracy_for_different_ks_using_k_means) displays the
    plot of the results.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overall Accuracy for Different Ks using K-means](assets/hulp_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Overall accuracy for different k measures using k-means
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As we can see, the accuracy is best around 30 clusters and levels out there
    at approximately 39%. In other words, for any given cluster, the most-frequently
    occurring label for that cluster applies to approximately 39% of the borrowers.
    The remaining 61% of the borrowers have labels that are not the most-frequently
    occurring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code displays the accuracy by cluster for *k* = 30:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The accuracy varies quite a bit cluster to cluster. Some clusters are much more
    homogeneous than others. For example, cluster 7 has an accuracy of 76%, while
    cluster 12 has an accuracy of just 21%. This is a starting point to build a clustering
    application to automatically assign new borrowers that apply for a Lending Club
    loan into a preexisting group based on how similar they are to other borrowers.
    Based on this clustering, it is possible to automatically assign a tentative numerical
    loan grade to the new borrower, which will be correct approximately 39% of the
    time.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the best possible solution, and we should consider whether acquiring
    more data, performing more feature engineering and selection, selecting different
    parameters for the *k*-means algorithm, or changing to a different clustering
    algorithm will improve the results. It is possible that we do not have enough
    data to meaningfully separate the borrowers into distinct and homogeneous groups
    more than we have already; if this is the case, more data and more feature engineering
    and selection are required. Or, it could be that, for the limited data that we
    have, *k*-means is not best for performing this separation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s switch to hierarchical clustering to see if our results improve.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical Clustering Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall that in hierarchical clustering we do not need to precommit to a particular
    number of clusters. Instead, we can choose how many clusters we would like after
    the hierarchical clustering has finished running. Hierarchical clustering will
    build a dendrogram, which can be conceptually viewed as an upside-down tree. The
    leaves at the very bottom are the individual borrowers that apply for loans on
    Lending Club.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical clustering joins the borrowers together as we move vertically up
    the upside-down tree based on how similar they are to each other. The borrowers
    that are most similar to each other are joined sooner, while borrowers that are
    not as similar are joined much later. Eventually, all the borrowers are joined
    together at the very top—the trunk—of the upside-down tree.
  prefs: []
  type: TYPE_NORMAL
- en: From a business perspective, this clustering process is clearly very powerful.
    If we are able to find borrowers that are similar to each other and group them
    together, we can more efficiently assign creditworthiness ratings to them. We
    can also have specific strategies for distinct groups of borrowers and better
    manage them from a relationship perspective, providing better overall client service.
  prefs: []
  type: TYPE_NORMAL
- en: Once the hierarchical clustering algorithm finishes running, we can determine
    where we want to cut the tree. The lower we cut, the more groups of borrowers
    we are left with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first train the hierarchical clustering algorithm like we did in [Chapter 5](ch05.html#Chapter_5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 6-4](#bottom_most_leaves_of_hierarchical_clustering) shows what the
    output dataframe looks like. The first few rows are the initial linkages of the
    bottom-most borrowers.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-4\. Bottom-most leaves of hierarchical clustering
  prefs: []
  type: TYPE_NORMAL
- en: '|  | clusterOne | clusterTwo | distance | newClusterSize |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 39786.0 | 39787.0 | 0.000000e+00 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 39788.0 | 42542.0 | 0.000000e+00 | 3.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 42538.0 | 42539.0 | 0.000000e+00 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 42540.0 | 42544.0 | 0.000000e+00 | 3.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 42541.0 | 42545.0 | 3.399350e-17 | 4.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 42543.0 | 42546.0 | 5.139334e-17 | 7.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 33251.0 | 33261.0 | 1.561313e-01 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 42512.0 | 42535.0 | 3.342654e-01 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 42219.0 | 42316.0 | 3.368231e-01 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 6112.0 | 21928.0 | 3.384368e-01 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 33248.0 | 33275.0 | 3.583819e-01 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 33253.0 | 33265.0 | 3.595331e-01 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 33258.0 | 42552.0 | 3.719377e-01 | 3.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | 20430.0 | 23299.0 | 3.757307e-01 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | 5455.0 | 32845.0 | 3.828709e-01 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | 28615.0 | 30306.0 | 3.900294e-01 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | 9056 .0 | 9769.0 | 3.967378e-01 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | 11162.0 | 13857.0 | 3.991124e-01 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | 33270.0 | 42548.0 | 3.995620e-01 | 3.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | 17422.0 | 17986.0 | 4.061704e-01 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: Recall that the last few rows represent the top of the upside-down tree, and
    all 42,541 borrowers are combined together eventually (see [Table 6-5](#topmost_leaves_of_hierarchical_clustering)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-5\. Top-most leaves of hierarchical clustering
  prefs: []
  type: TYPE_NORMAL
- en: '|  | clusterOne | clusterTwo | distance | newClusterSize |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 42521 | 85038.0 | 85043.0 | 132.715723 | 3969.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42522 | 85051.0 | 85052.0 | 141.386569 | 2899.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42532 | 85026.0 | 85027.0 | 146.976703 | 2351.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42524 | 85048.0 | 85049.0 | 152.660192 | 5691.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42525 | 85036.0 | 85059.0 | 153.512281 | 5956.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42526 | 85033.0 | 85044.0 | 160.825959 | 2203.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42527 | 85055.0 | 85061.0 | 163.701428 | 668.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42528 | 85062.0 | 85066.0 | 168.199295 | 6897.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42529 | 85054.0 | 85060.0 | 168.924039 | 9414.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42530 | 85028.0 | 85064.0 | 185.215769 | 3118.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42531 | 85067.0 | 85071.0 | 187.832588 | 15370.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42532 | 85056.0 | 85073.0 | 203.212147 | 17995.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42533 | 85057.0 | 85063.0 | 205.285993 | 9221.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42534 | 85068.0 | 85072.0 | 207.902660 | 5321.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42535 | 85069.0 | 85075.0 | 236.754581 | 9889.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42536 | 85070.0 | 85077.0 | 298.587755 | 16786.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42537 | 85058.0 | 85078.0 | 309.946867 | 16875.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42538 | 85074.0 | 85079.0 | 375.698458 | 34870.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42539 | 85065.0 | 85080.0 | 400.711547 | 37221.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 42504 | 85076.0 | 85081.0 | 644.047472 | 42542.0 |'
  prefs: []
  type: TYPE_TB
- en: Now, let’s cut the dendrogram so that we are left with a manageable number of
    clusters. This is set based on the `distance_threshold`. Based on trial and error,
    a `distance_threshold` of 100 results in 32 clusters, which is what we will use
    for this example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of distinct clusters given the distance threshold we picked is 32:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the overall accuracy of hierarchical clustering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The overall accuracy is approximately 37%, a bit worse than with *k*-means clustering.
    That being said, hierarchical clustering works differently than *k*-means and
    may group some borrowers more accurately than *k*-means, while *k*-means may group
    other borrowers more accurately than hierarchical clustering.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, the two clustering algorithms may complement each other, and
    this is worth exploring by ensembling the two and assessing the ensemble’s results
    compared to the results of either standalone solution.^([2](ch06.html#idm140637542559056))
    As with *k*-means, the accuracy varies quite a bit across the clusters. Some clusters
    are much more homogeneous than others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: HDBSCAN Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let’s turn to HDBSCAN and apply this clustering algorithm to group similar
    borrowers in this Lending Club dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that HDBSCAN will group borrowers together based on how closely packed
    together their attributes are in a high-dimensional space. Unlike *k*-means or
    hierarchical clustering, not all the borrowers will be grouped. Some borrowers
    that are very distinct from other groups of borrowers may remain ungrouped. These
    are outlier borrowers and are worth investigating to see if there is a good business
    reason they are dissimilar from other borrowers. It may be possible to automatically
    assign numerical loan grades to some groups of borrowers but other borrowers—those
    that are dissimilar—may require a more nuanced credit-scoring approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how well HDBSCAN does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the overall accuracy for HDBSCAN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As seen here, the overall accuracy is approximately 32%, worse than that of
    either *k*-means or hierarchical clustering.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-6](#cluster_results_for_hdbscan_chap_six) shows the various clusters
    and their cluster sizes.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-6\. Cluster results for HDBSCAN
  prefs: []
  type: TYPE_NORMAL
- en: '|  | cluster | clusterCount |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | –1 | 32708 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 7 | 4070 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 | 3668 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1 | 1096 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 4 | 773 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 0 | 120 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 6 | 49 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 3 | 38 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 5 | 20 |'
  prefs: []
  type: TYPE_TB
- en: 32,708 of the borrowers are in cluster -1, which means they are ungrouped.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the accuracy by cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Among these clusters, the accuracy ranges from 28% to 59%.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built an unsupervised clustering application based on borrowers
    that applied for unsecured personal loans on Lending Club from 2007-2011\. The
    applications were based on *k*-means, hierarchical clustering, and hierarchical
    DBSCAN. *k*-means performed the best, scoring an approximately 39% overall accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: While these applications performed okay, they can be improved quite a bit. You
    should experiment with these algorithms to improve the solution from here.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the unsupervised learning using Scikit-Learn portion of the book.
    Next, we will explore neural network-based forms of unsupervised learning using
    TensorFlow and Keras. We will start with representation learning and autoencoders
    in [Chapter 7](ch07.html#Chapter_7).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch06.html#idm140637543541600-marker)) We can ignore grade “7,” which corresponds
    to loan grade “Z.” These are the loans with missing loan grades that we had to
    fill in.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch06.html#idm140637542559056-marker)) We explored ensembling in [Chapter 2](ch02.html#Chapter_2).
    Refer back to [“Ensembles”](ch02.html#ensembles) if you need a refresher.
  prefs: []
  type: TYPE_NORMAL
