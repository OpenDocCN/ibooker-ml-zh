<html><head></head><body><section data-pdf-bookmark="Chapter 13. Putting It All Together: Experimenting and Ranking" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch:spotify">&#13;
<h1><span class="label">Chapter 13. </span>Putting It All Together: <span class="keep-together">Experimenting and Ranking</span></h1>&#13;
&#13;
&#13;
<p>In the last few chapters, we have covered many aspects of ranking, including various kinds of loss functions as well as metrics for measuring the performance of ranking systems. In this chapter, we will show an example of a ranking loss and ranking metric on the <a href="https://oreil.ly/j3nvH">Spotify Million Playlist dataset</a>.</p>&#13;
&#13;
<p>This chapter encourages a lot more experimentation and is more open-ended than the previous ones, whose goal was to introduce concepts and infrastructure. This chapter, on the other hand, is written to encourage you to roll up your sleeves and engage directly with loss&#13;
functions and writing metrics.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Experimentation Tips" data-type="sect1"><div class="sect1" id="id224">&#13;
<h1>Experimentation Tips</h1>&#13;
&#13;
<p>Before<a data-primary="ranking training" data-secondary="experimentation tips" data-type="indexterm" id="RTexptips13"/><a data-primary="experimentation" data-secondary="tips for" data-type="indexterm" id="expcode13"/><a data-primary="code" data-secondary="experimental code" data-type="indexterm" id="Cexper13"/> we begin digging into the data and modeling, let’s cover some practices that will make your life easier when doing a lot of experimentation and rapid iteration. These are general guidelines that have made our experimentation faster. As a result, we’re able to rapidly iterate toward solutions that help us reach our objectives.</p>&#13;
&#13;
<p>Experimental code is different from engineering code in that the code is written to explore ideas, not for robustness. The goal is to achieve maximum velocity while not sacrificing too much in terms of code quality. So you should think about whether a piece of code should be thoroughly tested or whether this isn’t necessary because the code is present only to test a hypothesis and then it will be thrown away. With that in mind, here are some tips. Keep in mind that these tips are the opinion of the authors, developed over time, and are not hard-and-fast rules, just some flavored opinions that some may disagree with.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Keep It Simple" data-type="sect2"><div class="sect2" id="id318">&#13;
<h2>Keep It Simple</h2>&#13;
&#13;
<p>In terms of the overall structure of research code, it’s best to keep it as simple as possible. Try not to overthink too much in terms of inheritance and reusability during the early stages of the lifecycle of exploration. At the start of a project, we usually don’t know what it needs yet, so the preference should be keeping the code easily readable and simple for debugging. That means you don’t have to focus too much on code reuse because at the early stage of a project, many code changes will occur while the structure of the model, data ingestion, and interaction of various parts of a system are being worked out. When the uncertainties have been worked out, then you can rewrite the code into a more robust form, but refactoring too early actually slows velocity.</p>&#13;
&#13;
<p>A general rule of thumb is that it is OK to copy code three times and then refactor out into a library the fourth time, because you’ll have seen enough use cases to justify the reuse of code. If refactoring is done too early, you might not have seen enough use cases of a piece of code to cover the possible use cases that it might need to handle.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Debug Print Statements" data-type="sect2"><div class="sect2" id="id147">&#13;
<h2>Debug Print Statements</h2>&#13;
&#13;
<p>If<a data-primary="logging" data-secondary="debugging print statements" data-type="indexterm" id="id1062"/><a data-primary="data processing" data-secondary="debugging print statements" data-type="indexterm" id="id1063"/> you’ve read a number of ML research papers, you may expect your data to be fairly clean and orderly at the start of a project. However, real-world data can be messy, with missing fields and unexpected values. Having lots of print functions allows you to print and visually inspect a sample of the data and also helps in crafting the input data pipelines and transformations to feed the model. Also, printing sample outputs of the model is useful in making sure the output is as expected.</p>&#13;
&#13;
<p>The most important places to include logging are the input and output schema between components of your system; these help you understand where reality may be deviating from expectations. Later, you can make unit tests to ensure that refactoring of the model doesn’t break anything, but the unit tests can wait for when the model architecture is stable. A good rule of thumb is to add unit tests when you want to refactor code or reuse or optimize the code to preserve functionality or when the code is stable and you want to ensure that it doesn’t break a build. Another good use case of adding print statements is when you inevitably run into<a data-primary="not-a-number (NaN) errors" data-type="indexterm" id="id1064"/><a data-primary="NaN (not-a-number) errors" data-type="indexterm" id="id1065"/> not-a-number (NaN) errors when running training code.</p>&#13;
&#13;
<p class="less_space pagebreak-before">In<a data-primary="JAX framework" data-secondary="NaN debugging" data-type="indexterm" id="id1066"/> JAX, you can enable NaN debugging by using the following lines:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">jax</code> <code class="kn">import</code> <code class="n">config</code>&#13;
<code class="n">config</code><code class="o">.</code><code class="n">update</code><code class="p">(</code><code class="s2">"jax_debug_nans"</code><code class="p">,</code> <code class="kc">True</code><code class="p">)</code>&#13;
&#13;
<code class="nd">@jax</code><code class="o">.</code><code class="n">jit</code>&#13;
<code class="k">def</code> <code class="nf">f</code><code class="p">(</code><code class="n">x</code><code class="p">):</code>&#13;
  <code class="n">jax</code><code class="o">.</code><code class="n">debug</code><code class="o">.</code><code class="n">print</code><code class="p">(</code><code class="s2">"Debugging </code><code class="si">{x}</code><code class="s2">"</code><code class="p">,</code> <code class="n">x</code><code class="o">=</code><code class="n">x</code><code class="p">)</code></pre>&#13;
&#13;
<p>The debug NaNs configuration setting will rerun a jitted function if it finds any NaNs, and the debug print function will print the value of the tensors even inside a JIT. A regular print won’t work inside a JIT because it is not a compilable command and is skipped over during the tracing, so you have to use the debug print function instead, which does work inside a JIT.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defer Optimization" data-type="sect2"><div class="sect2" id="id225">&#13;
<h2>Defer Optimization</h2>&#13;
&#13;
<p>In research code, there is a lot of temptation to<a data-primary="optimization" data-secondary="deferring" data-type="indexterm" id="id1067"/> optimize early—in particular, focusing on the implementation of your models or system to ensure they’re efficient computationally or the code is elegant. However,  research code is written for higher velocity in experimentation, not execution speed.</p>&#13;
&#13;
<p>Our suggestion is do not optimize too early unless it hinders research velocity. One reason for this is the system might not be complete, so optimizing one part might not make sense if another part of the system is even slower and is the actual bottleneck. Another reason is the part that you are optimizing might not make it to the final model, so all the optimization work might go to waste if the code is refactored away anyway.</p>&#13;
&#13;
<p>Finally, optimization might actually hinder the ability to modify or inject newer design choices in terms of architecture or functionality. Optimized code tends to have certain choices that were made that fit the current structure of the data flow but might not be amenable to further changes. For example, in the code for this chapter, one possible optimization choice would have been to batch together playlists of the same size so that the code might be able to run in larger batches. However, at this point of the experimentation, that optimization would have been premature and distracting because it might make the metrics code more complicated. Our gentle advice is to defer optimization until after the bulk of experimentation has been done and the architecture, loss functions, and metrics have been chosen and settled upon.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Keep Track of Changes" data-type="sect2"><div class="sect2" id="id148">&#13;
<h2>Keep Track of Changes</h2>&#13;
&#13;
<p>In research code, too many variables are probably at play for you to change them one at a time to see their effects. This problem is particularly noticeable with larger datasets that require a lot of runs to determine which change causes which effects. So, in general, fixing a number of parameters and changing the code bit by bit is still a good idea so that you can keep track of the change that causes the most improvement. Parameters have to be tracked, but so do the code changes.</p>&#13;
&#13;
<p>One way to keep track of changes is through services such as<a data-primary="Weights &amp; Biases" data-type="indexterm" id="id1068"/> Weights &amp; Biases that we discussed in <a data-type="xref" href="ch05.html#ch:pinterest-content">Chapter 5</a>. Keeping track of the exact code that led to a change and the parameters is a good idea so that experiments can be reproduced and analyzed. Especially with research code that changes so frequently and is sometimes not checked in, you have to be diligent in keeping a copy of the code that produced a run somewhere, and MLOps tools allow you to track code and hyperparameters.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Use Feature Engineering" data-type="sect2"><div class="sect2" id="id149">&#13;
<h2>Use Feature Engineering</h2>&#13;
&#13;
<p>Unlike<a data-primary="feature augmentation/engineering" data-type="indexterm" id="id1069"/> in academic papers, most applied research is interested in a good outcome rather than a theoretically beautiful result. We’re not  shackled by purist views that the model has to learn everything about the data by itself. Instead, we’re pragmatic and concerned about good outcomes.</p>&#13;
&#13;
<p>We should not discard practices like feature engineering, especially when we have little data or are crunched for time and need decent results fast. Using feature engineering means that if you know whether a handcrafted feature is correlated positively or negatively with an outcome like the ranking of an item, then by all means add these engineered features to the data. An example in recommender systems is having an attribute of the item being scored that matches something in the user’s profile. So, if an item has the same artist or album in the user’s playlist, we can return a Boolean True; otherwise, we return False. This extra feature simply helps the model converge faster, and the model can still use other latent features such as embeddings to compensate if the hand-engineered features don’t do so well.</p>&#13;
&#13;
<p>It is generally a good practice to ablate the hand-engineered features once in a while. To do this, hold back an experiment without some features to see if those features have become obsolete over time or if they still benefit the business metrics.</p>&#13;
<div data-type="tip"><h1>Ablation</h1>&#13;
<p><em>Ablation</em> in<a data-primary="ablation" data-type="indexterm" id="id1070"/> ML applications is the practice of measuring the change in performance of a model when a particular feature is removed. In computer vision applications, ablation often refers to blocking part of the image or view field to see how it impacts the model’s ability to identify or segment data. In other kinds of ML, it can mean strategically removing certain features.</p>&#13;
&#13;
<p>One<a data-primary="zero-ablation" data-type="indexterm" id="id1071"/> gotcha with ablation is what to replace the feature with. Simply <em>zeroing out</em> the feature can significantly skew the output of the model. This is called <em>zero-ablation</em>, and can force the model to treat that feature out of distribution, which yields less believable outcomes. Instead, some advocate for mean-ablation, or taking the average or most common value of that feature. This allows the model to see much more expected values, and reduce these risks.</p>&#13;
&#13;
<p>However, this fails to consider the most important aspects of the kinds of models we’ve been working on—latent high-order interactions. One of the authors has investigated a deeper approach to ablation called<a data-primary="causal scrubbing" data-type="indexterm" id="id1072"/> <em>causal scrubbing</em>, in which you fix the ablation value to be sampled from the posterior distribution produced by other feature values, i.e., a value that “makes sense” with the rest of the values the model will see at that time.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understand Metrics Versus Business Metrics" data-type="sect2"><div class="sect2" id="id150">&#13;
<h2>Understand Metrics Versus Business Metrics</h2>&#13;
&#13;
<p>Sometimes, as ML practitioners, we obsess<a data-primary="ranking metrics" data-secondary="versus business metrics" data-secondary-sortas="business metrics" data-type="indexterm" id="id1073"/><a data-primary="business metrics" data-type="indexterm" id="id1074"/><a data-primary="metrics" data-secondary="business metrics" data-type="indexterm" id="id1075"/> over the best possible metrics our models can achieve. However, we should temper that enthusiasm as the best ML metric might not totally represent the business interests at hand. Furthermore, other systems that contain business logic might sit on top of our models and modify the output. As a result, it is best not to obsess too heavily over ML metrics and to do proper A/B tests that contain business metrics instead since that’s the main measure of a good outcome with ML.</p>&#13;
&#13;
<p>The best possible circumstance is to find a loss function that aligns well or predicts the relevant business metric. This, unfortunately, is often not easy to find, especially when the business metrics are nuanced or have competing priorities.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Perform Rapid Iteration" data-type="sect2"><div class="sect2" id="id151">&#13;
<h2>Perform Rapid Iteration</h2>&#13;
&#13;
<p>Don’t<a data-primary="rapid iteration" data-type="indexterm" id="id1076"/><a data-primary="iteration, rapid" data-type="indexterm" id="id1077"/> be afraid to look at results of runs that are rather short. There’s no need to do a full pass over the data at the beginning, when you are figuring out the interaction between a model architecture and the data. It’s OK to do some rapid runs with minor tweaks to see how they change the metrics over a short number of time steps. In the Spotify Million Playlist dataset, we tweaked the model architecture by using 100,000 playlists before doing longer runs. Sometimes the changes can be so dramatic that the effects can be seen immediately, even at the first test-set evaluation.<a data-primary="" data-startref="RTexptips13" data-type="indexterm" id="id1078"/><a data-primary="" data-startref="expcode13" data-type="indexterm" id="id1079"/><a data-primary="" data-startref="Cexper13" data-type="indexterm" id="id1080"/></p>&#13;
&#13;
<p>Now that we have the basics of experimental research coding covered, let’s hop over to the data and code and play a bit with modeling music recommendations.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Spotify Million Playlist Dataset" data-type="sect1"><div class="sect1" id="id152">&#13;
<h1>Spotify Million Playlist Dataset</h1>&#13;
&#13;
<p>The<a data-primary="ranking training" data-secondary="Spotify playlist example" data-type="indexterm" id="RTspotify13"/><a data-primary="Spotify playlist example" data-secondary="code and documentation for" data-type="indexterm" id="id1081"/><a data-primary="code" data-secondary="obtaining and using code examples" data-type="indexterm" id="id1082"/> code for this section can be found in <a href="https://github.com/BBischof/ESRecsys/tree/main/spotify">this book’s GitHub repo</a>. The documentation for the data can be found at <a href="https://oreil.ly/eVA7f">Spotify Million Playlist Dataset Challenge</a>.</p>&#13;
&#13;
<p>The first thing we should do is take a look at the data:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">less<code class="w"> </code>data/spotify_million_playlist_dataset/data/mpd.slice.0-999.json<code class="w"/></pre>&#13;
&#13;
<p>That should produce the following output:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"info"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"generated_on"</code><code class="p">:</code><code class="w"> </code><code class="s2">"2017-12-03 08:41:42.057563"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"slice"</code><code class="p">:</code><code class="w"> </code><code class="s2">"0-999"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"version"</code><code class="p">:</code><code class="w"> </code><code class="s2">"v1"</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"playlists"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">"name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Throwbacks"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">"collaborative"</code><code class="p">:</code><code class="w"> </code><code class="s2">"false"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">"pid"</code><code class="p">:</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">"modified_at"</code><code class="p">:</code><code class="w"> </code><code class="mi">1493424000</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">"num_tracks"</code><code class="p">:</code><code class="w"> </code><code class="mi">52</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">"num_albums"</code><code class="p">:</code><code class="w"> </code><code class="mi">47</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">"num_followers"</code><code class="p">:</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">"tracks"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>&#13;
<code class="w">                </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">                    </code><code class="nt">"pos"</code><code class="p">:</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">                    </code><code class="nt">"artist_name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Missy Elliott"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">                    </code><code class="nt">"track_uri"</code><code class="p">:</code><code class="w"> </code><code class="s2">"spotify:track:0UaMYEvWZi0ZqiDOoHU3YI"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">                    </code><code class="nt">"artist_uri"</code><code class="p">:</code><code class="w"> </code><code class="s2">"spotify:artist:2wIVse2owClT7go1WT98tk"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">                    </code><code class="nt">"track_name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Lose Control (feat. Ciara &amp; Fat Man Scoop)"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">                    </code><code class="nt">"album_uri"</code><code class="p">:</code><code class="w"> </code><code class="s2">"spotify:album:6vV5UrXcfyQD1wu4Qo2I9K"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">                    </code><code class="nt">"duration_ms"</code><code class="p">:</code><code class="w"> </code><code class="mi">226863</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">                    </code><code class="nt">"album_name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"The Cookbook"</code><code class="w"/>&#13;
<code class="w">                </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">     </code><code class="p">}</code><code class="w"/>&#13;
<code class="w"> </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>When<a data-primary="Spotify playlist example" data-secondary="selecting features" data-type="indexterm" id="SPEfeatures13"/> encountering a new dataset, it is always important to look at it and plan which features to use to generate recommendations for the data.&#13;
One possible goal of the Spotify Million Playlist Dataset Challenge is to see if the next tracks in a playlist can be predicted from the first five tracks in the playlist.</p>&#13;
&#13;
<p>In this case, several features might be useful for the task. We have track, artist, and album universal resource identifiers (URIs), which are unique identifiers for tracks, artists, and albums, respectively. And we have artist and album names and names of playlists. The dataset also includes numerical features like duration of a track and the number of followers in a playlist. Intuitively, the number of followers of a playlist should not affect the ordering of tracks in a playlist, so you might want to look for better features before using these possibly uninformative ones.&#13;
Looking at the overall statistics of features, you can also obtain a lot of insight:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">less<code class="w"> </code>data/spotify_million_playlist_dataset/stats.txt<code class="w"/>&#13;
number<code class="w"> </code>of<code class="w"> </code>playlists<code class="w"> </code><code class="m">1000000</code><code class="w"/>&#13;
number<code class="w"> </code>of<code class="w"> </code>tracks<code class="w"> </code><code class="m">66346428</code><code class="w"/>&#13;
number<code class="w"> </code>of<code class="w"> </code>unique<code class="w"> </code>tracks<code class="w"> </code><code class="m">2262292</code><code class="w"/>&#13;
number<code class="w"> </code>of<code class="w"> </code>unique<code class="w"> </code>albums<code class="w"> </code><code class="m">734684</code><code class="w"/>&#13;
number<code class="w"> </code>of<code class="w"> </code>unique<code class="w"> </code>artists<code class="w"> </code><code class="m">295860</code><code class="w"/>&#13;
number<code class="w"> </code>of<code class="w"> </code>unique<code class="w"> </code>titles<code class="w"> </code><code class="m">92944</code><code class="w"/>&#13;
number<code class="w"> </code>of<code class="w"> </code>playlists<code class="w"> </code>with<code class="w"> </code>descriptions<code class="w"> </code><code class="m">18760</code><code class="w"/>&#13;
number<code class="w"> </code>of<code class="w"> </code>unique<code class="w"> </code>normalized<code class="w"> </code>titles<code class="w"> </code><code class="m">17381</code><code class="w"/>&#13;
avg<code class="w"> </code>playlist<code class="w"> </code>length<code class="w"> </code><code class="m">66</code>.346428<code class="w"/>&#13;
&#13;
top<code class="w"> </code>playlist<code class="w"> </code>titles<code class="w"/>&#13;
<code class="w">  </code><code class="m">10000</code><code class="w"> </code>country<code class="w"/>&#13;
<code class="w">  </code><code class="m">10000</code><code class="w"> </code>chill<code class="w"/>&#13;
<code class="w">   </code><code class="m">8493</code><code class="w"> </code>rap<code class="w"/>&#13;
<code class="w">   </code><code class="m">8481</code><code class="w"> </code>workout<code class="w"/>&#13;
<code class="w">   </code><code class="m">8146</code><code class="w"> </code>oldies<code class="w"/>&#13;
<code class="w">   </code><code class="m">8015</code><code class="w"> </code>christmas<code class="w"/>&#13;
<code class="w">   </code><code class="m">6848</code><code class="w"> </code>rock<code class="w"/>&#13;
<code class="w">   </code><code class="m">6157</code><code class="w"> </code>party<code class="w"/>&#13;
<code class="w">   </code><code class="m">5883</code><code class="w"> </code>throwback<code class="w"/>&#13;
<code class="w">   </code><code class="m">5063</code><code class="w"> </code>jams<code class="w"/>&#13;
<code class="w">   </code><code class="m">5052</code><code class="w"> </code>worship<code class="w"/>&#13;
<code class="w">   </code><code class="m">4907</code><code class="w"> </code>summer<code class="w"/>&#13;
<code class="w">   </code><code class="m">4677</code><code class="w"> </code>feels<code class="w"/>&#13;
<code class="w">   </code><code class="m">4612</code><code class="w"> </code>new<code class="w"/>&#13;
<code class="w">   </code><code class="m">4186</code><code class="w"> </code>disney<code class="w"/>&#13;
<code class="w">   </code><code class="m">4124</code><code class="w"> </code>lit<code class="w"/>&#13;
<code class="w">   </code><code class="m">4030</code><code class="w"> </code>throwbacks<code class="w"/></pre>&#13;
&#13;
<p>First of all, notice that the number of tracks is more than the number of playlists. This implies that quite a few tracks might have very little training data. So the <code>track_uri</code> might not be a feature that generalizes very well. On the other hand, the <code>album_uri</code> and <code>artist_uri</code> would generalize because they would occur multiple times in different playlists. For the sake of code clarity, we will mostly work with the <code>album_uri</code> and <code>artist_uri</code> as the features that represent a track.</p>&#13;
&#13;
<p>In previous “Putting It All Together” chapters, we demonstrated the use of content-based features or text token-based features that may be used instead, but direct embedding features are the clearest for demonstrating ranking. In a real-world application, embedding features and content-based features may be concatenated together to form a feature that generalizes better for recommendation ranking. For the purposes of this chapter, we will represent a track as the tuple of (<code>track_id</code>, <code>album_id</code>, <code>artist_id</code>), where the ID is an integer representing the URI. We will build dictionaries that map from the URI to the integer ID in the next section.<a data-primary="" data-startref="SPEfeatures13" data-type="indexterm" id="id1083"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Building URI Dictionaries" data-type="sect2"><div class="sect2" id="id226">&#13;
<h2>Building URI Dictionaries</h2>&#13;
&#13;
<p>Similar <a data-primary="Spotify playlist example" data-secondary="building URI dictionaries" data-type="indexterm" id="id1084"/> to <a data-type="xref" href="ch08.html#ch:wikipedia-e2e">Chapter 8</a>, we will first start by constructing a dictionary for all the URIs. This dictionary allows us to represent the text URI as an integer for faster processing on the JAX side, as we can easily look up embeddings from integers as opposed to arbitrary URI strings.</p>&#13;
&#13;
<p>Here is the code for <em>make_dictionary.py</em>:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code> <code class="nn">glob</code>&#13;
<code class="kn">import</code> <code class="nn">json</code>&#13;
<code class="kn">import</code> <code class="nn">os</code>&#13;
<code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Any</code><code class="p">,</code> <code class="n">Dict</code><code class="p">,</code> <code class="n">Tuple</code>&#13;
&#13;
<code class="kn">from</code> <code class="nn">absl</code> <code class="kn">import</code> <code class="n">app</code>&#13;
<code class="kn">from</code> <code class="nn">absl</code> <code class="kn">import</code> <code class="n">flags</code>&#13;
<code class="kn">from</code> <code class="nn">absl</code> <code class="kn">import</code> <code class="n">logging</code>&#13;
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>&#13;
<code class="kn">import</code> <code class="nn">tensorflow</code> <code class="k">as</code> <code class="nn">tf</code>&#13;
&#13;
<code class="n">FLAGS</code> <code class="o">=</code> <code class="n">flags</code><code class="o">.</code><code class="n">FLAGS</code>&#13;
<code class="n">_PLAYLISTS</code> <code class="o">=</code> <code class="n">flags</code><code class="o">.</code><code class="n">DEFINE_string</code><code class="p">(</code><code class="s2">"playlists"</code><code class="p">,</code> <code class="kc">None</code><code class="p">,</code> <code class="s2">"Playlist json glob."</code><code class="p">)</code>&#13;
<code class="n">_OUTPUT_PATH</code> <code class="o">=</code> <code class="n">flags</code><code class="o">.</code><code class="n">DEFINE_string</code><code class="p">(</code><code class="s2">"output"</code><code class="p">,</code> <code class="s2">"data"</code><code class="p">,</code> <code class="s2">"Output path."</code><code class="p">)</code>&#13;
&#13;
<code class="c1"># Required flag.</code>&#13;
<code class="n">flags</code><code class="o">.</code><code class="n">mark_flag_as_required</code><code class="p">(</code><code class="s2">"playlists"</code><code class="p">)</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">update_dict</code><code class="p">(</code><code class="nb">dict</code><code class="p">:</code> <code class="n">Dict</code><code class="p">[</code><code class="n">Any</code><code class="p">,</code> <code class="nb">int</code><code class="p">],</code> <code class="n">item</code><code class="p">:</code> <code class="n">Any</code><code class="p">):</code>&#13;
    <code class="sd">"""Adds an item to a dictionary."""</code>&#13;
    <code class="k">if</code> <code class="n">item</code> <code class="ow">not</code> <code class="ow">in</code> <code class="nb">dict</code><code class="p">:</code>&#13;
        <code class="n">index</code> <code class="o">=</code> <code class="nb">len</code><code class="p">(</code><code class="nb">dict</code><code class="p">)</code>&#13;
        <code class="nb">dict</code><code class="p">[</code><code class="n">item</code><code class="p">]</code> <code class="o">=</code> <code class="n">index</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">dump_dict</code><code class="p">(</code><code class="nb">dict</code><code class="p">:</code> <code class="n">Dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="nb">str</code><code class="p">],</code> <code class="n">name</code><code class="p">:</code> <code class="nb">str</code><code class="p">):</code>&#13;
  <code class="sd">"""Dumps a dictionary as json."""</code>&#13;
  <code class="n">fname</code> <code class="o">=</code> <code class="n">os</code><code class="o">.</code><code class="n">path</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">_OUTPUT_PATH</code><code class="o">.</code><code class="n">value</code><code class="p">,</code> <code class="n">name</code><code class="p">)</code>&#13;
  <code class="k">with</code> <code class="nb">open</code><code class="p">(</code><code class="n">fname</code><code class="p">,</code> <code class="s2">"w"</code><code class="p">)</code> <code class="k">as</code> <code class="n">f</code><code class="p">:</code>&#13;
    <code class="n">json</code><code class="o">.</code><code class="n">dump</code><code class="p">(</code><code class="nb">dict</code><code class="p">,</code> <code class="n">f</code><code class="p">)</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">main</code><code class="p">(</code><code class="n">argv</code><code class="p">):</code>&#13;
    <code class="sd">"""Main function."""</code>&#13;
    <code class="k">del</code> <code class="n">argv</code>  <code class="c1"># Unused.</code>&#13;
&#13;
    <code class="n">tf</code><code class="o">.</code><code class="n">config</code><code class="o">.</code><code class="n">set_visible_devices</code><code class="p">([],</code> <code class="s1">'GPU'</code><code class="p">)</code>&#13;
    <code class="n">tf</code><code class="o">.</code><code class="n">compat</code><code class="o">.</code><code class="n">v1</code><code class="o">.</code><code class="n">enable_eager_execution</code><code class="p">()</code>&#13;
    <code class="n">playlist_files</code> <code class="o">=</code> <code class="n">glob</code><code class="o">.</code><code class="n">glob</code><code class="p">(</code><code class="n">_PLAYLISTS</code><code class="o">.</code><code class="n">value</code><code class="p">)</code>&#13;
    <code class="n">track_uri_dict</code> <code class="o">=</code> <code class="p">{}</code>&#13;
    <code class="n">artist_uri_dict</code> <code class="o">=</code> <code class="p">{}</code>&#13;
    <code class="n">album_uri_dict</code> <code class="o">=</code> <code class="p">{}</code>&#13;
&#13;
    <code class="k">for</code> <code class="n">playlist_file</code> <code class="ow">in</code> <code class="n">playlist_files</code><code class="p">:</code>&#13;
        <code class="nb">print</code><code class="p">(</code><code class="s2">"Processing "</code><code class="p">,</code> <code class="n">playlist_file</code><code class="p">)</code>&#13;
        <code class="k">with</code> <code class="nb">open</code><code class="p">(</code><code class="n">playlist_file</code><code class="p">,</code> <code class="s2">"r"</code><code class="p">)</code> <code class="k">as</code> <code class="n">file</code><code class="p">:</code>&#13;
            <code class="n">data</code> <code class="o">=</code> <code class="n">json</code><code class="o">.</code><code class="n">load</code><code class="p">(</code><code class="n">file</code><code class="p">)</code>&#13;
            <code class="n">playlists</code> <code class="o">=</code> <code class="n">data</code><code class="p">[</code><code class="s2">"playlists"</code><code class="p">]</code>&#13;
            <code class="k">for</code> <code class="n">playlist</code> <code class="ow">in</code> <code class="n">playlists</code><code class="p">:</code>&#13;
                <code class="n">tracks</code> <code class="o">=</code> <code class="n">playlist</code><code class="p">[</code><code class="s2">"tracks"</code><code class="p">]</code>&#13;
                <code class="k">for</code> <code class="n">track</code> <code class="ow">in</code> <code class="n">tracks</code><code class="p">:</code>&#13;
                  <code class="n">update_dict</code><code class="p">(</code><code class="n">track_uri_dict</code><code class="p">,</code> <code class="n">track</code><code class="p">[</code><code class="s2">"track_uri"</code><code class="p">])</code>&#13;
                  <code class="n">update_dict</code><code class="p">(</code><code class="n">artist_uri_dict</code><code class="p">,</code> <code class="n">track</code><code class="p">[</code><code class="s2">"artist_uri"</code><code class="p">])</code>&#13;
                  <code class="n">update_dict</code><code class="p">(</code><code class="n">album_uri_dict</code><code class="p">,</code> <code class="n">track</code><code class="p">[</code><code class="s2">"album_uri"</code><code class="p">])</code>&#13;
&#13;
    <code class="n">dump_dict</code><code class="p">(</code><code class="n">track_uri_dict</code><code class="p">,</code> <code class="s2">"track_uri_dict.json"</code><code class="p">)</code>&#13;
    <code class="n">dump_dict</code><code class="p">(</code><code class="n">artist_uri_dict</code><code class="p">,</code> <code class="s2">"artist_uri_dict.json"</code><code class="p">)</code>&#13;
    <code class="n">dump_dict</code><code class="p">(</code><code class="n">album_uri_dict</code><code class="p">,</code> <code class="s2">"album_uri_dict.json"</code><code class="p">)</code>&#13;
&#13;
<code class="k">if</code> <code class="vm">__name__</code> <code class="o">==</code> <code class="s2">"__main__"</code><code class="p">:</code>&#13;
    <code class="n">app</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">main</code><code class="p">)</code></pre>&#13;
&#13;
<p>Whenever a new URI is encountered, we simply increment a counter and assign that unique identifier to the URI. We do this for tracks, artists, and albums and save it as a JSON file.</p>&#13;
&#13;
<p>Although we could have used a data processing framework like PySpark for this, it is important to take note of the data size. If the data size is small, like a million playlists, it would just be faster to do it on a single machine. We should be wise about when to use a big data processing framework, and for small datasets it can sometimes be faster to simply run the code on one machine instead of writing code that runs on a cluster.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Building the Training Data" data-type="sect2"><div class="sect2" id="id153">&#13;
<h2>Building the Training Data</h2>&#13;
&#13;
<p>Now<a data-primary="Spotify playlist example" data-secondary="building training data" data-type="indexterm" id="SPEtraindata13"/> that we have the dictionaries, we can use them to convert the raw JSON playlist logs into a more usable form for ML training. The code for this is in <em>make_training.py</em>:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code> <code class="nn">glob</code>&#13;
<code class="kn">import</code> <code class="nn">json</code>&#13;
<code class="kn">import</code> <code class="nn">os</code>&#13;
<code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Any</code><code class="p">,</code> <code class="n">Dict</code><code class="p">,</code> <code class="n">Tuple</code>&#13;
&#13;
<code class="kn">from</code> <code class="nn">absl</code> <code class="kn">import</code> <code class="n">app</code>&#13;
<code class="kn">from</code> <code class="nn">absl</code> <code class="kn">import</code> <code class="n">flags</code>&#13;
<code class="kn">from</code> <code class="nn">absl</code> <code class="kn">import</code> <code class="n">logging</code>&#13;
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>&#13;
<code class="kn">import</code> <code class="nn">tensorflow</code> <code class="k">as</code> <code class="nn">tf</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">input_pipeline</code>&#13;
&#13;
<code class="n">FLAGS</code> <code class="o">=</code> <code class="n">flags</code><code class="o">.</code><code class="n">FLAGS</code>&#13;
<code class="n">_PLAYLISTS</code> <code class="o">=</code> <code class="n">flags</code><code class="o">.</code><code class="n">DEFINE_string</code><code class="p">(</code><code class="s2">"playlists"</code><code class="p">,</code> <code class="kc">None</code><code class="p">,</code> <code class="s2">"Playlist json glob."</code><code class="p">)</code>&#13;
<code class="n">_DICTIONARY_PATH</code> <code class="o">=</code> <code class="n">flags</code><code class="o">.</code><code class="n">DEFINE_string</code><code class="p">(</code><code class="s2">"dictionaries"</code><code class="p">,</code> <code class="s2">"data/dictionaries"</code><code class="p">,</code>&#13;
                   <code class="s2">"Dictionary path."</code><code class="p">)</code>&#13;
<code class="n">_OUTPUT_PATH</code> <code class="o">=</code> <code class="n">flags</code><code class="o">.</code><code class="n">DEFINE_string</code><code class="p">(</code><code class="s2">"output"</code><code class="p">,</code> <code class="s2">"data/training"</code><code class="p">,</code> <code class="s2">"Output path."</code><code class="p">)</code>&#13;
<code class="n">_TOP_K</code> <code class="o">=</code> <code class="n">flags</code><code class="o">.</code><code class="n">DEFINE_integer</code><code class="p">(</code><code class="s2">"topk"</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="s2">"Top K tracks to use as context."</code><code class="p">)</code>&#13;
<code class="n">_MIN_NEXT</code> <code class="o">=</code> <code class="n">flags</code><code class="o">.</code><code class="n">DEFINE_integer</code><code class="p">(</code><code class="s2">"min_next"</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="s2">"Min number of tracks."</code><code class="p">)</code>&#13;
&#13;
<code class="c1"># Required flag.</code>&#13;
<code class="n">flags</code><code class="o">.</code><code class="n">mark_flag_as_required</code><code class="p">(</code><code class="s2">"playlists"</code><code class="p">)</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">main</code><code class="p">(</code><code class="n">argv</code><code class="p">):</code>&#13;
    <code class="sd">"""Main function."""</code>&#13;
    <code class="k">del</code> <code class="n">argv</code>  <code class="c1"># Unused.</code>&#13;
&#13;
    <code class="n">tf</code><code class="o">.</code><code class="n">config</code><code class="o">.</code><code class="n">set_visible_devices</code><code class="p">([],</code> <code class="s1">'GPU'</code><code class="p">)</code>&#13;
    <code class="n">tf</code><code class="o">.</code><code class="n">compat</code><code class="o">.</code><code class="n">v1</code><code class="o">.</code><code class="n">enable_eager_execution</code><code class="p">()</code>&#13;
    <code class="n">playlist_files</code> <code class="o">=</code> <code class="n">glob</code><code class="o">.</code><code class="n">glob</code><code class="p">(</code><code class="n">_PLAYLISTS</code><code class="o">.</code><code class="n">value</code><code class="p">)</code>&#13;
&#13;
    <code class="n">track_uri_dict</code> <code class="o">=</code> <code class="n">input_pipeline</code><code class="o">.</code><code class="n">load_dict</code><code class="p">(</code>&#13;
      <code class="n">_DICTIONARY_PATH</code><code class="o">.</code><code class="n">value</code><code class="p">,</code> <code class="s2">"track_uri_dict.json"</code><code class="p">)</code>&#13;
&#13;
    <code class="nb">print</code><code class="p">(</code><code class="s2">"</code><code class="si">%d</code><code class="s2"> tracks loaded"</code> <code class="o">%</code> <code class="nb">len</code><code class="p">(</code><code class="n">track_uri_dict</code><code class="p">))</code>&#13;
    <code class="n">artist_uri_dict</code> <code class="o">=</code> <code class="n">input_pipeline</code><code class="o">.</code><code class="n">load_dict</code><code class="p">(</code>&#13;
      <code class="n">_DICTIONARY_PATH</code><code class="o">.</code><code class="n">value</code><code class="p">,</code> <code class="s2">"artist_uri_dict.json"</code><code class="p">)</code>&#13;
    <code class="nb">print</code><code class="p">(</code><code class="s2">"</code><code class="si">%d</code><code class="s2"> artists loaded"</code> <code class="o">%</code> <code class="nb">len</code><code class="p">(</code><code class="n">artist_uri_dict</code><code class="p">))</code>&#13;
    <code class="n">album_uri_dict</code> <code class="o">=</code> <code class="n">input_pipeline</code><code class="o">.</code><code class="n">load_dict</code><code class="p">(</code>&#13;
      <code class="n">_DICTIONARY_PATH</code><code class="o">.</code><code class="n">value</code><code class="p">,</code> <code class="s2">"album_uri_dict.json"</code><code class="p">)</code>&#13;
    <code class="nb">print</code><code class="p">(</code><code class="s2">"</code><code class="si">%d</code><code class="s2"> albums loaded"</code> <code class="o">%</code> <code class="nb">len</code><code class="p">(</code><code class="n">album_uri_dict</code><code class="p">))</code>&#13;
    <code class="n">topk</code> <code class="o">=</code> <code class="n">_TOP_K</code><code class="o">.</code><code class="n">value</code>&#13;
    <code class="n">min_next</code> <code class="o">=</code> <code class="n">_MIN_NEXT</code><code class="o">.</code><code class="n">value</code>&#13;
    <code class="nb">print</code><code class="p">(</code><code class="s2">"Filtering out playlists with less than </code><code class="si">%d</code><code class="s2"> tracks"</code> <code class="o">%</code> <code class="n">min_next</code><code class="p">)</code>&#13;
&#13;
    <code class="n">raw_tracks</code> <code class="o">=</code> <code class="p">{}</code>&#13;
&#13;
    <code class="k">for</code> <code class="n">pidx</code><code class="p">,</code> <code class="n">playlist_file</code> <code class="ow">in</code> <code class="nb">enumerate</code><code class="p">(</code><code class="n">playlist_files</code><code class="p">):</code>&#13;
        <code class="nb">print</code><code class="p">(</code><code class="s2">"Processing "</code><code class="p">,</code> <code class="n">playlist_file</code><code class="p">)</code>&#13;
        <code class="k">with</code> <code class="nb">open</code><code class="p">(</code><code class="n">playlist_file</code><code class="p">,</code> <code class="s2">"r"</code><code class="p">)</code> <code class="k">as</code> <code class="n">file</code><code class="p">:</code>&#13;
            <code class="n">data</code> <code class="o">=</code> <code class="n">json</code><code class="o">.</code><code class="n">load</code><code class="p">(</code><code class="n">file</code><code class="p">)</code>&#13;
            <code class="n">playlists</code> <code class="o">=</code> <code class="n">data</code><code class="p">[</code><code class="s2">"playlists"</code><code class="p">]</code>&#13;
            <code class="n">tfrecord_name</code> <code class="o">=</code> <code class="n">os</code><code class="o">.</code><code class="n">path</code><code class="o">.</code><code class="n">join</code><code class="p">(</code>&#13;
              <code class="n">_OUTPUT_PATH</code><code class="o">.</code><code class="n">value</code><code class="p">,</code> <code class="s2">"</code><code class="si">%05d</code><code class="s2">.tfrecord"</code> <code class="o">%</code> <code class="n">pidx</code><code class="p">)</code>&#13;
            <code class="k">with</code> <code class="n">tf</code><code class="o">.</code><code class="n">io</code><code class="o">.</code><code class="n">TFRecordWriter</code><code class="p">(</code><code class="n">tfrecord_name</code><code class="p">)</code> <code class="k">as</code> <code class="n">file_writer</code><code class="p">:</code>&#13;
              <code class="k">for</code> <code class="n">playlist</code> <code class="ow">in</code> <code class="n">playlists</code><code class="p">:</code>&#13;
                  <code class="k">if</code> <code class="n">playlist</code><code class="p">[</code><code class="s2">"num_tracks"</code><code class="p">]</code> <code class="o">&lt;</code> <code class="n">min_next</code><code class="p">:</code>&#13;
                      <code class="k">continue</code>&#13;
                  <code class="n">tracks</code> <code class="o">=</code> <code class="n">playlist</code><code class="p">[</code><code class="s2">"tracks"</code><code class="p">]</code>&#13;
                  <code class="c1"># The first topk tracks are all for the context.</code>&#13;
                  <code class="n">track_context</code> <code class="o">=</code> <code class="p">[]</code>&#13;
                  <code class="n">artist_context</code> <code class="o">=</code> <code class="p">[]</code>&#13;
                  <code class="n">album_context</code> <code class="o">=</code> <code class="p">[]</code>&#13;
                  <code class="c1"># The rest are for predicting.</code>&#13;
                  <code class="n">next_track</code> <code class="o">=</code> <code class="p">[]</code>&#13;
                  <code class="n">next_artist</code> <code class="o">=</code> <code class="p">[]</code>&#13;
                  <code class="n">next_album</code> <code class="o">=</code> <code class="p">[]</code>&#13;
                  <code class="k">for</code> <code class="n">tidx</code><code class="p">,</code> <code class="n">track</code> <code class="ow">in</code> <code class="nb">enumerate</code><code class="p">(</code><code class="n">tracks</code><code class="p">):</code>&#13;
                      <code class="n">track_uri_idx</code> <code class="o">=</code> <code class="n">track_uri_dict</code><code class="p">[</code><code class="n">track</code><code class="p">[</code><code class="s2">"track_uri"</code><code class="p">]]</code>&#13;
                      <code class="n">artist_uri_idx</code> <code class="o">=</code> <code class="n">artist_uri_dict</code><code class="p">[</code><code class="n">track</code><code class="p">[</code><code class="s2">"artist_uri"</code><code class="p">]]</code>&#13;
                      <code class="n">album_uri_idx</code> <code class="o">=</code> <code class="n">album_uri_dict</code><code class="p">[</code><code class="n">track</code><code class="p">[</code><code class="s2">"album_uri"</code><code class="p">]]</code>&#13;
                      <code class="k">if</code> <code class="n">track_uri_idx</code> <code class="ow">not</code> <code class="ow">in</code> <code class="n">raw_tracks</code><code class="p">:</code>&#13;
                          <code class="n">raw_tracks</code><code class="p">[</code><code class="n">track_uri_idx</code><code class="p">]</code> <code class="o">=</code> <code class="n">track</code>&#13;
                      <code class="k">if</code> <code class="n">tidx</code> <code class="o">&lt;</code> <code class="n">topk</code><code class="p">:</code>&#13;
                          <code class="n">track_context</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">track_uri_idx</code><code class="p">)</code>&#13;
                          <code class="n">artist_context</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">artist_uri_idx</code><code class="p">)</code>&#13;
                          <code class="n">album_context</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">album_uri_idx</code><code class="p">)</code>&#13;
                      <code class="k">else</code><code class="p">:</code>&#13;
                          <code class="n">next_track</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">track_uri_idx</code><code class="p">)</code>&#13;
                          <code class="n">next_artist</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">artist_uri_idx</code><code class="p">)</code>&#13;
                          <code class="n">next_album</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">album_uri_idx</code><code class="p">)</code>&#13;
                  <code class="k">assert</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">next_track</code><code class="p">)</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code>&#13;
                  <code class="k">assert</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">next_artist</code><code class="p">)</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code>&#13;
                  <code class="k">assert</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">next_album</code><code class="p">)</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code>&#13;
                  <code class="n">record</code> <code class="o">=</code> <code class="n">tf</code><code class="o">.</code><code class="n">train</code><code class="o">.</code><code class="n">Example</code><code class="p">(</code>&#13;
                    <code class="n">features</code><code class="o">=</code><code class="n">tf</code><code class="o">.</code><code class="n">train</code><code class="o">.</code><code class="n">Features</code><code class="p">(</code><code class="n">feature</code><code class="o">=</code><code class="p">{</code>&#13;
                      <code class="s2">"track_context"</code><code class="p">:</code> <code class="n">tf</code><code class="o">.</code><code class="n">train</code><code class="o">.</code><code class="n">Feature</code><code class="p">(</code>&#13;
                      <code class="n">int64_list</code><code class="o">=</code><code class="n">tf</code><code class="o">.</code><code class="n">train</code><code class="o">.</code><code class="n">Int64List</code><code class="p">(</code><code class="n">value</code><code class="o">=</code><code class="n">track_context</code><code class="p">)),</code>&#13;
                      <code class="s2">"album_context"</code><code class="p">:</code> <code class="n">tf</code><code class="o">.</code><code class="n">train</code><code class="o">.</code><code class="n">Feature</code><code class="p">(</code>&#13;
                      <code class="n">int64_list</code><code class="o">=</code><code class="n">tf</code><code class="o">.</code><code class="n">train</code><code class="o">.</code><code class="n">Int64List</code><code class="p">(</code><code class="n">value</code><code class="o">=</code><code class="n">album_context</code><code class="p">)),</code>&#13;
                      <code class="s2">"artist_context"</code><code class="p">:</code> <code class="n">tf</code><code class="o">.</code><code class="n">train</code><code class="o">.</code><code class="n">Feature</code><code class="p">(</code>&#13;
                      <code class="n">int64_list</code><code class="o">=</code><code class="n">tf</code><code class="o">.</code><code class="n">train</code><code class="o">.</code><code class="n">Int64List</code><code class="p">(</code><code class="n">value</code><code class="o">=</code><code class="n">artist_context</code><code class="p">)),</code>&#13;
                      <code class="s2">"next_track"</code><code class="p">:</code> <code class="n">tf</code><code class="o">.</code><code class="n">train</code><code class="o">.</code><code class="n">Feature</code><code class="p">(</code>&#13;
                      <code class="n">int64_list</code><code class="o">=</code><code class="n">tf</code><code class="o">.</code><code class="n">train</code><code class="o">.</code><code class="n">Int64List</code><code class="p">(</code><code class="n">value</code><code class="o">=</code><code class="n">next_track</code><code class="p">)),</code>&#13;
                      <code class="s2">"next_album"</code><code class="p">:</code> <code class="n">tf</code><code class="o">.</code><code class="n">train</code><code class="o">.</code><code class="n">Feature</code><code class="p">(</code>&#13;
                      <code class="n">int64_list</code><code class="o">=</code><code class="n">tf</code><code class="o">.</code><code class="n">train</code><code class="o">.</code><code class="n">Int64List</code><code class="p">(</code><code class="n">value</code><code class="o">=</code><code class="n">next_album</code><code class="p">)),</code>&#13;
                      <code class="s2">"next_artist"</code><code class="p">:</code> <code class="n">tf</code><code class="o">.</code><code class="n">train</code><code class="o">.</code><code class="n">Feature</code><code class="p">(</code>&#13;
                      <code class="n">int64_list</code><code class="o">=</code><code class="n">tf</code><code class="o">.</code><code class="n">train</code><code class="o">.</code><code class="n">Int64List</code><code class="p">(</code><code class="n">value</code><code class="o">=</code><code class="n">next_artist</code><code class="p">)),</code>&#13;
                    <code class="p">}))</code>&#13;
                  <code class="n">record_bytes</code> <code class="o">=</code> <code class="n">record</code><code class="o">.</code><code class="n">SerializeToString</code><code class="p">()</code>&#13;
                  <code class="n">file_writer</code><code class="o">.</code><code class="n">write</code><code class="p">(</code><code class="n">record_bytes</code><code class="p">)</code>&#13;
&#13;
    <code class="n">filename</code> <code class="o">=</code> <code class="n">os</code><code class="o">.</code><code class="n">path</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">_OUTPUT_PATH</code><code class="o">.</code><code class="n">value</code><code class="p">,</code> <code class="s2">"all_tracks.json"</code><code class="p">)</code>&#13;
    <code class="k">with</code> <code class="nb">open</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code> <code class="s2">"w"</code><code class="p">)</code> <code class="k">as</code> <code class="n">f</code><code class="p">:</code>&#13;
        <code class="n">json</code><code class="o">.</code><code class="n">dump</code><code class="p">(</code><code class="n">raw_tracks</code><code class="p">,</code> <code class="n">f</code><code class="p">)</code>&#13;
&#13;
<code class="k">if</code> <code class="vm">__name__</code> <code class="o">==</code> <code class="s2">"__main__"</code><code class="p">:</code>&#13;
    <code class="n">app</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">main</code><code class="p">)</code></pre>&#13;
&#13;
<p>This code reads in a raw playlist JSON file, converts the URIs from textual identifiers to the index in the dictionary, and filters out playlists that are under a minimum size. In addition, we partition the playlist such that the first five elements are grouped into the context, or user that we are recommending items for, and the next items, which are the items we wish to predict for a given user. We call the first five elements the <em>context</em> because they represent a playlist and because there won’t be a one-to-one mapping between a playlist and a user if a user has more than one playlist. We then write each playlist as a TensorFlow example in a TensorFlow record file for use with the TensorFlow data input pipeline. The records will always contain five tracks, albums, and artists for the context and at least five more next tracks for learning the inference tasks of predicting the next tracks.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We use TensorFlow objects here because of their compatibility with JAX and to introduce some very convenient data formats.</p>&#13;
</div>&#13;
&#13;
<p>We also store unique rows of tracks with all the features, which is mostly for debugging and display should we need to convert a <code>track_uri</code> into a human-readable form. This track data is stored in <em>all_tracks.json</em>.<a data-primary="" data-startref="SPEtraindata13" data-type="indexterm" id="id1085"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reading the Input" data-type="sect2"><div class="sect2" id="id154">&#13;
<h2>Reading the Input</h2>&#13;
&#13;
<p>The<a data-primary="Spotify playlist example" data-secondary="reading input" data-type="indexterm" id="SPEreadinput13"/> input is then read via <em>input_pipeline.py</em>:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code> <code class="nn">glob</code>&#13;
<code class="kn">import</code> <code class="nn">json</code>&#13;
<code class="kn">import</code> <code class="nn">os</code>&#13;
<code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Sequence</code><code class="p">,</code> <code class="n">Tuple</code><code class="p">,</code> <code class="n">Set</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">tensorflow</code> <code class="k">as</code> <code class="nn">tf</code>&#13;
<code class="kn">import</code> <code class="nn">jax.numpy</code> <code class="k">as</code> <code class="nn">jnp</code>&#13;
&#13;
<code class="n">_schema</code> <code class="o">=</code> <code class="p">{</code>&#13;
   <code class="s2">"track_context"</code><code class="p">:</code> <code class="n">tf</code><code class="o">.</code><code class="n">io</code><code class="o">.</code><code class="n">FixedLenFeature</code><code class="p">([</code><code class="mi">5</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="n">tf</code><code class="o">.</code><code class="n">int64</code><code class="p">),</code>&#13;
   <code class="s2">"album_context"</code><code class="p">:</code> <code class="n">tf</code><code class="o">.</code><code class="n">io</code><code class="o">.</code><code class="n">FixedLenFeature</code><code class="p">([</code><code class="mi">5</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="n">tf</code><code class="o">.</code><code class="n">int64</code><code class="p">),</code>&#13;
   <code class="s2">"artist_context"</code><code class="p">:</code> <code class="n">tf</code><code class="o">.</code><code class="n">io</code><code class="o">.</code><code class="n">FixedLenFeature</code><code class="p">([</code><code class="mi">5</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="n">tf</code><code class="o">.</code><code class="n">int64</code><code class="p">),</code>&#13;
   <code class="s2">"next_track"</code><code class="p">:</code> <code class="n">tf</code><code class="o">.</code><code class="n">io</code><code class="o">.</code><code class="n">VarLenFeature</code><code class="p">(</code><code class="n">dtype</code><code class="o">=</code><code class="n">tf</code><code class="o">.</code><code class="n">int64</code><code class="p">),</code>&#13;
   <code class="s2">"next_album"</code><code class="p">:</code> <code class="n">tf</code><code class="o">.</code><code class="n">io</code><code class="o">.</code><code class="n">VarLenFeature</code><code class="p">(</code><code class="n">dtype</code><code class="o">=</code><code class="n">tf</code><code class="o">.</code><code class="n">int64</code><code class="p">),</code>&#13;
   <code class="s2">"next_artist"</code><code class="p">:</code> <code class="n">tf</code><code class="o">.</code><code class="n">io</code><code class="o">.</code><code class="n">VarLenFeature</code><code class="p">(</code><code class="n">dtype</code><code class="o">=</code><code class="n">tf</code><code class="o">.</code><code class="n">int64</code><code class="p">),</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">_decode_fn</code><code class="p">(</code><code class="n">record_bytes</code><code class="p">):</code>&#13;
  <code class="n">result</code> <code class="o">=</code> <code class="n">tf</code><code class="o">.</code><code class="n">io</code><code class="o">.</code><code class="n">parse_single_example</code><code class="p">(</code><code class="n">record_bytes</code><code class="p">,</code> <code class="n">_schema</code><code class="p">)</code>&#13;
  <code class="k">for</code> <code class="n">key</code> <code class="ow">in</code> <code class="n">_schema</code><code class="o">.</code><code class="n">keys</code><code class="p">():</code>&#13;
    <code class="k">if</code> <code class="n">key</code><code class="o">.</code><code class="n">startswith</code><code class="p">(</code><code class="s2">"next"</code><code class="p">):</code>&#13;
      <code class="n">result</code><code class="p">[</code><code class="n">key</code><code class="p">]</code> <code class="o">=</code> <code class="n">tf</code><code class="o">.</code><code class="n">sparse</code><code class="o">.</code><code class="n">to_dense</code><code class="p">(</code><code class="n">result</code><code class="p">[</code><code class="n">key</code><code class="p">])</code>&#13;
  <code class="k">return</code> <code class="n">result</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">create_dataset</code><code class="p">(</code>&#13;
    <code class="n">pattern</code><code class="p">:</code> <code class="nb">str</code><code class="p">):</code>&#13;
    <code class="sd">"""Creates a spotify dataset.</code>&#13;
&#13;
<code class="sd">    Args:</code>&#13;
<code class="sd">      pattern: glob pattern of tfrecords.</code>&#13;
<code class="sd">    """</code>&#13;
    <code class="n">filenames</code> <code class="o">=</code> <code class="n">glob</code><code class="o">.</code><code class="n">glob</code><code class="p">(</code><code class="n">pattern</code><code class="p">)</code>&#13;
    <code class="n">ds</code> <code class="o">=</code> <code class="n">tf</code><code class="o">.</code><code class="n">data</code><code class="o">.</code><code class="n">TFRecordDataset</code><code class="p">(</code><code class="n">filenames</code><code class="p">)</code>&#13;
    <code class="n">ds</code> <code class="o">=</code> <code class="n">ds</code><code class="o">.</code><code class="n">map</code><code class="p">(</code><code class="n">_decode_fn</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">ds</code></pre>&#13;
&#13;
<p>We use the TensorFlow data’s functionality to read and decode the TensorFlow records and examples. For that to work, we need to supply a schema, or a dictionary, telling the decoder the names and types of features to expect. Since we have picked five tracks each for the context, we should expect five each of <code>track_context</code>, <code>album_context</code>, and <code>artist_context</code>. However, since the playlists themselves are of variable lengths, we tell the decoder to expect variable-length integers for the <code>next_track</code>, <code>next_album</code>, and <code>next_artist</code> features.</p>&#13;
&#13;
<p>The second part of <em>input_pipeline.py</em> is for reusable input code to load the dictionaries and track metadata:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="k">def</code> <code class="nf">load_dict</code><code class="p">(</code><code class="n">dictionary_path</code><code class="p">:</code> <code class="nb">str</code><code class="p">,</code> <code class="n">name</code><code class="p">:</code> <code class="nb">str</code><code class="p">):</code>&#13;
    <code class="sd">"""Loads a dictionary."""</code>&#13;
    <code class="n">filename</code> <code class="o">=</code> <code class="n">os</code><code class="o">.</code><code class="n">path</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">dictionary_path</code><code class="p">,</code> <code class="n">name</code><code class="p">)</code>&#13;
    <code class="k">with</code> <code class="nb">open</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code> <code class="s2">"r"</code><code class="p">)</code> <code class="k">as</code> <code class="n">f</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="n">json</code><code class="o">.</code><code class="n">load</code><code class="p">(</code><code class="n">f</code><code class="p">)</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">load_all_tracks</code><code class="p">(</code><code class="n">all_tracks_file</code><code class="p">:</code> <code class="nb">str</code><code class="p">,</code>&#13;
                    <code class="n">track_uri_dict</code><code class="p">,</code> <code class="n">album_uri_dict</code><code class="p">,</code> <code class="n">artist_uri_dict</code><code class="p">):</code>&#13;
  <code class="sd">"""Loads all tracks.</code>&#13;
&#13;
<code class="sd">  """</code>&#13;
  <code class="k">with</code> <code class="nb">open</code><code class="p">(</code><code class="n">all_tracks_file</code><code class="p">,</code> <code class="s2">"r"</code><code class="p">)</code> <code class="k">as</code> <code class="n">f</code><code class="p">:</code>&#13;
    <code class="n">all_tracks_json</code> <code class="o">=</code> <code class="n">json</code><code class="o">.</code><code class="n">load</code><code class="p">(</code><code class="n">f</code><code class="p">)</code>&#13;
  <code class="n">all_tracks_dict</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nb">int</code><code class="p">(</code><code class="n">k</code><code class="p">):</code> <code class="n">v</code> <code class="k">for</code> <code class="n">k</code><code class="p">,</code> <code class="n">v</code> <code class="ow">in</code> <code class="n">all_tracks_json</code><code class="o">.</code><code class="n">items</code><code class="p">()</code>&#13;
  <code class="p">}</code>&#13;
  <code class="n">all_tracks_features</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="n">k</code><code class="p">:</code> <code class="p">(</code><code class="n">track_uri_dict</code><code class="p">[</code><code class="n">v</code><code class="p">[</code><code class="s2">"track_uri"</code><code class="p">]],</code>&#13;
        <code class="n">album_uri_dict</code><code class="p">[</code><code class="n">v</code><code class="p">[</code><code class="s2">"album_uri"</code><code class="p">]],</code>&#13;
        <code class="n">artist_uri_dict</code><code class="p">[</code><code class="n">v</code><code class="p">[</code><code class="s2">"artist_uri"</code><code class="p">]])</code>&#13;
    <code class="k">for</code> <code class="n">k</code><code class="p">,</code><code class="n">v</code> <code class="ow">in</code> <code class="n">all_tracks_dict</code><code class="o">.</code><code class="n">items</code><code class="p">()</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="n">all_tracks_dict</code><code class="p">,</code> <code class="n">all_tracks_features</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">make_all_tracks_numpy</code><code class="p">(</code><code class="n">all_tracks_features</code><code class="p">):</code>&#13;
  <code class="sd">"""Makes the entire corpus available for scoring."""</code>&#13;
  <code class="n">all_tracks</code> <code class="o">=</code> <code class="p">[]</code>&#13;
  <code class="n">all_albums</code> <code class="o">=</code> <code class="p">[]</code>&#13;
  <code class="n">all_artists</code> <code class="o">=</code> <code class="p">[]</code>&#13;
  <code class="n">items</code> <code class="o">=</code> <code class="nb">sorted</code><code class="p">(</code><code class="n">all_tracks_features</code><code class="o">.</code><code class="n">items</code><code class="p">())</code>&#13;
  <code class="k">for</code> <code class="n">row</code> <code class="ow">in</code> <code class="n">items</code><code class="p">:</code>&#13;
    <code class="n">k</code><code class="p">,</code> <code class="n">v</code> <code class="o">=</code> <code class="n">row</code>&#13;
    <code class="n">all_tracks</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">v</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code>&#13;
    <code class="n">all_albums</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">v</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code>&#13;
    <code class="n">all_artists</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">v</code><code class="p">[</code><code class="mi">2</code><code class="p">])</code>&#13;
  <code class="n">all_tracks</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="n">all_tracks</code><code class="p">,</code> <code class="n">dtype</code><code class="o">=</code><code class="n">jnp</code><code class="o">.</code><code class="n">int32</code><code class="p">)</code>&#13;
  <code class="n">all_albums</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="n">all_albums</code><code class="p">,</code> <code class="n">dtype</code><code class="o">=</code><code class="n">jnp</code><code class="o">.</code><code class="n">int32</code><code class="p">)</code>&#13;
  <code class="n">all_artists</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="n">all_artists</code><code class="p">,</code> <code class="n">dtype</code><code class="o">=</code><code class="n">jnp</code><code class="o">.</code><code class="n">int32</code><code class="p">)</code>&#13;
  <code class="k">return</code> <code class="n">all_tracks</code><code class="p">,</code> <code class="n">all_albums</code><code class="p">,</code> <code class="n">all_artists</code></pre>&#13;
&#13;
<p>We also supply a utility function to convert the <em>all_tracks.json</em> file into the entire corpus of tracks for scoring in the final recommendations. After all, the goal is to rank the entire corpus, given the first five context tracks, and see how well they match the given next track data.<a data-primary="" data-startref="SPEreadinput13" data-type="indexterm" id="id1086"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Modeling the Problem" data-type="sect2"><div class="sect2" id="id155">&#13;
<h2>Modeling the Problem</h2>&#13;
&#13;
<p>Next, let’s<a data-primary="Spotify playlist example" data-secondary="modeling problems" data-type="indexterm" id="SPEprop13"/> think of how we will model the problem. We have five context tracks, each with an associated artist and album. We know that we have more tracks than playlists, so for now we will simply ignore the <code>track_id</code> and just use the <code>album_id</code> and <code>artist_id</code> as features. One strategy could be to use one-hot encoding for the album and artist, and this would work well, but one-hot encoding tends to lead to models with high precision but less generalization.</p>&#13;
&#13;
<p>An alternate way to represent identifiers is to embed them—that is, to make a lookup table to an embedding of a fixed size that is lower dimensional than the cardinality of the identifiers. This embedding can be thought of as a low-rank approximation to the full-rank matrix of identifiers. We covered low-rank embeddings in earlier chapters, and we use that concept here as features to represent the album and artists.</p>&#13;
&#13;
<p>Take a look at <em>models.py</em>, which contains the code for <code>SpotifyModel</code>:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">functools</code> <code class="kn">import</code> <code class="n">partial</code>&#13;
<code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Any</code><code class="p">,</code> <code class="n">Callable</code><code class="p">,</code> <code class="n">Sequence</code><code class="p">,</code> <code class="n">Tuple</code>&#13;
&#13;
<code class="kn">from</code> <code class="nn">flax</code> <code class="kn">import</code> <code class="n">linen</code> <code class="k">as</code> <code class="n">nn</code>&#13;
<code class="kn">import</code> <code class="nn">jax.numpy</code> <code class="k">as</code> <code class="nn">jnp</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">SpotifyModel</code><code class="p">(</code><code class="n">nn</code><code class="o">.</code><code class="n">Module</code><code class="p">):</code>&#13;
    <code class="sd">"""Spotify model that takes a context and predicts the next tracks."""</code>&#13;
    <code class="n">feature_size</code> <code class="p">:</code> <code class="nb">int</code>&#13;
&#13;
    <code class="k">def</code> <code class="nf">setup</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>&#13;
        <code class="c1"># There are too many tracks and albums so limit by hashing.</code>&#13;
        <code class="bp">self</code><code class="o">.</code><code class="n">max_albums</code> <code class="o">=</code> <code class="mi">100000</code>&#13;
        <code class="bp">self</code><code class="o">.</code><code class="n">album_embed</code> <code class="o">=</code> <code class="n">nn</code><code class="o">.</code><code class="n">Embed</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">max_albums</code><code class="p">,</code> <code class="bp">self</code><code class="o">.</code><code class="n">feature_size</code><code class="p">)</code>&#13;
        <code class="bp">self</code><code class="o">.</code><code class="n">artist_embed</code> <code class="o">=</code> <code class="n">nn</code><code class="o">.</code><code class="n">Embed</code><code class="p">(</code><code class="mi">295861</code><code class="p">,</code> <code class="bp">self</code><code class="o">.</code><code class="n">feature_size</code><code class="p">)</code>&#13;
&#13;
    <code class="k">def</code> <code class="nf">get_embeddings</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">album</code><code class="p">,</code> <code class="n">artist</code><code class="p">):</code>&#13;
        <code class="sd">"""</code>&#13;
<code class="sd">        Given track, album, artist indices return the embeddings.</code>&#13;
<code class="sd">        Args:</code>&#13;
<code class="sd">            album: ints of shape nx1</code>&#13;
<code class="sd">            artist: ints of shape nx1</code>&#13;
<code class="sd">        Returns:</code>&#13;
<code class="sd">            Embeddings representing the track.</code>&#13;
<code class="sd">        """</code>&#13;
        <code class="n">album_modded</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">mod</code><code class="p">(</code><code class="n">album</code><code class="p">,</code> <code class="bp">self</code><code class="o">.</code><code class="n">max_albums</code><code class="p">)</code>&#13;
        <code class="n">album_embed</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">album_embed</code><code class="p">(</code><code class="n">album_modded</code><code class="p">)</code>&#13;
        <code class="n">artist_embed</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">artist_embed</code><code class="p">(</code><code class="n">artist</code><code class="p">)</code>&#13;
        <code class="n">result</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">concatenate</code><code class="p">([</code><code class="n">album_embed</code><code class="p">,</code> <code class="n">artist_embed</code><code class="p">],</code> <code class="n">axis</code><code class="o">=-</code><code class="mi">1</code><code class="p">)</code>&#13;
        <code class="k">return</code> <code class="n">result</code></pre>&#13;
&#13;
<p>In the setup code, notice that we have two embeddings, for the albums and the artists. We have a lot of albums, so we show one way to reduce the memory footprint of album embeddings: take the mod of a smaller number than the number of embeddings so that multiple albums might share an embedding. If more memory is available, you can remove the mod, but this technique is demonstrated here as a way of getting some benefit of having an embedding for a feature with very large cardinality.</p>&#13;
&#13;
<p>The artist is probably the most informative feature, and the data includes far fewer unique artists, so we have a one-to-one mapping between the <code>artist_id</code> and the embeddings. When we convert the tuple of <code>(album_id, artist_id)</code> to an embedding, we do separate lookups for each ID and then concatenate the embeddings and return one complete embedding to represent a track. If more playlist data becomes available, you might also want to embed the <code>track_id</code>. However, given that we have more unique tracks than playlists, the <code>track_id</code> feature will not generalize well until we have more playlist data and the <code>track_id</code> could occur more often as observations. A general rule of thumb is that a feature should occur at least 100 times to be useful; otherwise, the gradients for that feature will not be updated very often, and it might as well be a random number because it is initialized as such.</p>&#13;
&#13;
<p>In the <code>call</code> section, we do the heavy lifting of computing the affinity of a context to other tracks:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="k">def</code> <code class="fm">__call__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code>&#13;
                 <code class="n">track_context</code><code class="p">,</code> <code class="n">album_context</code><code class="p">,</code> <code class="n">artist_context</code><code class="p">,</code>&#13;
                 <code class="n">next_track</code><code class="p">,</code> <code class="n">next_album</code><code class="p">,</code> <code class="n">next_artist</code><code class="p">,</code>&#13;
                 <code class="n">neg_track</code><code class="p">,</code> <code class="n">neg_album</code><code class="p">,</code> <code class="n">neg_artist</code><code class="p">):</code>&#13;
        <code class="sd">"""Returns the affinity score to the context.</code>&#13;
<code class="sd">        Args:</code>&#13;
<code class="sd">            track_context: ints of shape n</code>&#13;
<code class="sd">            album_context: ints of shape n</code>&#13;
<code class="sd">            artist_context: ints of shape n</code>&#13;
<code class="sd">            next_track: int of shape m</code>&#13;
<code class="sd">            next_album: int of shape m</code>&#13;
<code class="sd">            next_artist: int of shape m</code>&#13;
<code class="sd">            neg_track: int of shape o</code>&#13;
<code class="sd">            neg_album: int of shape o</code>&#13;
<code class="sd">            neg_artist: int of shape o</code>&#13;
<code class="sd">        Returns:</code>&#13;
<code class="sd">            pos_affinity: affinity of context to the next track of shape m.</code>&#13;
<code class="sd">            neg_affinity: affinity of context to the neg tracks of shape o.</code>&#13;
<code class="sd">        """</code>&#13;
        <code class="n">context_embed</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">get_embeddings</code><code class="p">(</code><code class="n">album_context</code><code class="p">,</code> <code class="n">artist_context</code><code class="p">)</code>&#13;
        <code class="n">next_embed</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">get_embeddings</code><code class="p">(</code><code class="n">next_album</code><code class="p">,</code> <code class="n">next_artist</code><code class="p">)</code>&#13;
        <code class="n">neg_embed</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">get_embeddings</code><code class="p">(</code><code class="n">neg_album</code><code class="p">,</code> <code class="n">neg_artist</code><code class="p">)</code>&#13;
&#13;
        <code class="c1"># The affinity of the context to the other track is simply the dot</code>&#13;
        <code class="c1"># product of each context embedding with the other track's embedding.</code>&#13;
        <code class="c1"># We also add a small boost if the album or artist match.</code>&#13;
        <code class="n">pos_affinity</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">max</code><code class="p">(</code><code class="n">jnp</code><code class="o">.</code><code class="n">dot</code><code class="p">(</code><code class="n">next_embed</code><code class="p">,</code> <code class="n">context_embed</code><code class="o">.</code><code class="n">T</code><code class="p">),</code> <code class="n">axis</code><code class="o">=-</code><code class="mi">1</code><code class="p">)</code>&#13;
        <code class="n">pos_affinity</code> <code class="o">=</code> <code class="n">pos_affinity</code> <code class="o">+</code> <code class="mf">0.1</code> <code class="o">*</code> <code class="n">jnp</code><code class="o">.</code><code class="n">isin</code><code class="p">(</code><code class="n">next_album</code><code class="p">,</code> <code class="n">album_context</code><code class="p">)</code>&#13;
        <code class="n">pos_affinity</code> <code class="o">=</code> <code class="n">pos_affinity</code> <code class="o">+</code> <code class="mf">0.1</code> <code class="o">*</code> <code class="n">jnp</code><code class="o">.</code><code class="n">isin</code><code class="p">(</code><code class="n">next_artist</code><code class="p">,</code> <code class="n">artist_context</code><code class="p">)</code>&#13;
&#13;
        <code class="n">neg_affinity</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">max</code><code class="p">(</code><code class="n">jnp</code><code class="o">.</code><code class="n">dot</code><code class="p">(</code><code class="n">neg_embed</code><code class="p">,</code> <code class="n">context_embed</code><code class="o">.</code><code class="n">T</code><code class="p">),</code> <code class="n">axis</code><code class="o">=-</code><code class="mi">1</code><code class="p">)</code>&#13;
        <code class="n">neg_affinity</code> <code class="o">=</code> <code class="n">neg_affinity</code> <code class="o">+</code> <code class="mf">0.1</code> <code class="o">*</code> <code class="n">jnp</code><code class="o">.</code><code class="n">isin</code><code class="p">(</code><code class="n">neg_album</code><code class="p">,</code> <code class="n">album_context</code><code class="p">)</code>&#13;
        <code class="n">neg_affinity</code> <code class="o">=</code> <code class="n">neg_affinity</code> <code class="o">+</code> <code class="mf">0.1</code> <code class="o">*</code> <code class="n">jnp</code><code class="o">.</code><code class="n">isin</code><code class="p">(</code><code class="n">neg_artist</code><code class="p">,</code> <code class="n">artist_context</code><code class="p">)</code>&#13;
&#13;
        <code class="n">all_embeddings</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">concatenate</code><code class="p">(</code>&#13;
        <code class="p">[</code><code class="n">context_embed</code><code class="p">,</code> <code class="n">next_embed</code><code class="p">,</code> <code class="n">neg_embed</code><code class="p">],</code> <code class="n">axis</code><code class="o">=-</code><code class="mi">2</code><code class="p">)</code>&#13;
        <code class="n">all_embeddings_l2</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">sqrt</code><code class="p">(</code>&#13;
        <code class="n">jnp</code><code class="o">.</code><code class="n">sum</code><code class="p">(</code><code class="n">jnp</code><code class="o">.</code><code class="n">square</code><code class="p">(</code><code class="n">all_embeddings</code><code class="p">),</code> <code class="n">axis</code><code class="o">=-</code><code class="mi">1</code><code class="p">))</code>&#13;
&#13;
        <code class="n">context_self_affinity</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">dot</code><code class="p">(</code><code class="n">jnp</code><code class="o">.</code><code class="n">flip</code><code class="p">(</code>&#13;
        <code class="n">context_embed</code><code class="p">,</code> <code class="n">axis</code><code class="o">=-</code><code class="mi">2</code><code class="p">),</code> <code class="n">context_embed</code><code class="o">.</code><code class="n">T</code><code class="p">)</code>&#13;
        <code class="n">next_self_affinity</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">dot</code><code class="p">(</code><code class="n">jnp</code><code class="o">.</code><code class="n">flip</code><code class="p">(</code>&#13;
        <code class="n">next_embed</code><code class="p">,</code> <code class="n">axis</code><code class="o">=-</code><code class="mi">2</code><code class="p">),</code> <code class="n">next_embed</code><code class="o">.</code><code class="n">T</code><code class="p">)</code>&#13;
        <code class="n">neg_self_affinity</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">dot</code><code class="p">(</code><code class="n">jnp</code><code class="o">.</code><code class="n">flip</code><code class="p">(</code><code class="n">neg_embed</code><code class="p">,</code> <code class="n">axis</code><code class="o">=-</code><code class="mi">2</code><code class="p">),</code> <code class="n">neg_embed</code><code class="o">.</code><code class="n">T</code><code class="p">)</code>&#13;
&#13;
        <code class="k">return</code> <code class="p">(</code><code class="n">pos_affinity</code><code class="p">,</code> <code class="n">neg_affinity</code><code class="p">,</code>&#13;
                <code class="n">context_self_affinity</code><code class="p">,</code> <code class="n">next_self_affinity</code><code class="p">,</code> <code class="n">neg_self_affinity</code><code class="p">,</code>&#13;
                <code class="n">all_embeddings_l2</code><code class="p">)</code></pre>&#13;
&#13;
<p>Let’s dig into this a bit since this is the core of the model code. The first part is pretty straightforward: we convert the indices into embeddings by looking up the album and artist embedding and concatenating them as a single vector per track. It is in this location that you would add in other dense features by concatenation, or convert sparse features to embeddings as we have done.</p>&#13;
&#13;
<p>The next part computes the<a data-primary="affinity" data-type="indexterm" id="id1087"/> affinity of the context to the next tracks. Recall that the context is composed of the first five tracks, and the next track is the rest of the playlist to be computed. We have several choices here for representing the context and computing the affinity.</p>&#13;
&#13;
<p>For the affinity of the context, we have chosen the simplest form of affinity, that of a dot product. The other consideration is how we treat the context, since it is composed of five tracks. One possible way is to average all the context embeddings and use the average as the representation for the context. Another way is to find the track with the maximal affinity as the closest track in the context to that of the next track.</p>&#13;
&#13;
<p>Details on various options can be found in <a href="https://oreil.ly/ig7Ch">“Affinity Weighted Embedding”</a> by Jason Weston et al. We have found that if a user has diverse interests, finding the max affinity doesn’t update the context embeddings in the same direction as the next track, as using the mean embedding does. In the case of playlists, the mean context embedding vector should function just as well because playlists tend to be on a single theme.</p>&#13;
&#13;
<p>Notice that we compute the affinity for the negative tracks as well. This is because we want the next tracks to have more affinity to the context than the negative tracks. In addition to the affinity of the context and next tracks to the context, we also compute the L2 norm of the vectors as a way to regularize the model so it does not overfit on the training data. We also reverse the embedding vectors and compute what we call<a data-primary="self-affinity" data-type="indexterm" id="id1088"/> <em>self-affinity</em>, or the affinity of the context, next, and negative embeddings to themselves, simply by reversing the list of vectors and taking the dot product. This does not exhaustively compute all the affinities of the set with itself; this again is left as an exercise for you as it builds intuition and skill in using JAX.</p>&#13;
&#13;
<p>The results are then returned as a tuple to the caller.<a data-primary="" data-startref="SPEprop13" data-type="indexterm" id="id1089"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Framing the Loss Function" data-type="sect2"><div class="sect2" id="id156">&#13;
<h2>Framing the Loss Function</h2>&#13;
&#13;
<p>Now, let’s<a data-primary="Spotify playlist example" data-secondary="framing loss functions" data-type="indexterm" id="SPEframing13"/><a data-primary="loss functions" data-secondary="framing for Spotify example" data-type="indexterm" id="LFframing13"/> look at <em>train_spotify.py</em>. We will skip the boilerplate code and just look at the evaluation and training steps:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="k">def</code> <code class="nf">eval_step</code><code class="p">(</code><code class="n">state</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">all_tracks</code><code class="p">,</code> <code class="n">all_albums</code><code class="p">,</code> <code class="n">all_artists</code><code class="p">):</code>&#13;
    <code class="n">result</code> <code class="o">=</code> <code class="n">state</code><code class="o">.</code><code class="n">apply_fn</code><code class="p">(</code>&#13;
            <code class="n">state</code><code class="o">.</code><code class="n">params</code><code class="p">,</code>&#13;
            <code class="n">y</code><code class="p">[</code><code class="s2">"track_context"</code><code class="p">],</code> <code class="n">y</code><code class="p">[</code><code class="s2">"album_context"</code><code class="p">],</code> <code class="n">y</code><code class="p">[</code><code class="s2">"artist_context"</code><code class="p">],</code>&#13;
            <code class="n">y</code><code class="p">[</code><code class="s2">"next_track"</code><code class="p">],</code> <code class="n">y</code><code class="p">[</code><code class="s2">"next_album"</code><code class="p">],</code> <code class="n">y</code><code class="p">[</code><code class="s2">"next_artist"</code><code class="p">],</code>&#13;
            <code class="n">all_tracks</code><code class="p">,</code> <code class="n">all_albums</code><code class="p">,</code> <code class="n">all_artists</code><code class="p">)</code>&#13;
    <code class="n">all_affinity</code> <code class="o">=</code> <code class="n">result</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>&#13;
    <code class="n">top_k_scores</code><code class="p">,</code> <code class="n">top_k_indices</code> <code class="o">=</code> <code class="n">jax</code><code class="o">.</code><code class="n">lax</code><code class="o">.</code><code class="n">top_k</code><code class="p">(</code><code class="n">all_affinity</code><code class="p">,</code> <code class="mi">500</code><code class="p">)</code>&#13;
    <code class="n">top_tracks</code> <code class="o">=</code> <code class="n">all_tracks</code><code class="p">[</code><code class="n">top_k_indices</code><code class="p">]</code>&#13;
    <code class="n">top_artists</code> <code class="o">=</code> <code class="n">all_artists</code><code class="p">[</code><code class="n">top_k_indices</code><code class="p">]</code>&#13;
    <code class="n">top_tracks_count</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">sum</code><code class="p">(</code><code class="n">jnp</code><code class="o">.</code><code class="n">isin</code><code class="p">(</code>&#13;
      <code class="n">top_tracks</code><code class="p">,</code> <code class="n">y</code><code class="p">[</code><code class="s2">"next_track"</code><code class="p">]))</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">jnp</code><code class="o">.</code><code class="n">float32</code><code class="p">)</code>&#13;
    <code class="n">top_artists_count</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">sum</code><code class="p">(</code><code class="n">jnp</code><code class="o">.</code><code class="n">isin</code><code class="p">(</code>&#13;
      <code class="n">top_artists</code><code class="p">,</code> <code class="n">y</code><code class="p">[</code><code class="s2">"next_artist"</code><code class="p">]))</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">jnp</code><code class="o">.</code><code class="n">float32</code><code class="p">)</code>&#13;
&#13;
    <code class="n">top_tracks_recall</code> <code class="o">=</code> <code class="n">top_tracks_count</code> <code class="o">/</code> <code class="n">y</code><code class="p">[</code><code class="s2">"next_track"</code><code class="p">]</code><code class="o">.</code><code class="n">shape</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>&#13;
    <code class="n">top_artists_recall</code> <code class="o">=</code> <code class="n">top_artists_count</code> <code class="o">/</code> <code class="n">y</code><code class="p">[</code><code class="s2">"next_artist"</code><code class="p">]</code><code class="o">.</code><code class="n">shape</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>&#13;
&#13;
    <code class="n">metrics</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">stack</code><code class="p">([</code><code class="n">top_tracks_recall</code><code class="p">,</code> <code class="n">top_artists_recall</code><code class="p">])</code>&#13;
&#13;
    <code class="k">return</code> <code class="n">metrics</code></pre>&#13;
&#13;
<p>The first piece of code is the evaluation step. To compute the affinities of the entire corpus, we pass in the album and artist indices for every possible track in the corpus to the model and then sort them using <code>jax.lax.top_k</code>. The first two lines are the scoring code for recommending the next tracks from the context during recommendations. LAX<a data-primary="LAX library" data-type="indexterm" id="id1090"/> is a utility library that comes with JAX that contains functions outside of the NumPy API that are handy to work with vector processors like GPUs and TPUs. In the Spotify Million Playlist Dataset Challenge, one of the metrics is the recall@k at the artist and track level. For the tracks, the <code>isin</code> function returns the correct metric of the intersection of the next tracks and the top 500 scoring tracks of the corpus divided by the size of the set of next tracks. This is because the tracks are unique in the corpus. However, JAX’s <code>isin</code> doesn’t support making the elements unique, so for the artist recall metric, we might count artists in the recall set more than once. For the sake of computational efficiency, we use the multiple counts instead so that the evaluation might be computed quickly on the GPU so as not to stall the training pipeline. On a final evaluation, we might want to move the dataset to a CPU for a more accurate metric.</p>&#13;
&#13;
<p>We use<a data-primary="Weights &amp; Biases" data-type="indexterm" id="id1091"/> Weights &amp; Biases again to track all the metrics, as depicted in <a data-type="xref" href="#wandb_spotify_metrics_figure">Figure 13-1</a>. You can see how they fare with each other over several experiments:</p>&#13;
&#13;
<figure><div class="figure" id="wandb_spotify_metrics_figure">&#13;
<img alt="Spotify Million Platlist Dataset Evaluation Metrics" src="assets/brpj_1301.png"/>&#13;
<h6><span class="label">Figure 13-1. </span>Weights &amp; Biases experiment tracking</h6>&#13;
</div></figure>&#13;
&#13;
<p>Next, we will look at the loss functions, another juicy part that you can experiment with in the exercises at the end of the chapter:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="k">def</code> <code class="nf">train_step</code><code class="p">(</code><code class="n">state</code><code class="p">,</code> <code class="n">x</code><code class="p">,</code> <code class="n">regularization</code><code class="p">):</code>&#13;
    <code class="k">def</code> <code class="nf">loss_fn</code><code class="p">(</code><code class="n">params</code><code class="p">):</code>&#13;
        <code class="n">result</code> <code class="o">=</code> <code class="n">state</code><code class="o">.</code><code class="n">apply_fn</code><code class="p">(</code>&#13;
            <code class="n">params</code><code class="p">,</code>&#13;
            <code class="n">x</code><code class="p">[</code><code class="s2">"track_context"</code><code class="p">],</code> <code class="n">x</code><code class="p">[</code><code class="s2">"album_context"</code><code class="p">],</code> <code class="n">x</code><code class="p">[</code><code class="s2">"artist_context"</code><code class="p">],</code>&#13;
            <code class="n">x</code><code class="p">[</code><code class="s2">"next_track"</code><code class="p">],</code> <code class="n">x</code><code class="p">[</code><code class="s2">"next_album"</code><code class="p">],</code> <code class="n">x</code><code class="p">[</code><code class="s2">"next_artist"</code><code class="p">],</code>&#13;
            <code class="n">x</code><code class="p">[</code><code class="s2">"neg_track"</code><code class="p">],</code> <code class="n">x</code><code class="p">[</code><code class="s2">"neg_album"</code><code class="p">],</code> <code class="n">x</code><code class="p">[</code><code class="s2">"neg_artist"</code><code class="p">])</code>&#13;
      <code class="n">pos_affinity</code> <code class="o">=</code> <code class="n">result</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>&#13;
      <code class="n">neg_affinity</code> <code class="o">=</code> <code class="n">result</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>&#13;
      <code class="n">context_self_affinity</code> <code class="o">=</code> <code class="n">result</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code>&#13;
      <code class="n">next_self_affinity</code> <code class="o">=</code> <code class="n">result</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code>&#13;
      <code class="n">neg_self_affinity</code> <code class="o">=</code> <code class="n">result</code><code class="p">[</code><code class="mi">4</code><code class="p">]</code>&#13;
      <code class="n">all_embeddings_l2</code> <code class="o">=</code> <code class="n">result</code><code class="p">[</code><code class="mi">5</code><code class="p">]</code>&#13;
&#13;
      <code class="n">mean_neg_affinity</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">mean</code><code class="p">(</code><code class="n">neg_affinity</code><code class="p">)</code>&#13;
      <code class="n">mean_pos_affinity</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">mean</code><code class="p">(</code><code class="n">pos_affinity</code><code class="p">)</code>&#13;
      <code class="n">mean_triplet_loss</code> <code class="o">=</code> <code class="n">nn</code><code class="o">.</code><code class="n">relu</code><code class="p">(</code><code class="mf">1.0</code> <code class="o">+</code> <code class="n">mean_neg_affinity</code> <code class="o">-</code> <code class="n">mean_pos_affinity</code><code class="p">)</code>&#13;
&#13;
      <code class="n">max_neg_affinity</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">max</code><code class="p">(</code><code class="n">neg_affinity</code><code class="p">)</code>&#13;
      <code class="n">min_pos_affinity</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">min</code><code class="p">(</code><code class="n">pos_affinity</code><code class="p">)</code>&#13;
      <code class="n">extremal_triplet_loss</code> <code class="o">=</code> <code class="n">nn</code><code class="o">.</code><code class="n">relu</code><code class="p">(</code>&#13;
                              <code class="mf">1.0</code> <code class="o">+</code> <code class="n">max_neg_affinity</code> <code class="o">-</code> <code class="n">min_pos_affinity</code>&#13;
                                <code class="p">)</code>&#13;
&#13;
      <code class="n">context_self_affinity_loss</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">mean</code><code class="p">(</code><code class="n">nn</code><code class="o">.</code><code class="n">relu</code><code class="p">(</code><code class="mf">0.5</code> <code class="o">-</code> <code class="n">context_self_affinity</code><code class="p">))</code>&#13;
      <code class="n">next_self_affinity_loss</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">mean</code><code class="p">(</code><code class="n">nn</code><code class="o">.</code><code class="n">relu</code><code class="p">(</code>&#13;
                                <code class="mf">0.5</code> <code class="o">-</code> <code class="n">next_self_affinity</code><code class="p">)</code>&#13;
                                <code class="p">)</code>&#13;
      <code class="n">neg_self_affinity_loss</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">mean</code><code class="p">(</code><code class="n">nn</code><code class="o">.</code><code class="n">relu</code><code class="p">(</code><code class="n">neg_self_affinity</code><code class="p">))</code>&#13;
&#13;
      <code class="n">reg_loss</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">sum</code><code class="p">(</code><code class="n">nn</code><code class="o">.</code><code class="n">relu</code><code class="p">(</code><code class="n">all_embeddings_l2</code> <code class="o">-</code> <code class="n">regularization</code><code class="p">))</code>&#13;
      <code class="n">loss</code> <code class="o">=</code> <code class="p">(</code><code class="n">extremal_triplet_loss</code> <code class="o">+</code> <code class="n">mean_triplet_loss</code> <code class="o">+</code> <code class="n">reg_loss</code> <code class="o">+</code>&#13;
              <code class="n">context_self_affinity_loss</code> <code class="o">+</code> <code class="n">next_self_affinity_loss</code> <code class="o">+</code>&#13;
              <code class="n">neg_self_affinity_loss</code><code class="p">)</code>&#13;
      <code class="k">return</code> <code class="n">loss</code>&#13;
&#13;
    <code class="n">grad_fn</code> <code class="o">=</code> <code class="n">jax</code><code class="o">.</code><code class="n">value_and_grad</code><code class="p">(</code><code class="n">loss_fn</code><code class="p">)</code>&#13;
    <code class="n">loss</code><code class="p">,</code> <code class="n">grads</code> <code class="o">=</code> <code class="n">grad_fn</code><code class="p">(</code><code class="n">state</code><code class="o">.</code><code class="n">params</code><code class="p">)</code>&#13;
    <code class="n">new_state</code> <code class="o">=</code> <code class="n">state</code><code class="o">.</code><code class="n">apply_gradients</code><code class="p">(</code><code class="n">grads</code><code class="o">=</code><code class="n">grads</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">new_state</code><code class="p">,</code> <code class="n">loss</code></pre>&#13;
&#13;
<p>We have several losses here, some directly related to the main task and others that help with regularization and generalization.</p>&#13;
&#13;
<p>We initially started with the <code>mean_triplet_loss</code>, which is simply a loss that states that the positive affinity, or the affinity of the context tracks to the next tracks, should be one more than the negative affinity, or the affinity of the context tracks to the negative tracks. We will discuss how we experimented to obtain the other auxiliary loss functions.</p>&#13;
&#13;
<p>Experiment tracking, depicted in <a data-type="xref" href="#wandb_spotify_eval_track_metrics_figure">Figure 13-2</a>, is important in the process of improving the model, as is reproducibility. We have tried as much as possible to make the training process deterministic by using random-number generators from JAX that are reproducible by using the same starting random-number generator seed.</p>&#13;
&#13;
<figure><div class="figure" id="wandb_spotify_eval_track_metrics_figure">&#13;
<img alt="Spotify Million Platlist Dataset Experiments - Evaluation Track Recall" src="assets/brpj_1302.png"/>&#13;
<h6><span class="label">Figure 13-2. </span>Track recall experiments</h6>&#13;
</div></figure>&#13;
&#13;
<p>We started with the <code>mean_triplet_loss</code> and <code>reg_loss</code>, which is the regularization loss as a good baseline. These two losses simply make sure that the mean positive affinity of the context to the next track is one more than the negative affinity of the context to the negative tracks, and that the L2 norm of the embeddings does not exceed the regularization thresholds. These correspond to the metrics that did the worst. Notice that we do not run the experiment for the entire dataset. This is because for rapid iteration, it might be faster to just run on a smaller number of steps first and compare before interleaving occasionally with longer runs that use the entire dataset.</p>&#13;
&#13;
<p>The next loss we added was the <code>max_neg_affinity</code> and the <code>min_pos_affinity</code>.  This loss was inspired in part by <a href="https://oreil.ly/_aEF9">“Efficient Coordinate Descent or Ranking with Domination Loss”</a>  by Mark A. Stevens and <a href="https://oreil.ly/CPexf">“Learning to Rank Recommendations with the <em>k</em>-Order Statistic Loss”</a>  by Jason Weston et al. However, we do not use the entire negative set but merely a subsample. Why? Because the negative set is noisy. Just because a user hasn’t added a particular track to a playlist doesn’t mean that the track is not relevant to the playlist. Maybe the user hasn’t heard the track yet, so the noise is due to lack of exposure. We also do not do the sampling step as discussed in the <em>k</em>-order statistic loss paper because sampling is CPU friendly but not GPU friendly. So we combine ideas from both papers and take the largest negative affinity and make it one less than the smallest positive affinity. The addition of this loss on the extremal tracks from both the next and negative sets gave us the next boost in performance in our experiments.</p>&#13;
&#13;
<p>Finally, we added the self-affinity losses. These ensure that tracks from the context and next track sets have affinities of at least 0.5 and that the negative track affinities are at most 0. These are dot-product affinities and are more absolute as opposed to the relative positive and negative affinities that make the positive affinity one more than the negative affinities. In the long run, they didn’t help much, but they did help the model converge faster in the beginning. We left them in because they still offer some improvement on the evaluation metrics on the last training step. This wraps up the explanatory part of this “Putting It All Together” chapter. Now comes the fun part, the exercises!<a data-primary="" data-startref="RTspotify13" data-type="indexterm" id="id1092"/><a data-primary="" data-startref="SPEframing13" data-type="indexterm" id="id1093"/><a data-primary="" data-startref="LFframing13" data-type="indexterm" id="id1094"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="id227">&#13;
<h1>Exercises</h1>&#13;
&#13;
<p>We<a data-primary="JAX framework" data-secondary="experimentation exercises" data-type="indexterm" id="id1095"/><a data-primary="ranking training" data-secondary="experimentation exercises" data-type="indexterm" id="id1096"/> offer a lot of exercises because playing with the data and code is helpful in building out your intuition about different loss functions and ways of modeling the user. Also, thinking about how to write the code allows you to improve your proficiency with using JAX. So we have a list of helpful exercises to try out that are fun and will help you understand the material provided in this book.</p>&#13;
&#13;
<p>To wrap up this chapter, here are some interesting exercises to experiment with. Doing them should give you lots of intuition about loss functions and the way JAX works, as well as a feel for the experimental process.</p>&#13;
&#13;
<p>Here are some easy exercises to start with:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Try out different optimizers (e.g., ADAM, RMSPROP).</p>&#13;
</li>&#13;
<li>&#13;
<p>Try changing the feature sizes.</p>&#13;
</li>&#13;
<li>&#13;
<p>Add in duration as a feature (take care on normalization!).</p>&#13;
</li>&#13;
<li>&#13;
<p>What if you use cosine distance for inference and dot product for training?</p>&#13;
</li>&#13;
<li>&#13;
<p>Add in a new metric, like NDCG.</p>&#13;
</li>&#13;
<li>&#13;
<p>Play with distribution of positive versus negative affinities in the loss.</p>&#13;
</li>&#13;
<li>&#13;
<p>Hinge loss with the lowest next track and the highest negative track.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Continue exploring with these more difficult exercises:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Try using the track names as features and see if they help generalize.</p>&#13;
</li>&#13;
<li>&#13;
<p>What happens if you use a two-layer network for affinity?</p>&#13;
</li>&#13;
<li>&#13;
<p>What happens if you use an LSTM to compute affinity?</p>&#13;
</li>&#13;
<li>&#13;
<p>Replace track embeddings with correlation.</p>&#13;
</li>&#13;
<li>&#13;
<p>Compute all the self-affinities in a set.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id228">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>What<a data-primary="ranking training" data-secondary="overview of" data-type="indexterm" id="id1097"/> does it mean to replace an embedding with a feature? In our example of positive and negative affinity, we used the dot product to compute the affinity between two entities, such as two tracks, <math alttext="x">&#13;
  <mi>x</mi>&#13;
</math> and <math alttext="y">&#13;
  <mi>y</mi>&#13;
</math>. Rather than having the features as latent, represented by embeddings, an alternative is to manually construct features that represent the affinity between the two entities, <math alttext="x">&#13;
  <mi>x</mi>&#13;
</math> and <math alttext="y">&#13;
  <mi>y</mi>&#13;
</math>. As covered in <a data-type="xref" href="ch09.html#feature-counting">Chapter 9</a>, this can be log counts or Dice correlation coefficient or mutual information.</p>&#13;
&#13;
<p>Some kind of counting feature can be made and then stored in a database. Upon training and inference, the database is looked up for each entity <math alttext="x">&#13;
  <mi>x</mi>&#13;
</math> and <math alttext="y">&#13;
  <mi>y</mi>&#13;
</math>, and the affinity scores are then used instead of or in conjunction with the dot product that is being learned. These features tend to be more precise but have less recall than an embedding representation. The embedding representation, being of low rank, has the ability to generalize better and improve recall. Having counting features is synergistic with embedding features because we can simultaneously improve precision with the use of precise counting features and, at the same time, improve recall with the help of low-rank features like embeddings.</p>&#13;
&#13;
<p>For computing all <math alttext="n squared">&#13;
  <msup><mi>n</mi> <mn>2</mn> </msup>&#13;
</math> affinities of tracks to other tracks in a set, consider using JAX’s <code>vmap</code> function. <code>vmap</code> can be used to convert code that, for example, computes one track’s affinity with all the other tracks and makes it run for all tracks versus all other tracks.</p>&#13;
&#13;
<p>We hope that you have enjoyed playing with the data and code and that your skill in writing recommender systems in JAX has improved considerably after trying these exercises!</p>&#13;
</div></section>&#13;
</div></section></body></html>