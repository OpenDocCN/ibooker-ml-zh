<html><head></head><body><section data-pdf-bookmark="Chapter 13. Time Series Clustering" data-type="chapter" epub:type="chapter"><div class="chapter" id="Chapter_13">&#13;
<h1><span class="label">Chapter 13. </span>Time Series Clustering</h1>&#13;
&#13;
&#13;
<p>So<a data-primary="cross-sectional data" data-type="indexterm" id="idm140637524862800"/><a data-primary="unsupervised deep learning" data-secondary="time series clustering" data-type="indexterm" id="UDLtime13"/> far in this book, we have worked mostly with <em>cross-sectional data</em>, in which we have observations for entities at a single point in time. This includes the credit card dataset with transactions that happened over two days and the MNIST dataset with images of digits. For these datasets, we applied unsupervised learning to learn the underlying structure in the data and to group similar transactions and images together without using any labels.</p>&#13;
&#13;
<p>Unsupervised learning<a data-primary="time series clustering" data-secondary="time series data defined" data-type="indexterm" id="idm140637524859552"/> is also very valuable for work with <em>time series data</em>, in which we have observations for a single entity at different time intervals. We need to develop a solution that can learn the underlying structure of data across time, not just for a particular moment in time. If we develop such a solution, we can identify similar time series patterns and group them together.</p>&#13;
&#13;
<p>This<a data-primary="time series clustering" data-secondary="applications for" data-type="indexterm" id="idm140637524857312"/> is very impactful in fields such as finance, medicine, robotics, astronomy, biology, meteorology, etc., since professionals in these fields spend a lot of time analyzing data to classify current events based on how similar they are to past events. By grouping current events together with similar past events, these professionals are able to more confidently decide on the right course of action to take.</p>&#13;
&#13;
<p>In this chapter, we will work on clustering time series data based on pattern similarity. Clustering time series data is a purely unsupervised approach and does not require annotation of data for training, although annotated data is necessary for validating the results as with all other unsupervised learning experiments.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There<a data-primary="panel data" data-type="indexterm" id="idm140637524854032"/><a data-primary="longitudinal data" data-type="indexterm" id="idm140637524853296"/> is a third group of data that combines cross-sectional and time series data. This is known as <em>panel</em> or <em>longitudinal</em> data.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="ECG Data" data-type="sect1"><div class="sect1" id="idm140637524851296">&#13;
<h1>ECG Data</h1>&#13;
&#13;
<p>To<a data-primary="time series clustering" data-secondary="electrocardiogram (EKG/ECG) data" data-type="indexterm" id="idm140637524849696"/><a data-primary="k-means clustering" data-secondary="on time series data" data-secondary-sortas="time series data" data-type="indexterm" id="idm140637524848624"/> make the time series clustering problem more tangible, let’s introduce a specific real-world problem. Imagine we were working in healthcare and had to analyze electrocardiogram (EKG/ECG) readings. ECG machines record the electrical activity of the heart over a period of time using electrodes placed over the skin. The ECG measures activity over approximately 10 seconds, and the recorded metrics help detect any cardiac problems.</p>&#13;
&#13;
<p>Most ECG readings record normal heartbeat activity, but the abnormal readings are the ones healthcare professionals must identify to react preemptively before any adverse cardiac event—such as cardiac arrest—occurs. The ECG produces a line graph with peaks and valleys so the task of classifying a reading as normal or abnormal is a straightforward pattern recognition task, well suited for machine learning.</p>&#13;
&#13;
<p>Real-world ECG readings are not so cleanly displayed, making classification of the images into these various buckets difficult and error-prone.</p>&#13;
&#13;
<p>For example, variations in the <em>amplitude</em> of the waves (the height of the center line to the peak or trough), the <em>period</em> (the distance from one peak to the next), the <em>phase shift</em> (horizontal shifting), and the <em>vertical shift</em> are challenges for any machine-driven classification system.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Approach to Time Series Clustering" data-type="sect1"><div class="sect1" id="idm140637524843184">&#13;
<h1>Approach to Time Series Clustering</h1>&#13;
&#13;
<p>Any<a data-primary="time series clustering" data-secondary="approach to" data-type="indexterm" id="idm140637524841888"/> approach to time series clustering will require us to handle these types of distortions. As you may recall, clustering relies on distance measures to determine how close in space data is to other data so that similar data can be grouped together into distinct and homogeneous clusters.</p>&#13;
&#13;
<p>Clustering time series data works similarly, but we need a distance measure that is scale- and shift-invariant so that similar time series data is grouped together regardless of trivial differences in amplitude, period, phase shift, and vertical shift.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="k-Shape" data-type="sect2"><div class="sect2" id="idm140637524839664">&#13;
<h2>k-Shape</h2>&#13;
&#13;
<p>One<a data-primary="algorithms" data-secondary="k-shape" data-type="indexterm" id="idm140637524838096"/><a data-primary="k-shape algorithm" data-type="indexterm" id="idm140637524837088"/><a data-primary="Paparrizos, John" data-type="indexterm" id="idm140637524836416"/><a data-primary="Gravano, Luis" data-type="indexterm" id="idm140637524835744"/> of the state-of-the-art approaches to time series clustering that meets this criteria is <em>k-shape</em>, which was first introduced at ACM SIGMOD in 2015 by John Paparrizos and Luis Gravano.<sup><a data-type="noteref" href="ch13.html#idm140637524834352" id="idm140637524834352-marker">1</a></sup></p>&#13;
&#13;
<p><em>k</em>-shape uses a distance measure that is invariant to scaling and shifting to preserve the shapes of time series sequences while comparing them. Specifically, <em>k</em>-shape uses a normalized version of cross-correlation to compute cluster centroids and then, in every iteration, updates the assignment of time series to these clusters.</p>&#13;
&#13;
<p>In addition to being invariant to scaling and shifting, <em>k</em>-shape is domain-independent and scalable, requiring minimal parameter tuning. Its iterative refinement procedure scales linearly in the number of sequences. These characteristics have made it one of the most powerful time series clustering algorithms available today.</p>&#13;
&#13;
<p>By this point, it should be clear that <em>k</em>-shape operates similarly to <em>k</em>-means: both algorithms use an iterative approach to assign data to groups based on the distance between the data and the centroid of the nearest group. The critical difference is in how <em>k</em>-shape calculates distances—it uses shaped-based distance that relies on cross-correlations.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Time Series Clustering Using k-Shape on ECGFiveDays" data-type="sect1"><div class="sect1" id="idm140637524827888">&#13;
<h1>Time Series Clustering Using k-Shape on ECGFiveDays</h1>&#13;
&#13;
<p>Let’s<a data-primary="ECGFiveDays dataset" data-type="indexterm" id="ecgfive13"/><a data-primary="time series clustering" data-secondary="using k-shape on ECGFiveDays dataset" data-type="indexterm" id="TSCfive13"/> build a time series clustering model using <em>k</em>-shape.</p>&#13;
&#13;
<p>In<a data-primary="UCR Time Series website" data-type="indexterm" id="idm140637524823152"/> this chapter, we will rely on data from the UCR time series collection. Because the file size exceeds one hundred megabytes, it is not accessible on GitHub. You will need to download the files from the <a href="http://bit.ly/2CXPcfq">UCR Time Series website</a>.</p>&#13;
&#13;
<p>This is the largest public collection of class-labeled time series datasets, numbering—85 in total. These datasets are from multiple domains, so we can test how well our solution does across domains. Each time series belongs to only one class, so we also have labels to validate the results of our time series clustering.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Data Preparation" data-type="sect2"><div class="sect2" id="idm140637524820496">&#13;
<h2>Data Preparation</h2>&#13;
&#13;
<p>Let’s begin by loading the necessary libraries:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="sd">'''Main'''</code>&#13;
<code class="kn">import</code> <code class="nn">numpy</code> <code class="kn">as</code> <code class="nn">np</code>&#13;
<code class="kn">import</code> <code class="nn">pandas</code> <code class="kn">as</code> <code class="nn">pd</code>&#13;
<code class="kn">import</code> <code class="nn">os</code><code class="o">,</code> <code class="nn">time</code><code class="o">,</code> <code class="nn">re</code>&#13;
<code class="kn">import</code> <code class="nn">pickle</code><code class="o">,</code> <code class="nn">gzip</code><code class="o">,</code> <code class="nn">datetime</code>&#13;
<code class="kn">from</code> <code class="nn">os</code> <code class="kn">import</code> <code class="n">listdir</code><code class="p">,</code> <code class="n">walk</code>&#13;
<code class="kn">from</code> <code class="nn">os.path</code> <code class="kn">import</code> <code class="n">isfile</code><code class="p">,</code> <code class="n">join</code>&#13;
&#13;
<code class="sd">'''Data Viz'''</code>&#13;
<code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="kn">as</code> <code class="nn">plt</code>&#13;
<code class="kn">import</code> <code class="nn">seaborn</code> <code class="kn">as</code> <code class="nn">sns</code>&#13;
<code class="n">color</code> <code class="o">=</code> <code class="n">sns</code><code class="o">.</code><code class="n">color_palette</code><code class="p">()</code>&#13;
<code class="kn">import</code> <code class="nn">matplotlib</code> <code class="kn">as</code> <code class="nn">mpl</code>&#13;
<code class="kn">from</code> <code class="nn">mpl_toolkits.axes_grid1</code> <code class="kn">import</code> <code class="n">Grid</code>&#13;
&#13;
<code class="o">%</code><code class="n">matplotlib</code> <code class="n">inline</code>&#13;
&#13;
<code class="sd">'''Data Prep and Model Evaluation'''</code>&#13;
<code class="kn">from</code> <code class="nn">sklearn</code> <code class="kn">import</code> <code class="n">preprocessing</code> <code class="k">as</code> <code class="n">pp</code>&#13;
<code class="kn">from</code> <code class="nn">sklearn.model_selection</code> <code class="kn">import</code> <code class="n">train_test_split</code>&#13;
<code class="kn">from</code> <code class="nn">sklearn.model_selection</code> <code class="kn">import</code> <code class="n">StratifiedKFold</code>&#13;
<code class="kn">from</code> <code class="nn">sklearn.metrics</code> <code class="kn">import</code> <code class="n">log_loss</code><code class="p">,</code> <code class="n">accuracy_score</code>&#13;
<code class="kn">from</code> <code class="nn">sklearn.metrics</code> <code class="kn">import</code> <code class="n">precision_recall_curve</code><code class="p">,</code> <code class="n">average_precision_score</code>&#13;
<code class="kn">from</code> <code class="nn">sklearn.metrics</code> <code class="kn">import</code> <code class="n">roc_curve</code><code class="p">,</code> <code class="n">auc</code><code class="p">,</code> <code class="n">roc_auc_score</code><code class="p">,</code> <code class="n">mean_squared_error</code>&#13;
<code class="kn">from</code> <code class="nn">keras.utils</code> <code class="kn">import</code> <code class="n">to_categorical</code>&#13;
<code class="kn">from</code> <code class="nn">sklearn.metrics</code> <code class="kn">import</code> <code class="n">adjusted_rand_score</code>&#13;
<code class="kn">import</code> <code class="nn">random</code>&#13;
&#13;
<code class="sd">'''Algos'''</code>&#13;
<code class="kn">from</code> <code class="nn">kshape.core</code> <code class="kn">import</code> <code class="n">kshape</code><code class="p">,</code> <code class="n">zscore</code>&#13;
<code class="kn">import</code> <code class="nn">tslearn</code>&#13;
<code class="kn">from</code> <code class="nn">tslearn.utils</code> <code class="kn">import</code> <code class="n">to_time_series_dataset</code>&#13;
<code class="kn">from</code> <code class="nn">tslearn.clustering</code> <code class="kn">import</code> <code class="n">KShape</code><code class="p">,</code> <code class="n">TimeSeriesScalerMeanVariance</code>&#13;
<code class="kn">from</code> <code class="nn">tslearn.clustering</code> <code class="kn">import</code> <code class="n">TimeSeriesKMeans</code>&#13;
<code class="kn">import</code> <code class="nn">hdbscan</code>&#13;
&#13;
&#13;
<code class="sd">'''TensorFlow and Keras'''</code>&#13;
<code class="kn">import</code> <code class="nn">tensorflow</code> <code class="kn">as</code> <code class="nn">tf</code>&#13;
<code class="kn">import</code> <code class="nn">keras</code>&#13;
<code class="kn">from</code> <code class="nn">keras</code> <code class="kn">import</code> <code class="n">backend</code> <code class="k">as</code> <code class="n">K</code>&#13;
<code class="kn">from</code> <code class="nn">keras.models</code> <code class="kn">import</code> <code class="n">Sequential</code><code class="p">,</code> <code class="n">Model</code>&#13;
<code class="kn">from</code> <code class="nn">keras.layers</code> <code class="kn">import</code> <code class="n">Activation</code><code class="p">,</code> <code class="n">Dense</code><code class="p">,</code> <code class="n">Dropout</code><code class="p">,</code> <code class="n">Flatten</code><code class="p">,</code> <code class="n">Conv2D</code><code class="p">,</code> <code class="n">MaxPool2D</code>&#13;
<code class="kn">from</code> <code class="nn">keras.layers</code> <code class="kn">import</code> <code class="n">LeakyReLU</code><code class="p">,</code> <code class="n">Reshape</code><code class="p">,</code> <code class="n">UpSampling2D</code><code class="p">,</code> <code class="n">Conv2DTranspose</code>&#13;
<code class="kn">from</code> <code class="nn">keras.layers</code> <code class="kn">import</code> <code class="n">BatchNormalization</code><code class="p">,</code> <code class="n">Input</code><code class="p">,</code> <code class="n">Lambda</code>&#13;
<code class="kn">from</code> <code class="nn">keras.layers</code> <code class="kn">import</code> <code class="n">Embedding</code><code class="p">,</code> <code class="n">Flatten</code><code class="p">,</code> <code class="n">dot</code>&#13;
<code class="kn">from</code> <code class="nn">keras</code> <code class="kn">import</code> <code class="n">regularizers</code>&#13;
<code class="kn">from</code> <code class="nn">keras.losses</code> <code class="kn">import</code> <code class="n">mse</code><code class="p">,</code> <code class="n">binary_crossentropy</code>&#13;
<code class="kn">from</code> <code class="nn">IPython.display</code> <code class="kn">import</code> <code class="n">SVG</code>&#13;
<code class="kn">from</code> <code class="nn">keras.utils.vis_utils</code> <code class="kn">import</code> <code class="n">model_to_dot</code>&#13;
<code class="kn">from</code> <code class="nn">keras.optimizers</code> <code class="kn">import</code> <code class="n">Adam</code><code class="p">,</code> <code class="n">RMSprop</code>&#13;
<code class="kn">from</code> <code class="nn">tensorflow.examples.tutorials.mnist</code> <code class="kn">import</code> <code class="n">input_data</code></pre>&#13;
&#13;
<p>We<a data-primary="tslearn package" data-type="indexterm" id="idm140637525011632"/> will use the <em>tslearn</em> package to access the Python-based <em>k</em>-shape algorithm. tslearn has a similar framework as Scikit-learn but is geared toward work with time series data.</p>&#13;
&#13;
<p>Next, let’s load the training and test data from the <code>ECGFiveDays</code> dataset, which was downloaded from the UCR Time Series archive. The first column in this matrix has the class labels, while the rest of the columns are the values of the time series data. We will store the data as <code>X_train</code>, <code>y_train</code>, <code>X_test</code>, and <code>y_test</code>:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Load the datasets</code>&#13;
<code class="n">current_path</code> <code class="o">=</code> <code class="n">os</code><code class="o">.</code><code class="n">getcwd</code><code class="p">()</code>&#13;
<code class="nb">file</code> <code class="o">=</code> <code class="s1">'</code><code class="se">\\</code><code class="s1">datasets</code><code class="se">\\</code><code class="s1">ucr_time_series_data</code><code class="se">\\</code><code class="s1">'</code>&#13;
<code class="n">data_train</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">loadtxt</code><code class="p">(</code><code class="n">current_path</code><code class="o">+</code><code class="nb">file</code><code class="o">+</code>&#13;
                        <code class="s2">"ECGFiveDays/ECGFiveDays_TRAIN"</code><code class="p">,</code>&#13;
                        <code class="n">delimiter</code><code class="o">=</code><code class="s2">","</code><code class="p">)</code>&#13;
<code class="n">X_train</code> <code class="o">=</code> <code class="n">to_time_series_dataset</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">:])</code>&#13;
<code class="n">y_train</code> <code class="o">=</code> <code class="n">data_train</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">int</code><code class="p">)</code>&#13;
&#13;
<code class="n">data_test</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">loadtxt</code><code class="p">(</code><code class="n">current_path</code><code class="o">+</code><code class="nb">file</code><code class="o">+</code>&#13;
                       <code class="s2">"ECGFiveDays/ECGFiveDays_TEST"</code><code class="p">,</code>&#13;
                       <code class="n">delimiter</code><code class="o">=</code><code class="s2">","</code><code class="p">)</code>&#13;
<code class="n">X_test</code> <code class="o">=</code> <code class="n">to_time_series_dataset</code><code class="p">(</code><code class="n">data_test</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">:])</code>&#13;
<code class="n">y_test</code> <code class="o">=</code> <code class="n">data_test</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">int</code><code class="p">)</code></pre>&#13;
&#13;
<p>The following code shows the number of time series, the number of unique classes, and the length of each time series:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Basic summary statistics</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Number of time series:"</code><code class="p">,</code> <code class="nb">len</code><code class="p">(</code><code class="n">data_train</code><code class="p">))</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Number of unique classes:"</code><code class="p">,</code> <code class="nb">len</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">unique</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">])))</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Time series length:"</code><code class="p">,</code> <code class="nb">len</code><code class="p">(</code><code class="n">data_train</code><code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="mi">1</code><code class="p">:]))</code></pre>&#13;
&#13;
<pre data-type="programlisting">Number of time series: 23&#13;
Number of unique classes: 2&#13;
Time series length: 136</pre>&#13;
&#13;
<p>There are 23 time series and 2 unique classes, and each time series has a length of 136. <a data-type="xref" href="#ecg_five_days_class_1_0_first_two_examples">Figure 13-1</a> shows a few examples of each class; now we know what these ECG readings look like:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Examples of Class 1.0</code>&#13;
<code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">10</code><code class="p">):</code>&#13;
    <code class="k">if</code> <code class="n">data_train</code><code class="p">[</code><code class="n">i</code><code class="p">,</code><code class="mi">0</code><code class="p">]</code><code class="o">==</code><code class="mf">1.0</code><code class="p">:</code>&#13;
        <code class="k">print</code><code class="p">(</code><code class="s2">"Plot "</code><code class="p">,</code><code class="n">i</code><code class="p">,</code><code class="s2">" Class "</code><code class="p">,</code><code class="n">data_train</code><code class="p">[</code><code class="n">i</code><code class="p">,</code><code class="mi">0</code><code class="p">])</code>&#13;
        <code class="n">plt</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">data_train</code><code class="p">[</code><code class="n">i</code><code class="p">])</code>&#13;
        <code class="n">plt</code><code class="o">.</code><code class="n">show</code><code class="p">()</code></pre>&#13;
&#13;
<figure class="width-50"><div class="figure" id="ecg_five_days_class_1_0_first_two_examples">&#13;
<img alt="ECG Five Days Class 1.0 - First Two Examples" src="assets/hulp_1301.png"/>&#13;
<h6><span class="label">Figure 13-1. </span>ECGFiveDays class 1.0—first two examples</h6>&#13;
</div></figure>&#13;
&#13;
<figure class="width-50"><div class="figure">&#13;
<img alt="ECG Five Days Class 1.0 - Second Two Examples" src="assets/hulp_1302.png"/>&#13;
<h6><span class="label">Figure 13-2. </span>ECGFiveDays class 1.0—second two examples</h6>&#13;
</div></figure>&#13;
&#13;
<p>Here is the code to plot results from <code>Class 2.0</code>:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Examples of Class 2.0</code>&#13;
<code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">10</code><code class="p">):</code>&#13;
    <code class="k">if</code> <code class="n">data_train</code><code class="p">[</code><code class="n">i</code><code class="p">,</code><code class="mi">0</code><code class="p">]</code><code class="o">==</code><code class="mf">2.0</code><code class="p">:</code>&#13;
        <code class="k">print</code><code class="p">(</code><code class="s2">"Plot "</code><code class="p">,</code><code class="n">i</code><code class="p">,</code><code class="s2">" Class "</code><code class="p">,</code><code class="n">data_train</code><code class="p">[</code><code class="n">i</code><code class="p">,</code><code class="mi">0</code><code class="p">])</code>&#13;
        <code class="n">plt</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">data_train</code><code class="p">[</code><code class="n">i</code><code class="p">])</code>&#13;
        <code class="n">plt</code><code class="o">.</code><code class="n">show</code><code class="p">()</code></pre>&#13;
&#13;
<figure class="width-50"><div class="figure">&#13;
<img alt="ECG Five Days Class 2.0 - First Two Examples" src="assets/hulp_1303.png"/>&#13;
<h6><span class="label">Figure 13-3. </span>ECGFiveDays class 2.0—first two examples</h6>&#13;
</div></figure>&#13;
&#13;
<figure class="width-50"><div class="figure">&#13;
<img alt="ECG Five Days Class 2.0 - Second Two Examples" src="assets/hulp_1304.png"/>&#13;
<h6><span class="label">Figure 13-4. </span>ECGFiveDays class 2.0—second two examples</h6>&#13;
</div></figure>&#13;
&#13;
<p>To the naked, untrained eye, the examples from class 1.0 and class 2.0 seem indistinguishable, but these observations have been annotated by domain experts. The plots are noisy with distortions. There are also differences in amplitude, period, phase shift, and vertical shift that make classification a challenge.</p>&#13;
&#13;
<p>Let’s prepare the data for the <em>k</em>-shape algorithm. We will normalize the data to have a mean of zero and standard deviation of one:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Prepare the data - Scale</code>&#13;
<code class="n">X_train</code> <code class="o">=</code> <code class="n">TimeSeriesScalerMeanVariance</code><code class="p">(</code><code class="n">mu</code><code class="o">=</code><code class="mf">0.</code><code class="p">,</code> <code class="n">std</code><code class="o">=</code><code class="mf">1.</code><code class="p">)</code><code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code>&#13;
<code class="n">X_test</code> <code class="o">=</code> <code class="n">TimeSeriesScalerMeanVariance</code><code class="p">(</code><code class="n">mu</code><code class="o">=</code><code class="mf">0.</code><code class="p">,</code> <code class="n">std</code><code class="o">=</code><code class="mf">1.</code><code class="p">)</code><code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">X_test</code><code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Training and Evaluation" data-type="sect2"><div class="sect2" id="idm140637524225424">&#13;
<h2>Training and Evaluation</h2>&#13;
&#13;
<p>Next, we will call the <em>k</em>-shape algorithm and set the number of clusters as 2, the max iterations to perform as one hundred, and the number of rounds of training as one hundred:<sup><a data-type="noteref" href="ch13.html#idm140637523748448" id="idm140637523748448-marker">2</a></sup></p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Train using k-Shape</code>&#13;
<code class="n">ks</code> <code class="o">=</code> <code class="n">KShape</code><code class="p">(</code><code class="n">n_clusters</code><code class="o">=</code><code class="mi">2</code><code class="p">,</code> <code class="n">max_iter</code><code class="o">=</code><code class="mi">100</code><code class="p">,</code> <code class="n">n_init</code><code class="o">=</code><code class="mi">100</code><code class="p">,</code><code class="n">verbose</code><code class="o">=</code><code class="mi">0</code><code class="p">)</code>&#13;
<code class="n">ks</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code></pre>&#13;
&#13;
<p>To<a data-primary="adjusted Rand index" data-type="indexterm" id="idm140637523730048"/> measure the goodness of the time series clustering, we will use the <em>adjusted Rand index</em>, a measure of the similarity between two data clusterings adjusted for the chance grouping of elements. This is related to the accuracy measure.<sup><a data-type="noteref" href="ch13.html#idm140637523728768" id="idm140637523728768-marker">3</a></sup></p>&#13;
&#13;
<p>Intuitively, the Rand index measures the number of agreements in cluster assignments between the predicted clusterings and the true clusterings. If the model has an adjusted Rand index with a value close to 0.0, it is purely randomly assigning clusters; if the model has an adjusted Rand index with a value close to 1.0, the predicted clusterings match the true clusterings exactly.</p>&#13;
&#13;
<p>We will use the Scikit-learn implementation of the adjusted Rand index called the <em>adjusted_rand_score</em>.</p>&#13;
&#13;
<p>Let’s generate clustering predictions and then calculate the adjusted Rand index:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Make predictions and calculate adjusted Rand index</code>&#13;
<code class="n">preds</code> <code class="o">=</code> <code class="n">ks</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code>&#13;
<code class="n">ars</code> <code class="o">=</code> <code class="n">adjusted_rand_score</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">],</code><code class="n">preds</code><code class="p">)</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Adjusted Rand Index:"</code><code class="p">,</code> <code class="n">ars</code><code class="p">)</code></pre>&#13;
&#13;
<p>Based on this run, the adjusted Rand index is 0.668. If you perform this training and prediction several times, you will notice the adjusted Rand index will vary a bit but remains well above 0.0 at all times:</p>&#13;
&#13;
<pre data-type="programlisting">Adjusted Rand Index: 0.668041237113402</pre>&#13;
&#13;
<p>Let’s predict on the test set and calculate the adjusted Rand index for it:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Make predictions on test set and calculate adjusted Rand index</code>&#13;
<code class="n">preds_test</code> <code class="o">=</code> <code class="n">ks</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">X_test</code><code class="p">)</code>&#13;
<code class="n">ars</code> <code class="o">=</code> <code class="n">adjusted_rand_score</code><code class="p">(</code><code class="n">data_test</code><code class="p">[:,</code><code class="mi">0</code><code class="p">],</code><code class="n">preds_test</code><code class="p">)</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Adjusted Rand Index on Test Set:"</code><code class="p">,</code> <code class="n">ars</code><code class="p">)</code></pre>&#13;
&#13;
<p>The adjusted Rand index is considerably lower on the test set, barely above 0. The cluster predictions are nearly chance assignments—the time series are being grouped based on similarity with little success:</p>&#13;
&#13;
<pre data-type="programlisting">Adjusted Rand Index on Test Set: 0.0006332050676187496</pre>&#13;
&#13;
<p>If we had a much larger training set to train our <em>k</em>-shape-based time series clustering model, we would expect better performance on the test set.<a data-primary="" data-startref="TSCfive13" data-type="indexterm" id="idm140637523615088"/><a data-primary="" data-startref="ecgfive13" data-type="indexterm" id="idm140637523614144"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Time Series Clustering Using k-Shape on ECG5000" data-type="sect1"><div class="sect1" id="idm140637525021728">&#13;
<h1>Time Series Clustering Using k-Shape on ECG5000</h1>&#13;
&#13;
<p>Instead<a data-primary="time series clustering" data-secondary="using k-shape on ECG5000 dataset" data-type="indexterm" id="TSC50013"/><a data-primary="ECG5000 dataset" data-type="indexterm" id="ecg500013"/> of the <code>ECGFiveDays</code> dataset, which has only 23 observations in the training set and 861 in the test set, let’s use a much larger dataset of ECG readings. The <code>ECG5000</code> dataset (also available on the UCR Time Series archive) has five thousand ECG readings (i.e., time series) in total across the train and test sets.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Data Preparation" data-type="sect2"><div class="sect2" id="idm140637523634544">&#13;
<h2>Data Preparation</h2>&#13;
&#13;
<p>We will load in the datasets and make our own train and test split, with 80% of the five thousand readings in the custom train set and the remaining 20% in the custom test set. With this much larger training set, we should be able to develop a time series clustering model that has much better performance, both on the train set and, most importantly, on the test set:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Load the datasets</code>&#13;
<code class="n">current_path</code> <code class="o">=</code> <code class="n">os</code><code class="o">.</code><code class="n">getcwd</code><code class="p">()</code>&#13;
<code class="nb">file</code> <code class="o">=</code> <code class="s1">'</code><code class="se">\\</code><code class="s1">datasets</code><code class="se">\\</code><code class="s1">ucr_time_series_data</code><code class="se">\\</code><code class="s1">'</code>&#13;
<code class="n">data_train</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">loadtxt</code><code class="p">(</code><code class="n">current_path</code><code class="o">+</code><code class="nb">file</code><code class="o">+</code>&#13;
                        <code class="s2">"ECG5000/ECG5000_TRAIN"</code><code class="p">,</code>&#13;
                        <code class="n">delimiter</code><code class="o">=</code><code class="s2">","</code><code class="p">)</code>&#13;
&#13;
<code class="n">data_test</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">loadtxt</code><code class="p">(</code><code class="n">current_path</code><code class="o">+</code><code class="nb">file</code><code class="o">+</code>&#13;
                       <code class="s2">"ECG5000/ECG5000_TEST"</code><code class="p">,</code>&#13;
                       <code class="n">delimiter</code><code class="o">=</code><code class="s2">","</code><code class="p">)</code>&#13;
&#13;
<code class="n">data_joined</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">concatenate</code><code class="p">((</code><code class="n">data_train</code><code class="p">,</code><code class="n">data_test</code><code class="p">),</code><code class="n">axis</code><code class="o">=</code><code class="mi">0</code><code class="p">)</code>&#13;
<code class="n">data_train</code><code class="p">,</code> <code class="n">data_test</code> <code class="o">=</code> <code class="n">train_test_split</code><code class="p">(</code><code class="n">data_joined</code><code class="p">,</code>&#13;
                                    <code class="n">test_size</code><code class="o">=</code><code class="mf">0.20</code><code class="p">,</code> <code class="n">random_state</code><code class="o">=</code><code class="mi">2019</code><code class="p">)</code>&#13;
&#13;
<code class="n">X_train</code> <code class="o">=</code> <code class="n">to_time_series_dataset</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">:])</code>&#13;
<code class="n">y_train</code> <code class="o">=</code> <code class="n">data_train</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">int</code><code class="p">)</code>&#13;
<code class="n">X_test</code> <code class="o">=</code> <code class="n">to_time_series_dataset</code><code class="p">(</code><code class="n">data_test</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">:])</code>&#13;
<code class="n">y_test</code> <code class="o">=</code> <code class="n">data_test</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">int</code><code class="p">)</code></pre>&#13;
&#13;
<p>Let’s explore this dataset:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Summary statistics</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Number of time series:"</code><code class="p">,</code> <code class="nb">len</code><code class="p">(</code><code class="n">data_train</code><code class="p">))</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Number of unique classes:"</code><code class="p">,</code> <code class="nb">len</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">unique</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">])))</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Time series length:"</code><code class="p">,</code> <code class="nb">len</code><code class="p">(</code><code class="n">data_train</code><code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="mi">1</code><code class="p">:]))</code></pre>&#13;
&#13;
<p>The following code displays the basic summary statistics. There are four thousand readings in the training set, which are grouped into five distinct classes, and each time series has a length of 140:</p>&#13;
&#13;
<pre data-type="programlisting">Number of time series: 4000&#13;
Number of unique classes: 5&#13;
Time series length: 140</pre>&#13;
&#13;
<p>Let’s also consider how many of the readings belong to each of these classes.</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Calculate number of readings per class</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Number of time series in class 1.0:"</code><code class="p">,</code>&#13;
      <code class="nb">len</code><code class="p">(</code><code class="n">data_train</code><code class="p">[</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">]</code><code class="o">==</code><code class="mf">1.0</code><code class="p">]))</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Number of time series in class 2.0:"</code><code class="p">,</code>&#13;
      <code class="nb">len</code><code class="p">(</code><code class="n">data_train</code><code class="p">[</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">]</code><code class="o">==</code><code class="mf">2.0</code><code class="p">]))</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Number of time series in class 3.0:"</code><code class="p">,</code>&#13;
      <code class="nb">len</code><code class="p">(</code><code class="n">data_train</code><code class="p">[</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">]</code><code class="o">==</code><code class="mf">3.0</code><code class="p">]))</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Number of time series in class 4.0:"</code><code class="p">,</code>&#13;
      <code class="nb">len</code><code class="p">(</code><code class="n">data_train</code><code class="p">[</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">]</code><code class="o">==</code><code class="mf">4.0</code><code class="p">]))</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Number of time series in class 5.0:"</code><code class="p">,</code>&#13;
      <code class="nb">len</code><code class="p">(</code><code class="n">data_train</code><code class="p">[</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">]</code><code class="o">==</code><code class="mf">5.0</code><code class="p">]))</code></pre>&#13;
&#13;
<p>The distribution is shown in <a data-type="xref" href="#ecg_5000_class_1_0">Figure 13-5</a>. Most of the readings fall in class 1, followed by class 2. Significantly fewer readings belong to clases 3, 4, and 5.</p>&#13;
&#13;
<p>Let’s take the average time series reading from each class to get a better sense of how the various classes look.</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Display readings from each class</code>&#13;
<code class="k">for</code> <code class="n">j</code> <code class="ow">in</code> <code class="n">np</code><code class="o">.</code><code class="n">unique</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">]):</code>&#13;
    <code class="n">dataPlot</code> <code class="o">=</code> <code class="n">data_train</code><code class="p">[</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">]</code><code class="o">==</code><code class="n">j</code><code class="p">]</code>&#13;
    <code class="n">cnt</code> <code class="o">=</code> <code class="nb">len</code><code class="p">(</code><code class="n">dataPlot</code><code class="p">)</code>&#13;
    <code class="n">dataPlot</code> <code class="o">=</code> <code class="n">dataPlot</code><code class="p">[:,</code><code class="mi">1</code><code class="p">:]</code><code class="o">.</code><code class="n">mean</code><code class="p">(</code><code class="n">axis</code><code class="o">=</code><code class="mi">0</code><code class="p">)</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="s2">" Class "</code><code class="p">,</code><code class="n">j</code><code class="p">,</code><code class="s2">" Count "</code><code class="p">,</code><code class="n">cnt</code><code class="p">)</code>&#13;
    <code class="n">plt</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">dataPlot</code><code class="p">)</code>&#13;
    <code class="n">plt</code><code class="o">.</code><code class="n">show</code><code class="p">()</code></pre>&#13;
&#13;
<p>Class 1 (<a data-type="xref" href="#ecg_5000_class_1_0">Figure 13-5</a>) has a sharp trough followed by a sharp peak and stabilization. This is the most common type of reading.</p>&#13;
&#13;
<figure><div class="figure" id="ecg_5000_class_1_0">&#13;
<img alt="ECG 5000 Class 1.0" src="assets/hulp_1305.png"/>&#13;
<h6><span class="label">Figure 13-5. </span>ECG5000 class 1.0</h6>&#13;
</div></figure>&#13;
&#13;
<p>Class 2 (<a data-type="xref" href="#ecg_5000_class_2_0">Figure 13-6</a>) has a sharp trough followed by a recovery and then an even sharper and lower trough with a partial recovery. This is the second most common type of reading.</p>&#13;
&#13;
<figure><div class="figure" id="ecg_5000_class_2_0">&#13;
<img alt="ECG 5000 Class 2.0" src="assets/hulp_1306.png"/>&#13;
<h6><span class="label">Figure 13-6. </span>ECG5000 class 2.0</h6>&#13;
</div></figure>&#13;
&#13;
<p>Class 3 (<a data-type="xref" href="#ecg_5000_class_3_0">Figure 13-7</a>) has a sharp trough followed by a recovery and then an even sharper and lower trough with no recovery. There are a few examples of these in the dataset.</p>&#13;
&#13;
<figure><div class="figure" id="ecg_5000_class_3_0">&#13;
<img alt="ECG 5000 Class 3.0" src="assets/hulp_1307.png"/>&#13;
<h6><span class="label">Figure 13-7. </span>ECG5000 class 3.0</h6>&#13;
</div></figure>&#13;
&#13;
<p>Class 4 (<a data-type="xref" href="#ecg_5000_class_4_0">Figure 13-8</a>) has a sharp trough followed by a recovery and then a shallow trough and stabilization. There are a few examples of these in the dataset.</p>&#13;
&#13;
<figure><div class="figure" id="ecg_5000_class_4_0">&#13;
<img alt="ECG 5000 Class 4.0" src="assets/hulp_1308.png"/>&#13;
<h6><span class="label">Figure 13-8. </span>ECG5000 class 4.0</h6>&#13;
</div></figure>&#13;
&#13;
<p>Class 5 (<a data-type="xref" href="#ecg_5000_class_5_0">Figure 13-9</a>) has a sharp trough followed by an uneven recovery, a peak, and then an unsteady decline to a shallow trough. There are very few examples of these in the dataset.</p>&#13;
&#13;
<figure><div class="figure" id="ecg_5000_class_5_0">&#13;
<img alt="ECG 5000 Class 5.0" src="assets/hulp_1309.png"/>&#13;
<h6><span class="label">Figure 13-9. </span>ECG5000 class 5.0</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Training and Evaluation" data-type="sect2"><div class="sect2" id="idm140637523633600">&#13;
<h2>Training and Evaluation</h2>&#13;
&#13;
<p>As<a data-primary="k-shape algorithm" data-type="indexterm" id="idm140637523086304"/><a data-primary="algorithms" data-secondary="k-shape" data-type="indexterm" id="idm140637523085568"/> before, let’s normalize the data to have a mean of zero and standard deviation of one. Then, we will fit the <em>k</em>-shape algorithm, setting the number of clusters to five this time. Everything else remains the same:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Prepare data - Scale</code>&#13;
<code class="n">X_train</code> <code class="o">=</code> <code class="n">TimeSeriesScalerMeanVariance</code><code class="p">(</code><code class="n">mu</code><code class="o">=</code><code class="mf">0.</code><code class="p">,</code> <code class="n">std</code><code class="o">=</code><code class="mf">1.</code><code class="p">)</code><code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code>&#13;
<code class="n">X_test</code> <code class="o">=</code> <code class="n">TimeSeriesScalerMeanVariance</code><code class="p">(</code><code class="n">mu</code><code class="o">=</code><code class="mf">0.</code><code class="p">,</code> <code class="n">std</code><code class="o">=</code><code class="mf">1.</code><code class="p">)</code><code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">X_test</code><code class="p">)</code>&#13;
&#13;
<code class="c1"># Train using k-Shape</code>&#13;
<code class="n">ks</code> <code class="o">=</code> <code class="n">KShape</code><code class="p">(</code><code class="n">n_clusters</code><code class="o">=</code><code class="mi">5</code><code class="p">,</code> <code class="n">max_iter</code><code class="o">=</code><code class="mi">100</code><code class="p">,</code> <code class="n">n_init</code><code class="o">=</code><code class="mi">10</code><code class="p">,</code><code class="n">verbose</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code><code class="n">random_state</code><code class="o">=</code><code class="mi">2019</code><code class="p">)</code>&#13;
<code class="n">ks</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code></pre>&#13;
&#13;
<p>Let’s evaluate the results on the training set:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Predict on train set and calculate adjusted Rand index</code>&#13;
<code class="n">preds</code> <code class="o">=</code> <code class="n">ks</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code>&#13;
<code class="n">ars</code> <code class="o">=</code> <code class="n">adjusted_rand_score</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">],</code><code class="n">preds</code><code class="p">)</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Adjusted Rand Index on Training Set:"</code><code class="p">,</code> <code class="n">ars</code><code class="p">)</code></pre>&#13;
&#13;
<p>The<a data-primary="adjusted Rand index" data-type="indexterm" id="idm140637523048704"/> following code shows the adjusted Rand index on the training set. It is considerably stronger at 0.75:</p>&#13;
&#13;
<pre data-type="programlisting">Adjusted Rand Index on Training Set: 0.7499312374127193</pre>&#13;
&#13;
<p>Let’s evaluate the results on the test set, too:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Predict on test set and calculate adjusted Rand index</code>&#13;
<code class="n">preds_test</code> <code class="o">=</code> <code class="n">ks</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">X_test</code><code class="p">)</code>&#13;
<code class="n">ars</code> <code class="o">=</code> <code class="n">adjusted_rand_score</code><code class="p">(</code><code class="n">data_test</code><code class="p">[:,</code><code class="mi">0</code><code class="p">],</code><code class="n">preds_test</code><code class="p">)</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Adjusted Rand Index on Test Set:"</code><code class="p">,</code> <code class="n">ars</code><code class="p">)</code></pre>&#13;
&#13;
<p>The adjusted Rand index on the test set is much higher, too. It is 0.72:</p>&#13;
&#13;
<pre data-type="programlisting">Adjusted Rand Index on Test Set: 0.7172302400677499</pre>&#13;
&#13;
<p>By increasing the training set to four thousand time series (from 23), we have a considerably better-performing time series clustering model.</p>&#13;
&#13;
<p>Let’s explore the predicted clusters some more to see just how homogeneous they are. For each predicted cluster, we will evaluate the distribution of true labels. If the clusters are well-defined and homogeneous, most of the readings in each cluster should have the same true label:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Evaluate goodness of the clusters</code>&#13;
<code class="n">preds_test</code> <code class="o">=</code> <code class="n">preds_test</code><code class="o">.</code><code class="n">reshape</code><code class="p">(</code><code class="mi">1000</code><code class="p">,</code><code class="mi">1</code><code class="p">)</code>&#13;
<code class="n">preds_test</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">hstack</code><code class="p">((</code><code class="n">preds_test</code><code class="p">,</code><code class="n">data_test</code><code class="p">[:,</code><code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">reshape</code><code class="p">(</code><code class="mi">1000</code><code class="p">,</code><code class="mi">1</code><code class="p">)))</code>&#13;
<code class="n">preds_test</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">data</code><code class="o">=</code><code class="n">preds_test</code><code class="p">)</code>&#13;
<code class="n">preds_test</code> <code class="o">=</code> <code class="n">preds_test</code><code class="o">.</code><code class="n">rename</code><code class="p">(</code><code class="n">columns</code><code class="o">=</code><code class="p">{</code><code class="mi">0</code><code class="p">:</code> <code class="s1">'prediction'</code><code class="p">,</code> <code class="mi">1</code><code class="p">:</code> <code class="s1">'actual'</code><code class="p">})</code>&#13;
&#13;
<code class="n">counter</code> <code class="o">=</code> <code class="mi">0</code>&#13;
<code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="n">np</code><code class="o">.</code><code class="n">sort</code><code class="p">(</code><code class="n">preds_test</code><code class="o">.</code><code class="n">prediction</code><code class="o">.</code><code class="n">unique</code><code class="p">()):</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="s2">"Predicted Cluster "</code><code class="p">,</code> <code class="n">i</code><code class="p">)</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="n">preds_test</code><code class="o">.</code><code class="n">actual</code><code class="p">[</code><code class="n">preds_test</code><code class="o">.</code><code class="n">prediction</code><code class="o">==</code><code class="n">i</code><code class="p">]</code><code class="o">.</code><code class="n">value_counts</code><code class="p">())</code>&#13;
    <code class="k">print</code><code class="p">()</code>&#13;
    <code class="n">cnt</code> <code class="o">=</code> <code class="n">preds_test</code><code class="o">.</code><code class="n">actual</code><code class="p">[</code><code class="n">preds_test</code><code class="o">.</code><code class="n">prediction</code><code class="o">==</code><code class="n">i</code><code class="p">]</code> \&#13;
                        <code class="o">.</code><code class="n">value_counts</code><code class="p">()</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="mi">1</code><code class="p">:]</code><code class="o">.</code><code class="n">sum</code><code class="p">()</code>&#13;
    <code class="n">counter</code> <code class="o">=</code> <code class="n">counter</code> <code class="o">+</code> <code class="n">cnt</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Count of Non-Primary Points: "</code><code class="p">,</code> <code class="n">counter</code><code class="p">)</code></pre>&#13;
&#13;
<p>The following code displays the homogeneity of the clusters:</p>&#13;
&#13;
<pre data-type="programlisting">ECG 5000 k-shape predicted cluster analysis&#13;
&#13;
Predicted Cluster 0.0&#13;
    2.0   29&#13;
    4.0   2&#13;
    1.0   2&#13;
    3.0   2&#13;
    5.0   1&#13;
    Name: actual, dtype: int64&#13;
&#13;
Predicted Cluster 1.0&#13;
    2.0   270&#13;
    4.0   14&#13;
    3.0   8&#13;
    1.0   2&#13;
    5.0   1&#13;
    Name: actual, dtype: int64&#13;
&#13;
Predicted Cluster 2.0&#13;
    1.0   553&#13;
    4.0   16&#13;
    2.0   9&#13;
    3.0   7&#13;
    Name: actual, dtype: int64&#13;
&#13;
Predicted Cluster 3.0&#13;
    2.0   35&#13;
    1.0   5&#13;
    4.0   5&#13;
    5.0   3&#13;
    3.0   3&#13;
    Name: actual, dtype: int64&#13;
&#13;
Predicted Cluster 4.0&#13;
    1.0   30&#13;
    4.0   1&#13;
    3.0   1&#13;
    2.0   1&#13;
    Name: actual, dtype: int64&#13;
&#13;
Count of Non-Primary Points: 83</pre>&#13;
&#13;
<p>The majority of the readings within each predicted cluster belong to just one true label class. This highlights just how well defined and homogeneous the <em>k</em>-shape-derived clusters are.<a data-primary="" data-startref="TSC50013" data-type="indexterm" id="idm140637522823536"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Time Series Clustering Using k-Means on ECG5000" data-type="sect1"><div class="sect1" id="idm140637522822576">&#13;
<h1>Time Series Clustering Using k-Means on ECG5000</h1>&#13;
&#13;
<p>For<a data-primary="time series clustering" data-secondary="using k-means on ECG5000 dataset" data-type="indexterm" id="idm140637522820848"/> the sake of completeness, let’s compare the results of <em>k</em>-shape with results from <em>k</em>-means. We<a data-primary="tslearn package" data-type="indexterm" id="idm140637522818896"/> will use the <em>tslearn</em> library to perform the training and evaluate using the adjusted Rand index as before.</p>&#13;
&#13;
<p>We will set the number of clusters as five, the number of max iterations for a single run as one hundred, the number of independent runs as one hundred, the metric distance as Euclidean, and the random state as 2019:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Train using Time Series k-Means</code>&#13;
<code class="n">km</code> <code class="o">=</code> <code class="n">TimeSeriesKMeans</code><code class="p">(</code><code class="n">n_clusters</code><code class="o">=</code><code class="mi">5</code><code class="p">,</code> <code class="n">max_iter</code><code class="o">=</code><code class="mi">100</code><code class="p">,</code> <code class="n">n_init</code><code class="o">=</code><code class="mi">100</code><code class="p">,</code> \&#13;
                      <code class="n">metric</code><code class="o">=</code><code class="s2">"euclidean"</code><code class="p">,</code> <code class="n">verbose</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code> <code class="n">random_state</code><code class="o">=</code><code class="mi">2019</code><code class="p">)</code>&#13;
<code class="n">km</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code>&#13;
&#13;
<code class="c1"># Predict on training set and evaluate using adjusted Rand index</code>&#13;
<code class="n">preds</code> <code class="o">=</code> <code class="n">km</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code>&#13;
<code class="n">ars</code> <code class="o">=</code> <code class="n">adjusted_rand_score</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">],</code><code class="n">preds</code><code class="p">)</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Adjusted Rand Index on Training Set:"</code><code class="p">,</code> <code class="n">ars</code><code class="p">)</code>&#13;
&#13;
<code class="c1"># Predict on test set and evaluate using adjusted Rand index</code>&#13;
<code class="n">preds_test</code> <code class="o">=</code> <code class="n">km</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">X_test</code><code class="p">)</code>&#13;
<code class="n">ars</code> <code class="o">=</code> <code class="n">adjusted_rand_score</code><code class="p">(</code><code class="n">data_test</code><code class="p">[:,</code><code class="mi">0</code><code class="p">],</code><code class="n">preds_test</code><code class="p">)</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Adjusted Rand Index on Test Set:"</code><code class="p">,</code> <code class="n">ars</code><code class="p">)</code></pre>&#13;
&#13;
<p>The <em>TimeSeriesKMean</em> algorithm<a data-primary="TimeSeriesKMean algorithm" data-type="indexterm" id="idm140637522814688"/><a data-primary="algorithms" data-secondary="TimeSeriesKMean" data-type="indexterm" id="idm140637522546480"/> runs even faster than <em>k</em>-shape using the Euclidean distance metric. But the results are not as good:</p>&#13;
&#13;
<pre data-type="programlisting">Adjusted Rand Index of Time Series k-Means on Training Set: 0.5063464656715959</pre>&#13;
&#13;
<p>The adjusted Rand index on the training set is 0.506:</p>&#13;
&#13;
<pre data-type="programlisting">Adjusted Rand Index of Time Series k-Means on Test Set: 0.4864981997585834</pre>&#13;
&#13;
<p>The adjusted Rand index on the test set is 0.486.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Time Series Clustering Using Hierarchical DBSCAN on ECG5000" data-type="sect1"><div class="sect1" id="idm140637522774912">&#13;
<h1>Time Series Clustering Using Hierarchical DBSCAN on ECG5000</h1>&#13;
&#13;
<p>Finally, let’s<a data-primary="time series clustering" data-secondary="using hierarchical DBSCAN" data-type="indexterm" id="idm140637522773344"/><a data-primary="HDBSCAN (hierarchical DBSCAN)" data-type="indexterm" id="idm140637522772368"/> apply <em>hierarchical DBSCAN</em>, which we explored earlier in the book, and evaluate its performance.</p>&#13;
&#13;
<p>We will run <em>HDBSCAN</em> with its default parameters and evaluate performance using the adjusted Rand index:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Train model and evaluate on training set</code>&#13;
<code class="n">min_cluster_size</code> <code class="o">=</code> <code class="mi">5</code>&#13;
<code class="n">min_samples</code> <code class="o">=</code> <code class="bp">None</code>&#13;
<code class="n">alpha</code> <code class="o">=</code> <code class="mf">1.0</code>&#13;
<code class="n">cluster_selection_method</code> <code class="o">=</code> <code class="s1">'eom'</code>&#13;
<code class="n">prediction_data</code> <code class="o">=</code> <code class="bp">True</code>&#13;
&#13;
<code class="n">hdb</code> <code class="o">=</code> <code class="n">hdbscan</code><code class="o">.</code><code class="n">HDBSCAN</code><code class="p">(</code><code class="n">min_cluster_size</code><code class="o">=</code><code class="n">min_cluster_size</code><code class="p">,</code> \&#13;
                      <code class="n">min_samples</code><code class="o">=</code><code class="n">min_samples</code><code class="p">,</code> <code class="n">alpha</code><code class="o">=</code><code class="n">alpha</code><code class="p">,</code> \&#13;
                      <code class="n">cluster_selection_method</code><code class="o">=</code><code class="n">cluster_selection_method</code><code class="p">,</code> \&#13;
                      <code class="n">prediction_data</code><code class="o">=</code><code class="n">prediction_data</code><code class="p">)</code>&#13;
&#13;
<code class="n">preds</code> <code class="o">=</code> <code class="n">hdb</code><code class="o">.</code><code class="n">fit_predict</code><code class="p">(</code><code class="n">X_train</code><code class="o">.</code><code class="n">reshape</code><code class="p">(</code><code class="mi">4000</code><code class="p">,</code><code class="mi">140</code><code class="p">))</code>&#13;
<code class="n">ars</code> <code class="o">=</code> <code class="n">adjusted_rand_score</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">],</code><code class="n">preds</code><code class="p">)</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Adjusted Rand Index on Training Set:"</code><code class="p">,</code> <code class="n">ars</code><code class="p">)</code></pre>&#13;
&#13;
<p>The adjusted Rand index on the training set is an impressive 0.769:</p>&#13;
&#13;
<pre data-type="programlisting">Adjusted Rand Index on Training Set using HDBSCAN: 0.7689563655060421</pre>&#13;
&#13;
<p>The adjusted Rand index on the training set is an impressive 0.769.</p>&#13;
&#13;
<p>Let’s evaluate on the test set:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Predict on test set and evaluate</code>&#13;
<code class="n">preds_test</code> <code class="o">=</code> <code class="n">hdbscan</code><code class="o">.</code><code class="n">prediction</code><code class="o">.</code><code class="n">approximate_predict</code><code class="p">(</code> \&#13;
                <code class="n">hdb</code><code class="p">,</code> <code class="n">X_test</code><code class="o">.</code><code class="n">reshape</code><code class="p">(</code><code class="mi">1000</code><code class="p">,</code><code class="mi">140</code><code class="p">))</code>&#13;
<code class="n">ars</code> <code class="o">=</code> <code class="n">adjusted_rand_score</code><code class="p">(</code><code class="n">data_test</code><code class="p">[:,</code><code class="mi">0</code><code class="p">],</code><code class="n">preds_test</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="s2">"Adjusted Rand Index on Test Set:"</code><code class="p">,</code> <code class="n">ars</code><code class="p">)</code></pre>&#13;
&#13;
<p>The<a data-primary="" data-startref="ecg500013" data-type="indexterm" id="idm140637522691264"/> adjusted Rand index on the training set is an equally impressive 0.720:</p>&#13;
&#13;
<pre data-type="programlisting">Adjusted Rand Index on Test Set using HDBSCAN: 0.7200816245545564</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Comparing the Time Series Clustering Algorithms" data-type="sect1"><div class="sect1" id="idm140637522774288">&#13;
<h1>Comparing the Time Series Clustering Algorithms</h1>&#13;
&#13;
<p>HDBSCAN<a data-primary="time series clustering" data-secondary="algorithm comparison" data-type="indexterm" id="TSCcompar13"/> and <em>k</em>-shape performed similarly well on the ECG5000 dataset, while <em>k</em>-means performed worse. However, we cannot draw strong conclusions by evaluating the performance of these three clustering algorithms on a single time series dataset.</p>&#13;
&#13;
<p>Let’s run a larger experiment to see how these three clustering algorithms stack up against one another.</p>&#13;
&#13;
<p>First, we will load all the directories and files in the UCR Time Series Classification folder so we can iterate through them during the experiment. There are 85 datasets in total:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Load the datasets</code>&#13;
<code class="n">current_path</code> <code class="o">=</code> <code class="n">os</code><code class="o">.</code><code class="n">getcwd</code><code class="p">()</code>&#13;
<code class="nb">file</code> <code class="o">=</code> <code class="s1">'</code><code class="se">\\</code><code class="s1">datasets</code><code class="se">\\</code><code class="s1">ucr_time_series_data</code><code class="se">\\</code><code class="s1">'</code>&#13;
&#13;
<code class="n">mypath</code> <code class="o">=</code> <code class="n">current_path</code> <code class="o">+</code> <code class="nb">file</code>&#13;
<code class="n">d</code> <code class="o">=</code> <code class="p">[]</code>&#13;
<code class="n">f</code> <code class="o">=</code> <code class="p">[]</code>&#13;
<code class="k">for</code> <code class="p">(</code><code class="n">dirpath</code><code class="p">,</code> <code class="n">dirnames</code><code class="p">,</code> <code class="n">filenames</code><code class="p">)</code> <code class="ow">in</code> <code class="n">walk</code><code class="p">(</code><code class="n">mypath</code><code class="p">):</code>&#13;
    <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="n">dirnames</code><code class="p">:</code>&#13;
        <code class="n">newpath</code> <code class="o">=</code> <code class="n">mypath</code><code class="o">+</code><code class="s2">"</code><code class="se">\\</code><code class="s2">"</code><code class="o">+</code><code class="n">i</code><code class="o">+</code><code class="s2">"</code><code class="se">\\</code><code class="s2">"</code>&#13;
        <code class="n">onlyfiles</code> <code class="o">=</code> <code class="p">[</code><code class="n">f</code> <code class="k">for</code> <code class="n">f</code> <code class="ow">in</code> <code class="n">listdir</code><code class="p">(</code><code class="n">newpath</code><code class="p">)</code> <code class="k">if</code> <code class="n">isfile</code><code class="p">(</code><code class="n">join</code><code class="p">(</code><code class="n">newpath</code><code class="p">,</code> <code class="n">f</code><code class="p">))]</code>&#13;
        <code class="n">f</code><code class="o">.</code><code class="n">extend</code><code class="p">(</code><code class="n">onlyfiles</code><code class="p">)</code>&#13;
    <code class="n">d</code><code class="o">.</code><code class="n">extend</code><code class="p">(</code><code class="n">dirnames</code><code class="p">)</code>&#13;
    <code class="k">break</code></pre>&#13;
&#13;
<p>Next, let’s recycle the code for each of the three clustering algorithms and use the list of datasets we just prepared to run a full experiment. We will store the training and test adjusted Rand indices by dataset and measure the time it takes each clustering algorithm to complete the entire experiment of 85 datasets.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before" data-pdf-bookmark="Full Run with k-Shape" data-type="sect2"><div class="sect2" id="idm140637522361472">&#13;
<h2>Full Run with k-Shape</h2>&#13;
&#13;
<p>The first experiment uses <em>k</em>-shape.</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># k-Shape Experiment</code>&#13;
<code class="n">kShapeDF</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">data</code><code class="o">=</code><code class="p">[],</code><code class="n">index</code><code class="o">=</code><code class="p">[</code><code class="n">v</code> <code class="k">for</code> <code class="n">v</code> <code class="ow">in</code> <code class="n">d</code><code class="p">],</code>&#13;
                        <code class="n">columns</code><code class="o">=</code><code class="p">[</code><code class="s2">"Train ARS"</code><code class="p">,</code><code class="s2">"Test ARS"</code><code class="p">])</code>&#13;
&#13;
<code class="c1"># Train and Evaluate k-Shape</code>&#13;
<code class="k">class</code> <code class="nc">ElapsedTimer</code><code class="p">(</code><code class="nb">object</code><code class="p">):</code>&#13;
    <code class="k">def</code> <code class="nf-Magic">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>&#13;
        <code class="bp">self</code><code class="o">.</code><code class="n">start_time</code> <code class="o">=</code> <code class="n">time</code><code class="o">.</code><code class="n">time</code><code class="p">()</code>&#13;
    <code class="k">def</code> <code class="nf">elapsed</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code class="n">sec</code><code class="p">):</code>&#13;
        <code class="k">if</code> <code class="n">sec</code> <code class="o">&lt;</code> <code class="mi">60</code><code class="p">:</code>&#13;
            <code class="k">return</code> <code class="nb">str</code><code class="p">(</code><code class="n">sec</code><code class="p">)</code> <code class="o">+</code> <code class="s2">" sec"</code>&#13;
        <code class="k">elif</code> <code class="n">sec</code> <code class="o">&lt;</code> <code class="p">(</code><code class="mi">60</code> <code class="o">*</code> <code class="mi">60</code><code class="p">):</code>&#13;
            <code class="k">return</code> <code class="nb">str</code><code class="p">(</code><code class="n">sec</code> <code class="o">/</code> <code class="mi">60</code><code class="p">)</code> <code class="o">+</code> <code class="s2">" min"</code>&#13;
        <code class="k">else</code><code class="p">:</code>&#13;
            <code class="k">return</code> <code class="nb">str</code><code class="p">(</code><code class="n">sec</code> <code class="o">/</code> <code class="p">(</code><code class="mi">60</code> <code class="o">*</code> <code class="mi">60</code><code class="p">))</code> <code class="o">+</code> <code class="s2">" hr"</code>&#13;
    <code class="k">def</code> <code class="nf">elapsed_time</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>&#13;
        <code class="k">print</code><code class="p">(</code><code class="s2">"Elapsed: </code><code class="si">%s</code><code class="s2"> "</code> <code class="o">%</code> <code class="bp">self</code><code class="o">.</code><code class="n">elapsed</code><code class="p">(</code><code class="n">time</code><code class="o">.</code><code class="n">time</code><code class="p">()</code> <code class="o">-</code> <code class="bp">self</code><code class="o">.</code><code class="n">start_time</code><code class="p">))</code>&#13;
        <code class="k">return</code> <code class="p">(</code><code class="n">time</code><code class="o">.</code><code class="n">time</code><code class="p">()</code> <code class="o">-</code> <code class="bp">self</code><code class="o">.</code><code class="n">start_time</code><code class="p">)</code>&#13;
&#13;
<code class="n">timer</code> <code class="o">=</code> <code class="n">ElapsedTimer</code><code class="p">()</code>&#13;
<code class="n">cnt</code> <code class="o">=</code> <code class="mi">0</code>&#13;
<code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="n">d</code><code class="p">:</code>&#13;
    <code class="n">cnt</code> <code class="o">+=</code> <code class="mi">1</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="s2">"Dataset "</code><code class="p">,</code> <code class="n">cnt</code><code class="p">)</code>&#13;
    <code class="n">newpath</code> <code class="o">=</code> <code class="n">mypath</code><code class="o">+</code><code class="s2">"</code><code class="se">\\</code><code class="s2">"</code><code class="o">+</code><code class="n">i</code><code class="o">+</code><code class="s2">"</code><code class="se">\\</code><code class="s2">"</code>&#13;
    <code class="n">onlyfiles</code> <code class="o">=</code> <code class="p">[</code><code class="n">f</code> <code class="k">for</code> <code class="n">f</code> <code class="ow">in</code> <code class="n">listdir</code><code class="p">(</code><code class="n">newpath</code><code class="p">)</code> <code class="k">if</code> <code class="n">isfile</code><code class="p">(</code><code class="n">join</code><code class="p">(</code><code class="n">newpath</code><code class="p">,</code> <code class="n">f</code><code class="p">))]</code>&#13;
    <code class="n">j</code> <code class="o">=</code> <code class="n">onlyfiles</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>&#13;
    <code class="n">k</code> <code class="o">=</code> <code class="n">onlyfiles</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>&#13;
    <code class="n">data_train</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">loadtxt</code><code class="p">(</code><code class="n">newpath</code><code class="o">+</code><code class="n">j</code><code class="p">,</code> <code class="n">delimiter</code><code class="o">=</code><code class="s2">","</code><code class="p">)</code>&#13;
    <code class="n">data_test</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">loadtxt</code><code class="p">(</code><code class="n">newpath</code><code class="o">+</code><code class="n">k</code><code class="p">,</code> <code class="n">delimiter</code><code class="o">=</code><code class="s2">","</code><code class="p">)</code>&#13;
&#13;
    <code class="n">data_joined</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">concatenate</code><code class="p">((</code><code class="n">data_train</code><code class="p">,</code><code class="n">data_test</code><code class="p">),</code><code class="n">axis</code><code class="o">=</code><code class="mi">0</code><code class="p">)</code>&#13;
    <code class="n">data_train</code><code class="p">,</code> <code class="n">data_test</code> <code class="o">=</code> <code class="n">train_test_split</code><code class="p">(</code><code class="n">data_joined</code><code class="p">,</code>&#13;
                                        <code class="n">test_size</code><code class="o">=</code><code class="mf">0.20</code><code class="p">,</code> <code class="n">random_state</code><code class="o">=</code><code class="mi">2019</code><code class="p">)</code>&#13;
&#13;
    <code class="n">X_train</code> <code class="o">=</code> <code class="n">to_time_series_dataset</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">:])</code>&#13;
    <code class="n">y_train</code> <code class="o">=</code> <code class="n">data_train</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">int</code><code class="p">)</code>&#13;
    <code class="n">X_test</code> <code class="o">=</code> <code class="n">to_time_series_dataset</code><code class="p">(</code><code class="n">data_test</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">:])</code>&#13;
    <code class="n">y_test</code> <code class="o">=</code> <code class="n">data_test</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">int</code><code class="p">)</code>&#13;
&#13;
    <code class="n">X_train</code> <code class="o">=</code> <code class="n">TimeSeriesScalerMeanVariance</code><code class="p">(</code><code class="n">mu</code><code class="o">=</code><code class="mf">0.</code><code class="p">,</code> <code class="n">std</code><code class="o">=</code><code class="mf">1.</code><code class="p">)</code> \&#13;
                                <code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code>&#13;
    <code class="n">X_test</code> <code class="o">=</code> <code class="n">TimeSeriesScalerMeanVariance</code><code class="p">(</code><code class="n">mu</code><code class="o">=</code><code class="mf">0.</code><code class="p">,</code> <code class="n">std</code><code class="o">=</code><code class="mf">1.</code><code class="p">)</code> \&#13;
                                <code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">X_test</code><code class="p">)</code>&#13;
&#13;
    <code class="n">classes</code> <code class="o">=</code> <code class="nb">len</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">unique</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">]))</code>&#13;
    <code class="n">ks</code> <code class="o">=</code> <code class="n">KShape</code><code class="p">(</code><code class="n">n_clusters</code><code class="o">=</code><code class="n">classes</code><code class="p">,</code> <code class="n">max_iter</code><code class="o">=</code><code class="mi">10</code><code class="p">,</code> <code class="n">n_init</code><code class="o">=</code><code class="mi">3</code><code class="p">,</code><code class="n">verbose</code><code class="o">=</code><code class="mi">0</code><code class="p">)</code>&#13;
    <code class="n">ks</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code>&#13;
&#13;
    <code class="k">print</code><code class="p">(</code><code class="n">i</code><code class="p">)</code>&#13;
    <code class="n">preds</code> <code class="o">=</code> <code class="n">ks</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code>&#13;
    <code class="n">ars</code> <code class="o">=</code> <code class="n">adjusted_rand_score</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">],</code><code class="n">preds</code><code class="p">)</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="s2">"Adjusted Rand Index on Training Set:"</code><code class="p">,</code> <code class="n">ars</code><code class="p">)</code>&#13;
    <code class="n">kShapeDF</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">i</code><code class="p">,</code><code class="s2">"Train ARS"</code><code class="p">]</code> <code class="o">=</code> <code class="n">ars</code>&#13;
&#13;
    <code class="n">preds_test</code> <code class="o">=</code> <code class="n">ks</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">X_test</code><code class="p">)</code>&#13;
    <code class="n">ars</code> <code class="o">=</code> <code class="n">adjusted_rand_score</code><code class="p">(</code><code class="n">data_test</code><code class="p">[:,</code><code class="mi">0</code><code class="p">],</code><code class="n">preds_test</code><code class="p">)</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="s2">"Adjusted Rand Index on Test Set:"</code><code class="p">,</code> <code class="n">ars</code><code class="p">)</code>&#13;
    <code class="n">kShapeDF</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">i</code><code class="p">,</code><code class="s2">"Test ARS"</code><code class="p">]</code> <code class="o">=</code> <code class="n">ars</code>&#13;
&#13;
<code class="n">kShapeTime</code> <code class="o">=</code> <code class="n">timer</code><code class="o">.</code><code class="n">elapsed_time</code><code class="p">()</code></pre>&#13;
&#13;
<p>It takes approximately an hour to run the <em>k</em>-shape algorithm. We’ve stored the adjusted Rand indices and will use these to compare <em>k</em>-shape with <em>k</em>-means and HBDSCAN soon.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The time we measured for <em>k</em>-shape is based on the hyperparameters we set for the experiment as well as the local hardware specifications for the machine on which the experiments were run. <span class="keep-together">Different</span> hyperparameters and hardware specifications could result in dramatically different experiment times.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Full Run with k-Means" data-type="sect2"><div class="sect2" id="idm140637522324032">&#13;
<h2>Full Run with k-Means</h2>&#13;
&#13;
<p>Next up is <em>k</em>-means:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># k-Means Experiment - FULL RUN</code>&#13;
<code class="c1"># Create dataframe</code>&#13;
<code class="n">kMeansDF</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">data</code><code class="o">=</code><code class="p">[],</code><code class="n">index</code><code class="o">=</code><code class="p">[</code><code class="n">v</code> <code class="k">for</code> <code class="n">v</code> <code class="ow">in</code> <code class="n">d</code><code class="p">],</code> \&#13;
                        <code class="n">columns</code><code class="o">=</code><code class="p">[</code><code class="s2">"Train ARS"</code><code class="p">,</code><code class="s2">"Test ARS"</code><code class="p">])</code>&#13;
&#13;
<code class="c1"># Train and Evaluate k-Means</code>&#13;
<code class="n">timer</code> <code class="o">=</code> <code class="n">ElapsedTimer</code><code class="p">()</code>&#13;
<code class="n">cnt</code> <code class="o">=</code> <code class="mi">0</code>&#13;
<code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="n">d</code><code class="p">:</code>&#13;
    <code class="n">cnt</code> <code class="o">+=</code> <code class="mi">1</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="s2">"Dataset "</code><code class="p">,</code> <code class="n">cnt</code><code class="p">)</code>&#13;
    <code class="n">newpath</code> <code class="o">=</code> <code class="n">mypath</code><code class="o">+</code><code class="s2">"</code><code class="se">\\</code><code class="s2">"</code><code class="o">+</code><code class="n">i</code><code class="o">+</code><code class="s2">"</code><code class="se">\\</code><code class="s2">"</code>&#13;
    <code class="n">onlyfiles</code> <code class="o">=</code> <code class="p">[</code><code class="n">f</code> <code class="k">for</code> <code class="n">f</code> <code class="ow">in</code> <code class="n">listdir</code><code class="p">(</code><code class="n">newpath</code><code class="p">)</code> <code class="k">if</code> <code class="n">isfile</code><code class="p">(</code><code class="n">join</code><code class="p">(</code><code class="n">newpath</code><code class="p">,</code> <code class="n">f</code><code class="p">))]</code>&#13;
    <code class="n">j</code> <code class="o">=</code> <code class="n">onlyfiles</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>&#13;
    <code class="n">k</code> <code class="o">=</code> <code class="n">onlyfiles</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>&#13;
    <code class="n">data_train</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">loadtxt</code><code class="p">(</code><code class="n">newpath</code><code class="o">+</code><code class="n">j</code><code class="p">,</code> <code class="n">delimiter</code><code class="o">=</code><code class="s2">","</code><code class="p">)</code>&#13;
    <code class="n">data_test</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">loadtxt</code><code class="p">(</code><code class="n">newpath</code><code class="o">+</code><code class="n">k</code><code class="p">,</code> <code class="n">delimiter</code><code class="o">=</code><code class="s2">","</code><code class="p">)</code>&#13;
&#13;
    <code class="n">data_joined</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">concatenate</code><code class="p">((</code><code class="n">data_train</code><code class="p">,</code><code class="n">data_test</code><code class="p">),</code><code class="n">axis</code><code class="o">=</code><code class="mi">0</code><code class="p">)</code>&#13;
    <code class="n">data_train</code><code class="p">,</code> <code class="n">data_test</code> <code class="o">=</code> <code class="n">train_test_split</code><code class="p">(</code><code class="n">data_joined</code><code class="p">,</code> \&#13;
                                        <code class="n">test_size</code><code class="o">=</code><code class="mf">0.20</code><code class="p">,</code> <code class="n">random_state</code><code class="o">=</code><code class="mi">2019</code><code class="p">)</code>&#13;
&#13;
    <code class="n">X_train</code> <code class="o">=</code> <code class="n">to_time_series_dataset</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">:])</code>&#13;
    <code class="n">y_train</code> <code class="o">=</code> <code class="n">data_train</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">int</code><code class="p">)</code>&#13;
    <code class="n">X_test</code> <code class="o">=</code> <code class="n">to_time_series_dataset</code><code class="p">(</code><code class="n">data_test</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">:])</code>&#13;
    <code class="n">y_test</code> <code class="o">=</code> <code class="n">data_test</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">int</code><code class="p">)</code>&#13;
&#13;
    <code class="n">X_train</code> <code class="o">=</code> <code class="n">TimeSeriesScalerMeanVariance</code><code class="p">(</code><code class="n">mu</code><code class="o">=</code><code class="mf">0.</code><code class="p">,</code> <code class="n">std</code><code class="o">=</code><code class="mf">1.</code><code class="p">)</code> \&#13;
                                    <code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code>&#13;
    <code class="n">X_test</code> <code class="o">=</code> <code class="n">TimeSeriesScalerMeanVariance</code><code class="p">(</code><code class="n">mu</code><code class="o">=</code><code class="mf">0.</code><code class="p">,</code> <code class="n">std</code><code class="o">=</code><code class="mf">1.</code><code class="p">)</code> \&#13;
                                    <code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">X_test</code><code class="p">)</code>&#13;
&#13;
    <code class="n">classes</code> <code class="o">=</code> <code class="nb">len</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">unique</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">]))</code>&#13;
    <code class="n">km</code> <code class="o">=</code> <code class="n">TimeSeriesKMeans</code><code class="p">(</code><code class="n">n_clusters</code><code class="o">=</code><code class="mi">5</code><code class="p">,</code> <code class="n">max_iter</code><code class="o">=</code><code class="mi">10</code><code class="p">,</code> <code class="n">n_init</code><code class="o">=</code><code class="mi">10</code><code class="p">,</code> \&#13;
                          <code class="n">metric</code><code class="o">=</code><code class="s2">"euclidean"</code><code class="p">,</code> <code class="n">verbose</code><code class="o">=</code><code class="mi">0</code><code class="p">,</code> <code class="n">random_state</code><code class="o">=</code><code class="mi">2019</code><code class="p">)</code>&#13;
    <code class="n">km</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code>&#13;
&#13;
    <code class="k">print</code><code class="p">(</code><code class="n">i</code><code class="p">)</code>&#13;
    <code class="n">preds</code> <code class="o">=</code> <code class="n">km</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code>&#13;
    <code class="n">ars</code> <code class="o">=</code> <code class="n">adjusted_rand_score</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">],</code><code class="n">preds</code><code class="p">)</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="s2">"Adjusted Rand Index on Training Set:"</code><code class="p">,</code> <code class="n">ars</code><code class="p">)</code>&#13;
    <code class="n">kMeansDF</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">i</code><code class="p">,</code><code class="s2">"Train ARS"</code><code class="p">]</code> <code class="o">=</code> <code class="n">ars</code>&#13;
&#13;
    <code class="n">preds_test</code> <code class="o">=</code> <code class="n">km</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">X_test</code><code class="p">)</code>&#13;
    <code class="n">ars</code> <code class="o">=</code> <code class="n">adjusted_rand_score</code><code class="p">(</code><code class="n">data_test</code><code class="p">[:,</code><code class="mi">0</code><code class="p">],</code><code class="n">preds_test</code><code class="p">)</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="s2">"Adjusted Rand Index on Test Set:"</code><code class="p">,</code> <code class="n">ars</code><code class="p">)</code>&#13;
    <code class="n">kMeansDF</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">i</code><code class="p">,</code><code class="s2">"Test ARS"</code><code class="p">]</code> <code class="o">=</code> <code class="n">ars</code>&#13;
&#13;
<code class="n">kMeansTime</code> <code class="o">=</code> <code class="n">timer</code><code class="o">.</code><code class="n">elapsed_time</code><code class="p">()</code></pre>&#13;
&#13;
<p>It takes less than five minutes for <em>k</em>-means to run through all 85 datasets:</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Full Run with HDBSCAN" data-type="sect2"><div class="sect2" id="idm140637521942128">&#13;
<h2>Full Run with HDBSCAN</h2>&#13;
&#13;
<p>Finally, we have HBDSCAN:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># HDBSCAN Experiment - FULL RUN</code>&#13;
<code class="c1"># Create dataframe</code>&#13;
<code class="n">hdbscanDF</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">data</code><code class="o">=</code><code class="p">[],</code><code class="n">index</code><code class="o">=</code><code class="p">[</code><code class="n">v</code> <code class="k">for</code> <code class="n">v</code> <code class="ow">in</code> <code class="n">d</code><code class="p">],</code> \&#13;
                         <code class="n">columns</code><code class="o">=</code><code class="p">[</code><code class="s2">"Train ARS"</code><code class="p">,</code><code class="s2">"Test ARS"</code><code class="p">])</code>&#13;
&#13;
<code class="c1"># Train and Evaluate HDBSCAN</code>&#13;
<code class="n">timer</code> <code class="o">=</code> <code class="n">ElapsedTimer</code><code class="p">()</code>&#13;
<code class="n">cnt</code> <code class="o">=</code> <code class="mi">0</code>&#13;
<code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="n">d</code><code class="p">:</code>&#13;
    <code class="n">cnt</code> <code class="o">+=</code> <code class="mi">1</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="s2">"Dataset "</code><code class="p">,</code> <code class="n">cnt</code><code class="p">)</code>&#13;
    <code class="n">newpath</code> <code class="o">=</code> <code class="n">mypath</code><code class="o">+</code><code class="s2">"</code><code class="se">\\</code><code class="s2">"</code><code class="o">+</code><code class="n">i</code><code class="o">+</code><code class="s2">"</code><code class="se">\\</code><code class="s2">"</code>&#13;
    <code class="n">onlyfiles</code> <code class="o">=</code> <code class="p">[</code><code class="n">f</code> <code class="k">for</code> <code class="n">f</code> <code class="ow">in</code> <code class="n">listdir</code><code class="p">(</code><code class="n">newpath</code><code class="p">)</code> <code class="k">if</code> <code class="n">isfile</code><code class="p">(</code><code class="n">join</code><code class="p">(</code><code class="n">newpath</code><code class="p">,</code> <code class="n">f</code><code class="p">))]</code>&#13;
    <code class="n">j</code> <code class="o">=</code> <code class="n">onlyfiles</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>&#13;
    <code class="n">k</code> <code class="o">=</code> <code class="n">onlyfiles</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>&#13;
    <code class="n">data_train</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">loadtxt</code><code class="p">(</code><code class="n">newpath</code><code class="o">+</code><code class="n">j</code><code class="p">,</code> <code class="n">delimiter</code><code class="o">=</code><code class="s2">","</code><code class="p">)</code>&#13;
    <code class="n">data_test</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">loadtxt</code><code class="p">(</code><code class="n">newpath</code><code class="o">+</code><code class="n">k</code><code class="p">,</code> <code class="n">delimiter</code><code class="o">=</code><code class="s2">","</code><code class="p">)</code>&#13;
&#13;
    <code class="n">data_joined</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">concatenate</code><code class="p">((</code><code class="n">data_train</code><code class="p">,</code><code class="n">data_test</code><code class="p">),</code><code class="n">axis</code><code class="o">=</code><code class="mi">0</code><code class="p">)</code>&#13;
    <code class="n">data_train</code><code class="p">,</code> <code class="n">data_test</code> <code class="o">=</code> <code class="n">train_test_split</code><code class="p">(</code><code class="n">data_joined</code><code class="p">,</code> \&#13;
                                    <code class="n">test_size</code><code class="o">=</code><code class="mf">0.20</code><code class="p">,</code> <code class="n">random_state</code><code class="o">=</code><code class="mi">2019</code><code class="p">)</code>&#13;
&#13;
    <code class="n">X_train</code> <code class="o">=</code> <code class="n">data_train</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">:]</code>&#13;
    <code class="n">y_train</code> <code class="o">=</code> <code class="n">data_train</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">int</code><code class="p">)</code>&#13;
    <code class="n">X_test</code> <code class="o">=</code> <code class="n">data_test</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">:]</code>&#13;
    <code class="n">y_test</code> <code class="o">=</code> <code class="n">data_test</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">int</code><code class="p">)</code>&#13;
&#13;
    <code class="n">X_train</code> <code class="o">=</code> <code class="n">TimeSeriesScalerMeanVariance</code><code class="p">(</code><code class="n">mu</code><code class="o">=</code><code class="mf">0.</code><code class="p">,</code> <code class="n">std</code><code class="o">=</code><code class="mf">1.</code><code class="p">)</code> \&#13;
                                    <code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">X_train</code><code class="p">)</code>&#13;
    <code class="n">X_test</code> <code class="o">=</code> <code class="n">TimeSeriesScalerMeanVariance</code><code class="p">(</code><code class="n">mu</code><code class="o">=</code><code class="mf">0.</code><code class="p">,</code> <code class="n">std</code><code class="o">=</code><code class="mf">1.</code><code class="p">)</code>  \&#13;
                                    <code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">X_test</code><code class="p">)</code>&#13;
&#13;
    <code class="n">classes</code> <code class="o">=</code> <code class="nb">len</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">unique</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">]))</code>&#13;
    <code class="n">min_cluster_size</code> <code class="o">=</code> <code class="mi">5</code>&#13;
    <code class="n">min_samples</code> <code class="o">=</code> <code class="bp">None</code>&#13;
    <code class="n">alpha</code> <code class="o">=</code> <code class="mf">1.0</code>&#13;
    <code class="n">cluster_selection_method</code> <code class="o">=</code> <code class="s1">'eom'</code>&#13;
    <code class="n">prediction_data</code> <code class="o">=</code> <code class="bp">True</code>&#13;
&#13;
    <code class="n">hdb</code> <code class="o">=</code> <code class="n">hdbscan</code><code class="o">.</code><code class="n">HDBSCAN</code><code class="p">(</code><code class="n">min_cluster_size</code><code class="o">=</code><code class="n">min_cluster_size</code><code class="p">,</code> \&#13;
                          <code class="n">min_samples</code><code class="o">=</code><code class="n">min_samples</code><code class="p">,</code> <code class="n">alpha</code><code class="o">=</code><code class="n">alpha</code><code class="p">,</code> \&#13;
                          <code class="n">cluster_selection_method</code><code class="o">=</code> \&#13;
                              <code class="n">cluster_selection_method</code><code class="p">,</code> \&#13;
                          <code class="n">prediction_data</code><code class="o">=</code><code class="n">prediction_data</code><code class="p">)</code>&#13;
&#13;
    <code class="k">print</code><code class="p">(</code><code class="n">i</code><code class="p">)</code>&#13;
    <code class="n">preds</code> <code class="o">=</code> <code class="n">hdb</code><code class="o">.</code><code class="n">fit_predict</code><code class="p">(</code><code class="n">X_train</code><code class="o">.</code><code class="n">reshape</code><code class="p">(</code><code class="n">X_train</code><code class="o">.</code><code class="n">shape</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> \&#13;
                                            <code class="n">X_train</code><code class="o">.</code><code class="n">shape</code><code class="p">[</code><code class="mi">1</code><code class="p">]))</code>&#13;
    <code class="n">ars</code> <code class="o">=</code> <code class="n">adjusted_rand_score</code><code class="p">(</code><code class="n">data_train</code><code class="p">[:,</code><code class="mi">0</code><code class="p">],</code><code class="n">preds</code><code class="p">)</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="s2">"Adjusted Rand Index on Training Set:"</code><code class="p">,</code> <code class="n">ars</code><code class="p">)</code>&#13;
    <code class="n">hdbscanDF</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">i</code><code class="p">,</code><code class="s2">"Train ARS"</code><code class="p">]</code> <code class="o">=</code> <code class="n">ars</code>&#13;
&#13;
    <code class="n">preds_test</code> <code class="o">=</code> <code class="n">hdbscan</code><code class="o">.</code><code class="n">prediction</code><code class="o">.</code><code class="n">approximate_predict</code><code class="p">(</code><code class="n">hdb</code><code class="p">,</code>&#13;
                            <code class="n">X_test</code><code class="o">.</code><code class="n">reshape</code><code class="p">(</code><code class="n">X_test</code><code class="o">.</code><code class="n">shape</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> \&#13;
                                           <code class="n">X_test</code><code class="o">.</code><code class="n">shape</code><code class="p">[</code><code class="mi">1</code><code class="p">]))</code>&#13;
    <code class="n">ars</code> <code class="o">=</code> <code class="n">adjusted_rand_score</code><code class="p">(</code><code class="n">data_test</code><code class="p">[:,</code><code class="mi">0</code><code class="p">],</code><code class="n">preds_test</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="s2">"Adjusted Rand Index on Test Set:"</code><code class="p">,</code> <code class="n">ars</code><code class="p">)</code>&#13;
    <code class="n">hdbscanDF</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">i</code><code class="p">,</code><code class="s2">"Test ARS"</code><code class="p">]</code> <code class="o">=</code> <code class="n">ars</code>&#13;
&#13;
<code class="n">hdbscanTime</code> <code class="o">=</code> <code class="n">timer</code><code class="o">.</code><code class="n">elapsed_time</code><code class="p">()</code></pre>&#13;
&#13;
<p>It takes less than 10 minutes for HBDSCAN to run through all 85 datasets.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Comparing All Three Time Series Clustering Approaches" data-type="sect2"><div class="sect2" id="idm140637521607008">&#13;
<h2>Comparing All Three Time Series Clustering Approaches</h2>&#13;
&#13;
<p>Now let’s compare all three clustering algorithms to see which fared the best. One approach is to calculate the average adjusted Rand indices on the training and test sets, respectively, for each of the clustering algorithms.</p>&#13;
&#13;
<p>Here are the scores for each of the algorithms:</p>&#13;
&#13;
<pre data-type="programlisting">k-Shape Results&#13;
&#13;
Train ARS     0.165139&#13;
Test ARS      0.151103</pre>&#13;
&#13;
<pre data-type="programlisting">k-Means Results&#13;
&#13;
Train ARS     0.184789&#13;
Test ARS      0.178960</pre>&#13;
&#13;
<pre data-type="programlisting">HDBSCAN Results&#13;
&#13;
Train ARS     0.178754&#13;
Test ARS 0.158238</pre>&#13;
&#13;
<p>The results are fairly comparable, with <em>k</em>-means having the highest Rand indices, followed closely by <em>k</em>-shape and HDBSCAN.</p>&#13;
&#13;
<p>To validate some of these findings, let’s count how many times each algorithm placed first, second, or third across all the 85 datasets:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Count top place finishes</code>&#13;
<code class="n">timeSeriesClusteringDF</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">data</code><code class="o">=</code><code class="p">[],</code><code class="n">index</code><code class="o">=</code><code class="n">kShapeDF</code><code class="o">.</code><code class="n">index</code><code class="p">,</code> \&#13;
                            <code class="n">columns</code><code class="o">=</code><code class="p">[</code><code class="s2">"kShapeTest"</code><code class="p">,</code> \&#13;
                                    <code class="s2">"kMeansTest"</code><code class="p">,</code> \&#13;
                                    <code class="s2">"hdbscanTest"</code><code class="p">])</code>&#13;
&#13;
<code class="n">timeSeriesClusteringDF</code><code class="o">.</code><code class="n">kShapeTest</code> <code class="o">=</code> <code class="n">kShapeDF</code><code class="p">[</code><code class="s2">"Test ARS"</code><code class="p">]</code>&#13;
<code class="n">timeSeriesClusteringDF</code><code class="o">.</code><code class="n">kMeansTest</code> <code class="o">=</code> <code class="n">kMeansDF</code><code class="p">[</code><code class="s2">"Test ARS"</code><code class="p">]</code>&#13;
<code class="n">timeSeriesClusteringDF</code><code class="o">.</code><code class="n">hdbscanTest</code> <code class="o">=</code> <code class="n">hdbscanDF</code><code class="p">[</code><code class="s2">"Test ARS"</code><code class="p">]</code>&#13;
&#13;
<code class="n">tscResults</code> <code class="o">=</code> <code class="n">timeSeriesClusteringDF</code><code class="o">.</code><code class="n">copy</code><code class="p">()</code>&#13;
&#13;
<code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="nb">len</code><code class="p">(</code><code class="n">tscResults</code><code class="p">)):</code>&#13;
    <code class="n">maxValue</code> <code class="o">=</code> <code class="n">tscResults</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="n">i</code><code class="p">]</code><code class="o">.</code><code class="n">max</code><code class="p">()</code>&#13;
    <code class="n">tscResults</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="n">i</code><code class="p">][</code><code class="n">tscResults</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="n">i</code><code class="p">]</code><code class="o">==</code><code class="n">maxValue</code><code class="p">]</code><code class="o">=</code><code class="mi">1</code>&#13;
    <code class="n">minValue</code> <code class="o">=</code> <code class="n">tscResults</code> <code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="n">i</code><code class="p">]</code><code class="o">.</code><code class="n">min</code><code class="p">()</code>&#13;
    <code class="n">tscResults</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="n">i</code><code class="p">][</code><code class="n">tscResults</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="n">i</code><code class="p">]</code><code class="o">==</code><code class="n">minValue</code><code class="p">]</code><code class="o">=-</code><code class="mi">1</code>&#13;
    <code class="n">medianValue</code> <code class="o">=</code> <code class="n">tscResults</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="n">i</code><code class="p">]</code><code class="o">.</code><code class="n">median</code><code class="p">()</code>&#13;
    <code class="n">tscResults</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="n">i</code><code class="p">][</code><code class="n">tscResults</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="n">i</code><code class="p">]</code><code class="o">==</code><code class="n">medianValue</code><code class="p">]</code><code class="o">=</code><code class="mi">0</code></pre>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Show results</code>&#13;
<code class="n">tscResultsDF</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">data</code><code class="o">=</code><code class="n">np</code><code class="o">.</code><code class="n">zeros</code><code class="p">((</code><code class="mi">3</code><code class="p">,</code><code class="mi">3</code><code class="p">)),</code> \&#13;
                <code class="n">index</code><code class="o">=</code><code class="p">[</code><code class="s2">"firstPlace"</code><code class="p">,</code><code class="s2">"secondPlace"</code><code class="p">,</code><code class="s2">"thirdPlace"</code><code class="p">],</code> \&#13;
                <code class="n">columns</code><code class="o">=</code><code class="p">[</code><code class="s2">"kShape"</code><code class="p">,</code> <code class="s2">"kMeans"</code><code class="p">,</code><code class="s2">"hdbscan"</code><code class="p">])</code>&#13;
<code class="n">tscResultsDF</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="s2">"firstPlace"</code><code class="p">,:]</code> <code class="o">=</code> <code class="n">tscResults</code><code class="p">[</code><code class="n">tscResults</code><code class="o">==</code><code class="mi">1</code><code class="p">]</code><code class="o">.</code><code class="n">count</code><code class="p">()</code><code class="o">.</code><code class="n">values</code>&#13;
<code class="n">tscResultsDF</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="s2">"secondPlace"</code><code class="p">,:]</code> <code class="o">=</code> <code class="n">tscResults</code><code class="p">[</code><code class="n">tscResults</code><code class="o">==</code><code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">count</code><code class="p">()</code><code class="o">.</code><code class="n">values</code>&#13;
<code class="n">tscResultsDF</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="s2">"thirdPlace"</code><code class="p">,:]</code> <code class="o">=</code> <code class="n">tscResults</code><code class="p">[</code><code class="n">tscResults</code><code class="o">==-</code><code class="mi">1</code><code class="p">]</code><code class="o">.</code><code class="n">count</code><code class="p">()</code><code class="o">.</code><code class="n">values</code>&#13;
<code class="n">tscResultsDF</code></pre>&#13;
&#13;
<p><em>k</em>-shape had the most first place finishes, followed by HDBSCAN. <em>k</em>-means had the most second place finishes, performing neither the best but also not the worst on the majority of the datasets (<a data-type="xref" href="#comparison_summary">Table 13-1</a>).</p>&#13;
<table class="pagebreak-before" id="comparison_summary">&#13;
<caption><span class="label">Table 13-1. </span>Comparison summary</caption>&#13;
<thead>&#13;
<tr>&#13;
<th/>&#13;
<th>kShape</th>&#13;
<th>kMeans</th>&#13;
<th>hbdscan</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>firstPlace</p></td>&#13;
<td><p>31.0</p></td>&#13;
<td><p>24.0</p></td>&#13;
<td><p>29.0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>secondPlace</p></td>&#13;
<td><p>19.0</p></td>&#13;
<td><p>41.0</p></td>&#13;
<td><p>26.0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>thirdPlace</p></td>&#13;
<td><p>35.0</p></td>&#13;
<td><p>20.0</p></td>&#13;
<td><p>30.0</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Based on this comparison, it is hard to conclude that one algorithm universally trounces all the others. While <em>k</em>-shape has the most first place finishes, it is considerably slower than the other two algorithms.</p>&#13;
&#13;
<p>And, <em>k</em>-means and HDBSCAN both hold their own, winning first place on a healthy number of datasets.<a data-primary="" data-startref="TSCcompar13" data-type="indexterm" id="idm140637520272288"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="idm140637522368928">&#13;
<h1>Conclusion</h1>&#13;
&#13;
<p>In this chapter, we explored time series data for the first time in the book and demonstrated the power of unsupervised learning to group time series patterns based on their similarity to one another and without requiring any labels. We worked with three clustering algorithms in detail—<em>k</em>-shape, <em>k</em>-means, and HDBSCAN. While <em>k</em>-shape is regarded as the best of the bunch today, the other two algorithms perform quite well, too.</p>&#13;
&#13;
<p>Most importantly, the results from the 85 time series datasets we worked with highlight the importance of experimentation. As with most machine learning, no single algorithm trounces all other algorithms. You must constantly expand your breadth of knowledge and experiment to see which approaches work best for the problem at hand. Knowing what to apply when is the hallmark of a good data scientist.</p>&#13;
&#13;
<p>Hopefully you will be better equipped to solve more of the problems you face going forward with the many different unsupervised learning approaches you’ve learned throughout&#13;
this book.<a data-primary="" data-startref="ULdeep10" data-type="indexterm" id="idm140637520266976"/><a data-primary="" data-startref="UDLtime13" data-type="indexterm" id="idm140637520266000"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm140637524834352"><sup><a href="ch13.html#idm140637524834352-marker">1</a></sup> The paper is publicly available <a href="http://www.cs.columbia.edu/~jopa/kshape.html">here</a>.</p><p data-type="footnote" id="idm140637523748448"><sup><a href="ch13.html#idm140637523748448-marker">2</a></sup> For more on the hyperparameters, refer to the <a href="http://bit.ly/2Gfg0L9">official <em>k</em>-shape documentation</a>.</p><p data-type="footnote" id="idm140637523728768"><sup><a href="ch13.html#idm140637523728768-marker">3</a></sup> Consult Wikipedia for more information on the <a href="https://en.wikipedia.org/wiki/Rand_index">Rand index</a>.</p></div></div></section></body></html>