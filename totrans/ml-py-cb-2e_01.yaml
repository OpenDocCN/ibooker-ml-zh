- en: Chapter 1\. Working with Vectors, Matrices, and Arrays in NumPy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章。在 NumPy 中处理向量、矩阵和数组
- en: 1.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.0 介绍
- en: 'NumPy is a foundational tool of the Python machine learning stack. NumPy allows
    for efficient operations on the data structures often used in machine learning:
    vectors, matrices, and tensors. While NumPy isn’t the focus of this book, it will
    show up frequently in the following chapters. This chapter covers the most common
    NumPy operations we’re likely to run into while working on machine learning workflows.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 是 Python 机器学习堆栈的基础工具。NumPy 允许在机器学习中经常使用的数据结构（向量、矩阵和张量）上进行高效操作。虽然本书的重点不是
    NumPy，但在接下来的章节中会经常出现。本章涵盖了我们在机器学习工作流中可能遇到的最常见的 NumPy 操作。
- en: 1.1 Creating a Vector
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 创建向量
- en: Problem
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to create a vector.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建一个向量。
- en: Solution
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use NumPy to create a one-dimensional array:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy 创建一维数组：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Discussion
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: NumPy’s main data structure is the multidimensional array. A vector is just
    an array with a single dimension. To create a vector, we simply create a one-dimensional
    array. Just like vectors, these arrays can be represented horizontally (i.e.,
    rows) or vertically (i.e., columns).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的主要数据结构是多维数组。向量只是一个单维数组。要创建向量，我们只需创建一个一维数组。就像向量一样，这些数组可以水平表示（即行）或垂直表示（即列）。
- en: See Also
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Vectors, Math Is Fun](https://oreil.ly/43I-b)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[向量, Math Is Fun](https://oreil.ly/43I-b)'
- en: '[Euclidean vector, Wikipedia](https://oreil.ly/er78t)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[欧几里得向量, 维基百科](https://oreil.ly/er78t)'
- en: 1.2 Creating a Matrix
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 创建矩阵
- en: Problem
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to create a matrix.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建一个矩阵。
- en: Solution
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use NumPy to create a two-dimensional array:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy 创建二维数组：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Discussion
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: To create a matrix we can use a NumPy two-dimensional array. In our solution,
    the matrix contains three rows and two columns (a column of 1s and a column of
    2s).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建矩阵，我们可以使用 NumPy 的二维数组。在我们的解决方案中，矩阵包含三行和两列（一列为 1，一列为 2）。
- en: 'NumPy actually has a dedicated matrix data structure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，NumPy 有一个专用的矩阵数据结构：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, the matrix data structure is not recommended for two reasons. First,
    arrays are the de facto standard data structure of NumPy. Second, the vast majority
    of NumPy operations return arrays, not matrix objects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，矩阵数据结构由于两个原因而不推荐使用。首先，数组是 NumPy 的事实标准数据结构。其次，绝大多数 NumPy 操作返回数组，而不是矩阵对象。
- en: See Also
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Matrix, Wikipedia](https://oreil.ly/tnRJw)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[矩阵, 维基百科](https://oreil.ly/tnRJw)'
- en: '[Matrix, Wolfram MathWorld](https://oreil.ly/76jUS)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[矩阵, Wolfram MathWorld](https://oreil.ly/76jUS)'
- en: 1.3 Creating a Sparse Matrix
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 创建稀疏矩阵
- en: Problem
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Given data with very few nonzero values, you want to efficiently represent it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于数据中只有很少的非零值，您希望以高效的方式表示它。
- en: Solution
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Create a sparse matrix:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 创建稀疏矩阵：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Discussion
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A frequent situation in machine learning is having a huge amount of data; however,
    most of the elements in the data are zeros. For example, imagine a matrix where
    the columns are every movie on Netflix, the rows are every Netflix user, and the
    values are how many times a user has watched that particular movie. This matrix
    would have tens of thousands of columns and millions of rows! However, since most
    users do not watch most movies, the vast majority of elements would be zero.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中经常遇到的情况是有大量数据；然而，数据中大多数元素都是零。例如，想象一下一个矩阵，其中列是 Netflix 上的每部电影，行是每个 Netflix
    用户，值是用户观看该特定电影的次数。这个矩阵将有成千上万的列和数百万的行！然而，由于大多数用户不会观看大多数电影，大多数元素将为零。
- en: 'A *sparse matrix* is a matrix in which most elements are 0\. Sparse matrices
    store only nonzero elements and assume all other values will be zero, leading
    to significant computational savings. In our solution, we created a NumPy array
    with two nonzero values, then converted it into a sparse matrix. If we view the
    sparse matrix we can see that only the nonzero values are stored:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*稀疏矩阵* 是一个大部分元素为 0 的矩阵。稀疏矩阵仅存储非零元素，并假设所有其他值都为零，从而显著节省计算资源。在我们的解决方案中，我们创建了一个具有两个非零值的
    NumPy 数组，然后将其转换为稀疏矩阵。如果查看稀疏矩阵，可以看到只存储了非零值：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are a number of types of sparse matrices. However, in *compressed sparse
    row* (CSR) matrices, `(1, 1)` and `(2, 0)` represent the (zero-indexed) indices
    of the nonzero values `1` and `3`, respectively. For example, the element `1`
    is in the second row and second column. We can see the advantage of sparse matrices
    if we create a much larger matrix with many more zero elements and then compare
    this larger matrix with our original sparse matrix:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的稀疏矩阵。然而，在*压缩稀疏行*（CSR）矩阵中，`(1, 1)` 和 `(2, 0)` 表示非零值 `1` 和 `3` 的（从零开始计数的）索引。例如，元素
    `1` 在第二行第二列。如果我们创建一个具有更多零元素的更大矩阵，然后将其与我们的原始稀疏矩阵进行比较，我们可以看到稀疏矩阵的优势：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see, despite the fact that we added many more zero elements in the
    larger matrix, its sparse representation is exactly the same as our original sparse
    matrix. That is, the addition of zero elements did not change the size of the
    sparse matrix.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，尽管在更大的矩阵中添加了更多的零元素，但其稀疏表示与我们原始的稀疏矩阵完全相同。也就是说，添加零元素并没有改变稀疏矩阵的大小。
- en: As mentioned, there are many different types of sparse matrices, such as compressed
    sparse column, list of lists, and dictionary of keys. While an explanation of
    the different types and their implications is outside the scope of this book,
    it is worth noting that while there is no “best” sparse matrix type, there are
    meaningful differences among them, and we should be conscious about why we are
    choosing one type over another.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，稀疏矩阵有许多不同的类型，如压缩稀疏列、列表列表和键字典。虽然解释这些不同类型及其影响超出了本书的范围，但值得注意的是，虽然没有“最佳”稀疏矩阵类型，但它们之间存在显著差异，我们应该意识到为什么选择一种类型而不是另一种类型。
- en: See Also
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SciPy documentation: Sparse Matrices](https://oreil.ly/zBBRB)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SciPy 文档：稀疏矩阵](https://oreil.ly/zBBRB)'
- en: '[101 Ways to Store a Sparse Matrix](https://oreil.ly/sBQhN)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[存储稀疏矩阵的 101 种方法](https://oreil.ly/sBQhN)'
- en: 1.4 Preallocating NumPy Arrays
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.4 预分配 NumPy 数组
- en: Problem
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to preallocate arrays of a given size with some value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要预先分配给定大小的数组，并使用某些值。
- en: Solution
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'NumPy has functions for generating vectors and matrices of any size using 0s,
    1s, or values of your choice:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 具有使用 0、1 或您选择的值生成任意大小向量和矩阵的函数：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Discussion
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Generating arrays prefilled with data is useful for a number of purposes, such
    as making code more performant or using synthetic data to test algorithms. In
    many programming languages, preallocating an array of default values (such as
    0s) is considered common practice.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预填充数据生成数组对于许多目的非常有用，例如使代码更具性能或使用合成数据来测试算法。在许多编程语言中，预先分配一个带有默认值（例如 0）的数组被认为是常见做法。
- en: 1.5 Selecting Elements
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.5 选择元素
- en: Problem
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to select one or more elements in a vector or matrix.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在向量或矩阵中选择一个或多个元素。
- en: Solution
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'NumPy arrays make it easy to select elements in vectors or matrices:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组使得选择向量或矩阵中的元素变得很容易：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Discussion
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Like most things in Python, NumPy arrays are zero-indexed, meaning that the
    index of the first element is 0, not 1\. With that caveat, NumPy offers a wide
    variety of methods for selecting (i.e., indexing and slicing) elements or groups
    of elements in arrays:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数 Python 中的事物一样，NumPy 数组是从零开始索引的，这意味着第一个元素的索引是 0，而不是 1。除此之外，NumPy 提供了大量方法来选择（即索引和切片）数组中的元素或元素组：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 1.6 Describing a Matrix
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.6 描述矩阵
- en: Problem
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to describe the shape, size, and dimensions of a matrix.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要描述矩阵的形状、大小和维度。
- en: Solution
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `shape`, `size`, and `ndim` attributes of a NumPy object:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy 对象的 `shape`、`size` 和 `ndim` 属性：
- en: '[PRE34]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Discussion
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: This might seem basic (and it is); however, time and again it will be valuable
    to check the shape and size of an array both for further calculations and simply
    as a gut check after an operation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很基础（而且确实如此）；然而，一次又一次地，检查数组的形状和大小都是非常有价值的，无论是为了进一步的计算还是仅仅作为操作后的直觉检查。
- en: 1.7 Applying Functions over Each Element
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.7 对每个元素应用函数
- en: Problem
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to apply some function to all elements in an array.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您想将某些函数应用于数组中的所有元素。
- en: Solution
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the NumPy `vectorize` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy 的 `vectorize` 方法：
- en: '[PRE40]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Discussion
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The NumPy `vectorize` method converts a function into a function that can apply
    to all elements in an array or slice of an array. It’s worth noting that `vectorize`
    is essentially a `for` loop over the elements and does not increase performance.
    Furthermore, NumPy arrays allow us to perform operations between arrays even if
    their dimensions are not the same (a process called *broadcasting*). For example,
    we can create a much simpler version of our solution using broadcasting:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的`vectorize`方法将一个函数转换为可以应用于数组或数组切片的所有元素的函数。值得注意的是，`vectorize`本质上是对元素的`for`循环，不会提高性能。此外，NumPy数组允许我们在数组之间执行操作，即使它们的维度不同（这称为*广播*）。例如，我们可以使用广播创建一个更简单的版本：
- en: '[PRE42]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Broadcasting does not work for all shapes and situations, but it is a common
    way of applying simple operations over all elements of a NumPy array.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 广播不适用于所有形状和情况，但它是在NumPy数组的所有元素上应用简单操作的常见方法。
- en: 1.8 Finding the Maximum and Minimum Values
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.8 查找最大值和最小值
- en: Problem
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to find the maximum or minimum value in an array.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在数组中找到最大或最小值。
- en: Solution
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use NumPy’s `max` and `min` methods:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NumPy的`max`和`min`方法：
- en: '[PRE44]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Discussion
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Often we want to know the maximum and minimum value in an array or subset of
    an array. This can be accomplished with the `max` and `min` methods. Using the
    `axis` parameter, we can also apply the operation along a certain axis:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常想知道数组或数组子集中的最大值和最小值。这可以通过`max`和`min`方法来实现。使用`axis`参数，我们还可以沿着特定轴应用操作：
- en: '[PRE48]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 1.9 Calculating the Average, Variance, and Standard Deviation
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.9 计算平均值、方差和标准差
- en: Problem
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to calculate some descriptive statistics about an array.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望计算数组的一些描述性统计信息。
- en: Solution
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use NumPy’s `mean`, `var`, and `std`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NumPy的`mean`、`var`和`std`：
- en: '[PRE52]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Discussion
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Just like with `max` and `min`, we can easily get descriptive statistics about
    the whole matrix or do calculations along a single axis:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用`max`和`min`一样，我们可以轻松地获得关于整个矩阵的描述性统计信息，或者沿着单个轴进行计算：
- en: '[PRE58]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 1.10 Reshaping Arrays
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.10 重新塑形数组
- en: Problem
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to change the shape (number of rows and columns) of an array without
    changing the element values.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望更改数组的形状（行数和列数），而不更改元素值。
- en: Solution
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use NumPy’s `reshape`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NumPy的`reshape`：
- en: '[PRE60]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Discussion
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`reshape` allows us to restructure an array so that we maintain the same data
    but organize it as a different number of rows and columns. The only requirement
    is that the shape of the original and new matrix contain the same number of elements
    (i.e., are the same size). We can see the size of a matrix using `size`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`reshape`允许我们重构一个数组，以便我们保持相同的数据但将其组织为不同数量的行和列。唯一的要求是原始矩阵和新矩阵的形状包含相同数量的元素（即，大小相同）。我们可以使用`size`来查看矩阵的大小：'
- en: '[PRE62]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'One useful argument in `reshape` is `-1`, which effectively means “as many
    as needed,” so `reshape(1, -1)` means one row and as many columns as needed:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`reshape`中一个有用的参数是`-1`，它实际上意味着“需要多少就多少”，因此`reshape(1, -1)`意味着一行和所需的列数：'
- en: '[PRE64]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, if we provide one integer, `reshape` will return a one-dimensional
    array of that length:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们提供一个整数，`reshape`将返回一个长度为该整数的一维数组：
- en: '[PRE66]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 1.11 Transposing a Vector or Matrix
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.11 转置向量或矩阵
- en: Problem
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to transpose a vector or matrix.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要转置向量或矩阵。
- en: Solution
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `T` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`T`方法：
- en: '[PRE68]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Discussion
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '*Transposing* is a common operation in linear algebra where the column and
    row indices of each element are swapped. A nuanced point typically overlooked
    outside of a linear algebra class is that, technically, a vector can’t be transposed
    because it’s just a collection of values:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*转置*是线性代数中的常见操作，其中每个元素的列和行索引被交换。在线性代数课程之外通常被忽略的一个微妙的点是，从技术上讲，向量不能被转置，因为它只是一组值：'
- en: '[PRE70]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'However, it is common to refer to transposing a vector as converting a row
    vector to a column vector (notice the second pair of brackets) or vice versa:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常将向量的转置称为将行向量转换为列向量（请注意第二对括号）或反之亦然：
- en: '[PRE72]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 1.12 Flattening a Matrix
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.12 扁平化矩阵
- en: Problem
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to transform a matrix into a one-dimensional array.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将矩阵转换为一维数组。
- en: Solution
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `flatten` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`flatten`方法：
- en: '[PRE74]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Discussion
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`flatten` is a simple method to transform a matrix into a one-dimensional array.
    Alternatively, we can use `reshape` to create a row vector:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatten`是一个简单的方法，将矩阵转换为一维数组。或者，我们可以使用`reshape`创建一个行向量：'
- en: '[PRE76]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Another common way to flatten arrays is the `ravel` method. Unlike `flatten`,
    which returns a copy of the original array, `ravel` operates on the original object
    itself and is therefore slightly faster. It also lets us flatten lists of arrays,
    which we can’t do with the `flatten` method. This operation is useful for flattening
    very large arrays and speeding up code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 1.13 Finding the Rank of a Matrix
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to know the rank of a matrix.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s linear algebra method `matrix_rank`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Discussion
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *rank* of a matrix is the dimensions of the vector space spanned by its
    columns or rows. Finding the rank of a matrix is easy in NumPy thanks to `matrix_rank`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The Rank of a Matrix, CliffsNotes](https://oreil.ly/Wg9ZG)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.14 Getting the Diagonal of a Matrix
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to get the diagonal elements of a matrix.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s `diagonal`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Discussion
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NumPy makes getting the diagonal elements of a matrix easy with `diagonal`.
    It is also possible to get a diagonal off the main diagonal by using the `offset`
    parameter:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 1.15 Calculating the Trace of a Matrix
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to calculate the trace of a matrix.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `trace`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Discussion
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *trace* of a matrix is the sum of the diagonal elements and is often used
    under the hood in machine learning methods. Given a NumPy multidimensional array,
    we can calculate the trace using `trace`. Alternatively, we can return the diagonal
    of a matrix and calculate its sum:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: See Also
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The Trace of a Square Matrix](https://oreil.ly/AhX1b)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.16 Calculating Dot Products
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to calculate the dot product of two vectors.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s `dot` function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Discussion
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *dot product* of two vectors, <math display="inline"><mi>a</mi></math>
    and <math display="inline"><mi>b</mi></math>, is defined as:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><munderover><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></munderover> <msub><mi>a</mi> <mi>i</mi></msub> <msub><mi>b</mi> <mi>i</mi></msub></mrow></math>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><munderover><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></munderover> <msub><mi>a</mi> <mi>i</mi></msub> <msub><mi>b</mi> <mi>i</mi></msub></mrow></math>
- en: 'where <math display="inline"><msub><mi>a</mi><mi>i</mi></msub></math> is the
    <math display="inline"><mi>i</mi></math>th element of vector <math display="inline"><mi>a</mi></math>,
    and <math display="inline"><msub><mi>b</mi><mi>i</mi></msub></math> is the <math
    display="inline"><mi>i</mi></math>th element of vector <math display="inline"><mi>b</mi></math>.
    We can use NumPy’s `dot` function to calculate the dot product. Alternatively,
    in Python 3.5+ we can use the new `@` operator:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: See Also
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Vector Dot Product and Vector Length, Khan Academy](https://oreil.ly/MpBt7)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dot Product, Paul’s Online Math Notes](https://oreil.ly/EprM1)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.17 Adding and Subtracting Matrices
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to add or subtract two matrices.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s `add` and `subtract`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Discussion
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, we can simply use the `+` and `–` operators:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 1.18 Multiplying Matrices
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to multiply two matrices.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s `dot`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Discussion
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, in Python 3.5+ we can use the `@` operator:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'If we want to do element-wise multiplication, we can use the `*` operator:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: See Also
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Array vs. Matrix Operations, MathWorks](https://oreil.ly/_sFx5)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.19 Inverting a Matrix
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to calculate the inverse of a square matrix.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要计算一个方阵的逆。
- en: Solution
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use NumPy’s linear algebra `inv` method:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy 的线性代数 `inv` 方法：
- en: '[PRE108]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Discussion
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The inverse of a square matrix, **A**, is a second matrix, **A**^(–1), such
    that:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 方阵 **A** 的逆，**A**^(–1)，是第二个矩阵，满足以下条件：
- en: <math display="block"><mrow><mi mathvariant="bold">A</mi> <msup><mi mathvariant="bold">A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mi mathvariant="bold">I</mi></mrow></math>
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mi mathvariant="bold">A</mi> <msup><mi mathvariant="bold">A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mi mathvariant="bold">I</mi></mrow></math>
- en: 'where **I** is the identity matrix. In NumPy we can use `linalg.inv` to calculate
    **A**^(–1) if it exists. To see this in action, we can multiply a matrix by its
    inverse, and the result is the identity matrix:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 **I** 是单位矩阵。在 NumPy 中，如果存在的话，我们可以使用 `linalg.inv` 计算 **A**^(–1)。为了看到这一点，我们可以将一个矩阵乘以它的逆，结果是单位矩阵：
- en: '[PRE110]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: See Also
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Inverse of a Matrix](https://oreil.ly/SwRXC)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[矩阵的逆](https://oreil.ly/SwRXC)'
- en: 1.20 Generating Random Values
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.20 生成随机值
- en: Problem
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to generate pseudorandom values.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要生成伪随机值。
- en: Solution
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use NumPy’s `random`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy 的 `random`：
- en: '[PRE112]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Discussion
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'NumPy offers a wide variety of means to generate random numbers—many more than
    can be covered here. In our solution we generated floats; however, it is also
    common to generate integers:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了生成随机数的多种方法，远远超出了此处所能涵盖的范围。在我们的解决方案中，我们生成了浮点数；然而，生成整数也很常见：
- en: '[PRE114]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Alternatively, we can generate numbers by drawing them from a distribution
    (note this is not technically random):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过从分布中抽取数字来生成数字（请注意，这在技术上不是随机的）：
- en: '[PRE116]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Finally, sometimes it can be useful to return the same random numbers multiple
    times to get predictable, repeatable results. We can do this by setting the “seed”
    (an integer) of the pseudorandom generator. Random processes with the same seed
    will always produce the same output. We will use seeds throughout this book so
    that the code you see in the book and the code you run on your computer produces
    the same results.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有时候返回相同的随机数多次以获取可预测的、可重复的结果是有用的。我们可以通过设置伪随机生成器的“种子”（一个整数）来实现这一点。具有相同种子的随机过程将始终产生相同的输出。我们将在本书中使用种子，以确保您在书中看到的代码和在您的计算机上运行的代码产生相同的结果。
