- en: Chapter 1\. Working with Vectors, Matrices, and Arrays in NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NumPy is a foundational tool of the Python machine learning stack. NumPy allows
    for efficient operations on the data structures often used in machine learning:
    vectors, matrices, and tensors. While NumPy isn’t the focus of this book, it will
    show up frequently in the following chapters. This chapter covers the most common
    NumPy operations we’re likely to run into while working on machine learning workflows.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 Creating a Vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to create a vector.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy to create a one-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy’s main data structure is the multidimensional array. A vector is just
    an array with a single dimension. To create a vector, we simply create a one-dimensional
    array. Just like vectors, these arrays can be represented horizontally (i.e.,
    rows) or vertically (i.e., columns).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Vectors, Math Is Fun](https://oreil.ly/43I-b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Euclidean vector, Wikipedia](https://oreil.ly/er78t)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.2 Creating a Matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to create a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy to create a two-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a matrix we can use a NumPy two-dimensional array. In our solution,
    the matrix contains three rows and two columns (a column of 1s and a column of
    2s).
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy actually has a dedicated matrix data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, the matrix data structure is not recommended for two reasons. First,
    arrays are the de facto standard data structure of NumPy. Second, the vast majority
    of NumPy operations return arrays, not matrix objects.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Matrix, Wikipedia](https://oreil.ly/tnRJw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Matrix, Wolfram MathWorld](https://oreil.ly/76jUS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.3 Creating a Sparse Matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given data with very few nonzero values, you want to efficiently represent it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a sparse matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A frequent situation in machine learning is having a huge amount of data; however,
    most of the elements in the data are zeros. For example, imagine a matrix where
    the columns are every movie on Netflix, the rows are every Netflix user, and the
    values are how many times a user has watched that particular movie. This matrix
    would have tens of thousands of columns and millions of rows! However, since most
    users do not watch most movies, the vast majority of elements would be zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *sparse matrix* is a matrix in which most elements are 0\. Sparse matrices
    store only nonzero elements and assume all other values will be zero, leading
    to significant computational savings. In our solution, we created a NumPy array
    with two nonzero values, then converted it into a sparse matrix. If we view the
    sparse matrix we can see that only the nonzero values are stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a number of types of sparse matrices. However, in *compressed sparse
    row* (CSR) matrices, `(1, 1)` and `(2, 0)` represent the (zero-indexed) indices
    of the nonzero values `1` and `3`, respectively. For example, the element `1`
    is in the second row and second column. We can see the advantage of sparse matrices
    if we create a much larger matrix with many more zero elements and then compare
    this larger matrix with our original sparse matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, despite the fact that we added many more zero elements in the
    larger matrix, its sparse representation is exactly the same as our original sparse
    matrix. That is, the addition of zero elements did not change the size of the
    sparse matrix.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, there are many different types of sparse matrices, such as compressed
    sparse column, list of lists, and dictionary of keys. While an explanation of
    the different types and their implications is outside the scope of this book,
    it is worth noting that while there is no “best” sparse matrix type, there are
    meaningful differences among them, and we should be conscious about why we are
    choosing one type over another.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[SciPy documentation: Sparse Matrices](https://oreil.ly/zBBRB)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[101 Ways to Store a Sparse Matrix](https://oreil.ly/sBQhN)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.4 Preallocating NumPy Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to preallocate arrays of a given size with some value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NumPy has functions for generating vectors and matrices of any size using 0s,
    1s, or values of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generating arrays prefilled with data is useful for a number of purposes, such
    as making code more performant or using synthetic data to test algorithms. In
    many programming languages, preallocating an array of default values (such as
    0s) is considered common practice.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5 Selecting Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to select one or more elements in a vector or matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NumPy arrays make it easy to select elements in vectors or matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like most things in Python, NumPy arrays are zero-indexed, meaning that the
    index of the first element is 0, not 1\. With that caveat, NumPy offers a wide
    variety of methods for selecting (i.e., indexing and slicing) elements or groups
    of elements in arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 1.6 Describing a Matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to describe the shape, size, and dimensions of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `shape`, `size`, and `ndim` attributes of a NumPy object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This might seem basic (and it is); however, time and again it will be valuable
    to check the shape and size of an array both for further calculations and simply
    as a gut check after an operation.
  prefs: []
  type: TYPE_NORMAL
- en: 1.7 Applying Functions over Each Element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to apply some function to all elements in an array.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the NumPy `vectorize` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The NumPy `vectorize` method converts a function into a function that can apply
    to all elements in an array or slice of an array. It’s worth noting that `vectorize`
    is essentially a `for` loop over the elements and does not increase performance.
    Furthermore, NumPy arrays allow us to perform operations between arrays even if
    their dimensions are not the same (a process called *broadcasting*). For example,
    we can create a much simpler version of our solution using broadcasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Broadcasting does not work for all shapes and situations, but it is a common
    way of applying simple operations over all elements of a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: 1.8 Finding the Maximum and Minimum Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to find the maximum or minimum value in an array.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s `max` and `min` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often we want to know the maximum and minimum value in an array or subset of
    an array. This can be accomplished with the `max` and `min` methods. Using the
    `axis` parameter, we can also apply the operation along a certain axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 1.9 Calculating the Average, Variance, and Standard Deviation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to calculate some descriptive statistics about an array.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s `mean`, `var`, and `std`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like with `max` and `min`, we can easily get descriptive statistics about
    the whole matrix or do calculations along a single axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 1.10 Reshaping Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to change the shape (number of rows and columns) of an array without
    changing the element values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s `reshape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`reshape` allows us to restructure an array so that we maintain the same data
    but organize it as a different number of rows and columns. The only requirement
    is that the shape of the original and new matrix contain the same number of elements
    (i.e., are the same size). We can see the size of a matrix using `size`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'One useful argument in `reshape` is `-1`, which effectively means “as many
    as needed,” so `reshape(1, -1)` means one row and as many columns as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if we provide one integer, `reshape` will return a one-dimensional
    array of that length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 1.11 Transposing a Vector or Matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to transpose a vector or matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `T` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Transposing* is a common operation in linear algebra where the column and
    row indices of each element are swapped. A nuanced point typically overlooked
    outside of a linear algebra class is that, technically, a vector can’t be transposed
    because it’s just a collection of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is common to refer to transposing a vector as converting a row
    vector to a column vector (notice the second pair of brackets) or vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 1.12 Flattening a Matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to transform a matrix into a one-dimensional array.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `flatten` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`flatten` is a simple method to transform a matrix into a one-dimensional array.
    Alternatively, we can use `reshape` to create a row vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common way to flatten arrays is the `ravel` method. Unlike `flatten`,
    which returns a copy of the original array, `ravel` operates on the original object
    itself and is therefore slightly faster. It also lets us flatten lists of arrays,
    which we can’t do with the `flatten` method. This operation is useful for flattening
    very large arrays and speeding up code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 1.13 Finding the Rank of a Matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to know the rank of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s linear algebra method `matrix_rank`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *rank* of a matrix is the dimensions of the vector space spanned by its
    columns or rows. Finding the rank of a matrix is easy in NumPy thanks to `matrix_rank`.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The Rank of a Matrix, CliffsNotes](https://oreil.ly/Wg9ZG)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.14 Getting the Diagonal of a Matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to get the diagonal elements of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s `diagonal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NumPy makes getting the diagonal elements of a matrix easy with `diagonal`.
    It is also possible to get a diagonal off the main diagonal by using the `offset`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 1.15 Calculating the Trace of a Matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to calculate the trace of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `trace`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *trace* of a matrix is the sum of the diagonal elements and is often used
    under the hood in machine learning methods. Given a NumPy multidimensional array,
    we can calculate the trace using `trace`. Alternatively, we can return the diagonal
    of a matrix and calculate its sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The Trace of a Square Matrix](https://oreil.ly/AhX1b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.16 Calculating Dot Products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to calculate the dot product of two vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s `dot` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *dot product* of two vectors, <math display="inline"><mi>a</mi></math>
    and <math display="inline"><mi>b</mi></math>, is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><munderover><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></munderover> <msub><mi>a</mi> <mi>i</mi></msub> <msub><mi>b</mi> <mi>i</mi></msub></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'where <math display="inline"><msub><mi>a</mi><mi>i</mi></msub></math> is the
    <math display="inline"><mi>i</mi></math>th element of vector <math display="inline"><mi>a</mi></math>,
    and <math display="inline"><msub><mi>b</mi><mi>i</mi></msub></math> is the <math
    display="inline"><mi>i</mi></math>th element of vector <math display="inline"><mi>b</mi></math>.
    We can use NumPy’s `dot` function to calculate the dot product. Alternatively,
    in Python 3.5+ we can use the new `@` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Vector Dot Product and Vector Length, Khan Academy](https://oreil.ly/MpBt7)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dot Product, Paul’s Online Math Notes](https://oreil.ly/EprM1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.17 Adding and Subtracting Matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to add or subtract two matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s `add` and `subtract`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, we can simply use the `+` and `–` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 1.18 Multiplying Matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to multiply two matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s `dot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, in Python 3.5+ we can use the `@` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to do element-wise multiplication, we can use the `*` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Array vs. Matrix Operations, MathWorks](https://oreil.ly/_sFx5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.19 Inverting a Matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to calculate the inverse of a square matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s linear algebra `inv` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The inverse of a square matrix, **A**, is a second matrix, **A**^(–1), such
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mi mathvariant="bold">A</mi> <msup><mi mathvariant="bold">A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mi mathvariant="bold">I</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'where **I** is the identity matrix. In NumPy we can use `linalg.inv` to calculate
    **A**^(–1) if it exists. To see this in action, we can multiply a matrix by its
    inverse, and the result is the identity matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Inverse of a Matrix](https://oreil.ly/SwRXC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.20 Generating Random Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to generate pseudorandom values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use NumPy’s `random`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NumPy offers a wide variety of means to generate random numbers—many more than
    can be covered here. In our solution we generated floats; however, it is also
    common to generate integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can generate numbers by drawing them from a distribution
    (note this is not technically random):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Finally, sometimes it can be useful to return the same random numbers multiple
    times to get predictable, repeatable results. We can do this by setting the “seed”
    (an integer) of the pseudorandom generator. Random processes with the same seed
    will always produce the same output. We will use seeds throughout this book so
    that the code you see in the book and the code you run on your computer produces
    the same results.
  prefs: []
  type: TYPE_NORMAL
