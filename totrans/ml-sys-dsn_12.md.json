["```py\ndef train():\n   ...\n   batch_size = 32\n   ... \n   learning_rate = 3e-4\n   ...\n   model.train(data, batch_size, loss_fn)\n   ...   \n\n^ example of underconfigured code: things are too rigid  \n\nclass Config(BaseConfig):\n    def __init__(self):\n        self.data_config = DataConfig()\n        self.model_config = ModelConfig()\n        self.training_config = TrainingConfig()\n        self.inference_config = InferenceConfig()\n        self.environment_config = EnvironmentConfig()\n\nclass DataConfig(BaseConfig):\n    def __init__(self):\n        self.train_data_config = TrainDataConfig()\n        self.validation_data_config = ValidationDataConfig()\n        self.test_data_config = TestDataConfig()\n\nconfig = Config(\n    data_config=DataConfig(\n        train_data_config=TrainDataConfig(\n            ...\n        ),\n        validation_data_config=ValidationDataConfig(\n            ...\n        ),\n        test_data_config=TestDataConfig(\n            ...\n        ),\n    ),\n    ...\n)\n```", "```py\nfrom unittest.mock import patch, Mock\nimport torch\nfrom training_pipeline import train, get_config\n\nclass DummyResnet(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.model = torch.nn.Sequential(torch.nn.AdaptiveAvgPool2d(1),\n                                         torch.nn.Conv2d(3, 2048, 1))\n\n    def forward(self, x):\n        return self.model(x).squeeze(-1).squeeze(-1)\n\ndef test_train_pipeline():\n    config = get_config()\n    config[\"dataset_path\"] = \"/path/to/fixture\"\n    config[\"num_epochs\"] = 1\n\n    mock = Mock(wraps=DummyResnet)\n    with patch('training_pipeline.models.Resnet', mock):\n        result = train(config)\n        assert mock.call_count == 1\n        assert result['train_loss'] < .5\n        assert result['val_loss'] < 1\n```"]