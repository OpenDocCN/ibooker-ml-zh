- en: Chapter 6\. Exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It has been said that it is easier to take a SME and train them in data science
    than the reverse. I’m not sure I agree with that 100%, but there is truth that
    data has nuance and an SME can help tease that apart. By understanding the business
    and the data, they are able to create better models and have a better impact on
    their business.
  prefs: []
  type: TYPE_NORMAL
- en: Before I create a model, I will do some exploratory data analysis. This gives
    me a feel for the data, but also is a great excuse to meet and discuss issues
    with business units that control that data.
  prefs: []
  type: TYPE_NORMAL
- en: Data Size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, we are using the Titanic dataset here. The pandas `.shape` property
    will return a tuple of the number of rows and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can see that this dataset has 1,309 rows and 13 columns.
  prefs: []
  type: TYPE_NORMAL
- en: Summary Stats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use pandas to get summary statistics for our data. The `.describe` method
    will also give us the count of non-NaN values. Let’s look at the results for the
    first and last columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The count row tells us that both of these columns are filled in. There are no
    missing values. We also have the mean, standard deviation, minimum, maximum, and
    quartile values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A pandas DataFrame has an `iloc` attribute that we can do index operations on.
    It will let us pick out rows and columns by index location. We pass in the row
    positions as a scalar, list, or slice, and then we can add a comma and pass in
    the column positions as a scalar, list, or slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we pull out the second and fifth row, and the last three columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a `.loc` attribute, and we can put out rows and columns based
    on name (rather than position). Here is the same portion of the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Histogram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A histogram is a great tool to visualize numeric data. You can see how many
    modes there are as well as look at the distribution (see [Figure 6-1](#id7)).
    The pandas library has a `.plot` method to show histograms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Pandas histogram.](assets/mlpr_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Pandas histogram.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Using the seaborn library, we can plot a histogram of continuous values against
    the target (see [Figure 6-2](#iddist2)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Seaborn histogram.](assets/mlpr_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Seaborn histogram.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Scatter Plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A scatter plot shows the relationship between two numeric columns (see [Figure 6-3](#id8)).
    Again, this is easy with pandas. Adjust the `alpha` parameter if you have overlapping
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Pandas scatter plot.](assets/mlpr_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. Pandas scatter plot.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There doesn’t appear to be much correlation between these two features. We
    can do Pearson correlation between two (pandas) columns with the `.corr` method
    to quantify the correlation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Joint Plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yellowbrick has a fancier scatter plot that includes histograms on the edge
    as well as a regression line called a *joint plot* (see [Figure 6-4](#id9)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Yellowbrick joint plot.](assets/mlpr_0604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. Yellowbrick joint plot.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this `.fit` method, `X` and `y` refer to a column each. Usually, the `X`
    is a DataFrame, not a series.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the [seaborn](https://seaborn.pydata.org) library to create
    a joint plot (see [Figure 6-5](#id10)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Seaborn joint plot.](assets/mlpr_0605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5\. Seaborn joint plot.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Pair Grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The seaborn library can create a pair grid (see [Figure 6-6](#id11)). This
    plot is a matrix of columns and kernel density estimations. To color by a column
    from a DataFrame, use the `hue` parameter. By coloring with the target, we can
    see if features have different effects on the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Seaborn pair grid.](assets/mlpr_0606.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-6\. Seaborn pair grid.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Box and Violin Plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Seaborn has various plots to visualize distributions. We show examples of a
    box plot and a violin plot (see [Figure 6-7](#id12) and [Figure 6-8](#id13)).
    These plots can visualize a feature against a target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Seaborn box plot.](assets/mlpr_0607.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-7\. Seaborn box plot.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Violin plots can help with distribution visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Seaborn violin plot.](assets/mlpr_0608.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-8\. Seaborn violin plot.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Comparing Two Ordinal Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is pandas code to compare two ordinal categories. I’m simulating that
    by binning age into ten quantiles, and pclass into three bins. The plot is normalized
    so it fills all of the vertical area. This makes it easy to see that in the 40%
    quantile most of the tickets were in 3rd class (see [Figure 6-9](#id42)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'can be replaced by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In pandas, there is often more than one way to do something, and some helper
    functions are available that compose other functionality, such as `pd.crosstab`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing ordinal values.](assets/mlpr_0609.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-9\. Comparing ordinal values.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Correlation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yellowbrick can create pairwise comparisons between the features (see [Figure 6-10](#id14)).
    This plot shows a Pearson correlation (the `algorithm` parameter also accepts
    `''spearman''` and `''covariance''`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![Covariance created with Yellowbrick.](assets/mlpr_0610.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-10\. Covariance correlation created with Yellowbrick.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A similar plot, a heat map, is available in the seaborn library (see [Figure 6-11](#id15)).
    We need to pass in a correlation DataFrame as the data. Sadly, the colorbar does
    not span between -1 and 1 unless the values in the matrix do, or we add the `vmin`
    and `vmax` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![Seaborn heat map.](assets/mlpr_0611.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-11\. Seaborn heat map.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The pandas library can also provide a correlation between DataFrame columns.
    We only show the first two columns of the result. The default method is `''pearson''`,
    but you can also set the `method` parameter to `''kendall''`, `''spearman''`,
    or a custom callable that returns a float given two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Highly correlated columns don’t add value and can throw off feature importance
    and interpretation of regression coefficients. Below is code to find the correlated
    columns. In our data none of the columns are highly correlated (remember we removed
    the sex_male column).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had correlated columns, we could choose to remove either the columns
    from level_0 or level_1 from the feature data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the dataset with more columns, we can see that many of them are correlated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: RadViz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A RadViz plot shows each sample on a circle, with the features on the circumference
    (see [Figure 6-12](#id16)). The values are normalized, and you can imagine that
    each figure has a spring that pulls samples to it based on the value.
  prefs: []
  type: TYPE_NORMAL
- en: This is one technique to visualize separability between the targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yellowbrick can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Yellowbrick RadViz plot.](assets/mlpr_0612.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-12\. Yellowbrick RadViz plot.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The pandas library can plot RadViz plots as well (see [Figure 6-13](#id17)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Pandas RadViz plot.](assets/mlpr_0613.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-13\. Pandas RadViz plot.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Parallel Coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For multivariate data, you can use a parallel coordinates plot to see clustering
    visually (see [Figure 6-14](#id18) and [Figure 6-15](#id19)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, here is a Yellowbrick version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Yellowbrick parallel coordinates plot.](assets/mlpr_0614.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-14\. Yellowbrick parallel coordinates plot.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'And a pandas version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![Pandas parallel coordinates plot.](assets/mlpr_0615.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-15\. Pandas parallel coordinates plot.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
