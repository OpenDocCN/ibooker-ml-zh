- en: 13 Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 集成
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: API design
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API设计
- en: Release cycle
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布周期
- en: Operating the system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统
- en: Overrides and fallbacks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖和回退
- en: As we claimed earlier, the worst thing you can do is build a system, only to
    put it on a shelf instead of going live. Both of us have faced such problems at
    least once in our careers, and it is not an experience we recommend.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所声称的，你能做的最糟糕的事情就是构建一个系统，然后只是把它放在架子上而不是让它上线。我们俩在我们的职业生涯中至少都遇到过这样的问题，这不是我们推荐的经历。
- en: 'A rookie mistake would be to think that integration is a one-time event or
    a single phase of a project. That is an antipattern: you cannot just dedicate
    some weeks to future integration and start building a system in a vacuum. In reality,
    it is a continuous process that starts from the very beginning of the project
    and ends only when the system is decommissioned. Even more, when the system’s
    life cycle comes to an end, it requires certain deintegration efforts, making
    sure none of the direct or indirect users will be affected by switching it off.
    Proper integration is the key to the success of your system, making it much easier
    to get feedback on and improve. The smoother various elements are integrated into
    your system, the shorter the feedback loop and the faster the iterations you can
    implement.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新手错误的想法是认为集成是一次性的事件或项目的一个阶段。这是一个反模式：你不能只是为未来的集成分配几周时间，然后在真空中开始构建系统。实际上，它是一个从项目一开始就开始，直到系统退役才结束的持续过程。更重要的是，当系统的生命周期结束时，它需要一定的解集成努力，确保没有任何直接或间接的用户会受到关闭系统的影响。适当的集成是您系统成功的关键，使您更容易获得反馈并改进。各种元素集成到您的系统中的越平滑，反馈循环就越短，您可以实施的迭代就越快。
- en: In this chapter, we discuss how to efficiently integrate your system, with a
    focus on technical aspects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论如何高效地集成您的系统，重点关注技术方面。
- en: 13.1 API design
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 API设计
- en: API design is a crucial part of the integration process. It may be perceived
    as a contract between your system and its users, but it is a contract you need
    to read through thoroughly before signing. The is that is your API design will
    be costly to change once it has been set up, even if it’s not set in stone and
    the system is still in development.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: API设计是集成过程中的关键部分。它可能被视为系统与其用户之间的合同，但这是你在签署之前需要彻底阅读的合同。这是因为一旦API设计被设置，即使它不是一成不变的，系统仍在开发中，更改API设计也将是代价高昂的。
- en: If you are a reader who is experienced in machine learning (ML), you may feel
    tempted to skip this section, simply because you know how to design APIs and have
    done it many times. That is a fair claim, as we are not going to teach you the
    difference between REST and RPC or how to design APIs in general. Besides, there
    are myriads of great books and articles on this topic (e.g., a nice collection
    of recommended materials can be found at [https://news.ycombinator.com/item?id=24383180](https://news.ycombinator.com/item?id=24383180)).
    Instead, we will focus on the key aspects and highlight pitfalls specific to ML
    systems in particular.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一位在机器学习（ML）方面经验丰富的读者，你可能觉得可以跳过这一节，仅仅因为你已经知道如何设计API并且已经多次这样做。这是一个合理的说法，因为我们不会教你REST和RPC之间的区别，或者如何一般性地设计API。此外，关于这个主题有大量的优秀书籍和文章（例如，可以在[https://news.ycombinator.com/item?id=24383180](https://news.ycombinator.com/item?id=24383180)找到一些推荐的资料集合）。相反，我们将专注于关键方面，并突出ML系统特有的陷阱。
- en: 'If we were to pick just two properties of a good API, we would choose *simplicity*
    and *predictability*. There is a classic software quote by Butler Lampson, which
    is even referred to as the “fundamental theorem of software engineering”: “We
    can solve any problem by introducing an extra level of indirection.”'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要挑选出好的API的两个属性，我们会选择*简单性*和*可预测性*。Butler Lampson有一句经典的软件名言，甚至被称为“软件工程的基本定理”：“我们可以通过引入一个额外的间接层来解决任何问题。”
- en: A variation of this quote is that any programming problem can be solved with
    a layer of abstraction except for a problem of too many abstractions. So the simplicity
    of an API is the art of finding the right abstraction that is not leaky. An abstraction
    is considered leaky when it exposes too many underlying implementation details.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话的一个变体是，任何编程问题都可以通过一层抽象来解决，除了太多抽象的问题。所以API的简单性是找到正确抽象的艺术，这种抽象不会泄露太多底层实现细节。
- en: The vital role of *simplicity* lies in its ability to make an API easier to
    learn and use without a deep understanding of internals. A typical ML system often
    has many handlers and parameters, and it is always tempting to expose them to
    the external user. This leads to overcomplicated solutions where calling methods
    requires providing multiple parameters, and at the end of the day, it is hard
    to understand their meanings and how they are interconnected. A better approach
    implies hiding the complexity behind a simple interface and offering a few methods
    with a small number of parameters. Users will be grateful for that.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 简单性的关键作用在于其使 API 更易于学习和使用，而无需深入了解内部结构。一个典型的机器学习系统通常有许多处理程序和参数，总是有向外部用户暴露它们的诱惑。这导致了解决方案过于复杂，调用方法需要提供多个参数，最终很难理解它们的含义以及它们是如何相互关联的。更好的方法是在简单的界面后面隐藏复杂性，并提供一些参数数量较少的方法。用户会为此感到感激。
- en: However, hiding all the parameters is not the best idea either (see figure 13.1).
    It is important to provide a way to customize the system’s behavior, especially
    for debugging purposes. Imagine yourself debugging a system that has a dozen parameters
    during a late-night on-call shift, and you cannot modify any of them. Not a pleasant
    experience! In these cases, it always makes sense to suggest reasonable defaults
    and provide a way to override them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，隐藏所有参数也不是最好的主意（见图 13.1）。为系统行为提供定制方式很重要，尤其是在调试目的上。想象一下，在一个深夜的值班期间，你正在调试一个有十几个参数的系统，而你无法修改任何一个参数。这不是一个愉快的体验！在这些情况下，建议合理的默认值并提供一种覆盖它们的方式总是很有意义的。
- en: '![figure](../Images/CH13_F01_Babushkin.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH13_F01_Babushkin.png)'
- en: Figure 13.1 Overconfiguration vs. underconfiguration
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.1 过度配置与不足配置
- en: Campfire story from Arseny
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 阿尔谢尼的营火故事
- en: I used to work for a company that provided an API for external developers. I
    was in charge of building a brand-new endpoint that would mirror a classification
    system under the hood. In the early stages, the API seemed to be very straightforward—just
    accepting an object as input and delivering a label from a predefined taxonomy
    as output.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经为一家公司工作，该公司为外部开发者提供 API。我负责构建一个全新的端点，该端点将镜像底层的分类系统。在早期阶段，该 API 似乎非常简单——只需接受一个对象作为输入，并从预定义的分类法中输出一个标签。
- en: 'The accuracy of the baseline was not perfect, though, and one of my colleagues
    suggested returning a list of labels instead of a single label. It was a reasonable
    suggestion, which I implemented with no hesitation. However, practice showed that
    users only needed a single label even when it was incorrect (their usage patterns
    could not use the second label or further). The bad news was that the list of
    labels had already been exposed in the API, and it would be hard to remove it
    without breaking compatibility. So the API became overly complicated for no reason,
    and many users shared their frustration about that: "Why do you return a list
    of labels if it always contains a single item?” Too quick a decision about the
    API design led to a suboptimal solution that was hard to fix later.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基线准确度并不完美，我的一个同事建议返回一个标签列表而不是单个标签。这是一个合理的建议，我毫不犹豫地实施了它。然而，实践表明，即使在标签不正确的情况下（他们的使用模式无法使用第二个标签或更多），用户也只需要一个标签。坏消息是标签列表已经暴露在
    API 中，如果不破坏兼容性，很难将其移除。因此，API 无端变得过于复杂，许多用户对此表示了不满：“为什么你返回一个标签列表，而它总是包含单个项目？”过于草率的
    API 设计决策导致了一个次优的解决方案，后来很难修复。
- en: Predictability is another crucial property of a good API. We’ve already talked
    about how ML systems tend to be nondeterministic unless they are forced to intentionally
    (please see chapter 10). This is an even more critical factor for APIs, as they
    must be deterministic and predictable. It is important to make sure that the same
    input will always produce the same output. Of course, there are algorithms that
    are nondeterministic by design (e.g., text generation with temperature sampling),
    but this is an exception that proves the rule.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可预测性是良好 API 的另一个关键属性。我们已经讨论了机器学习系统通常是非确定性的，除非它们被强制有意地（请参阅第 10 章）。这对于 API 来说是一个更加关键的因素，因为它们必须是确定性和可预测的。确保相同的输入总是产生相同的输出是很重要的。当然，有一些算法是非确定性的（例如，带有温度采样的文本生成），但这只是例外，证明了规则。
- en: There is always a possibility of forcing *deterministic behavior*. One simple
    example would be taking a random seed from the parameters (and choosing your own
    seed if not specified). By the way, while many ML libraries use random seeds from
    a global state, it is not possible in JAX, a new numerical computing library by
    Google that emerged recently. Its design suggests that you have to pass the random
    state explicitly exactly for this reason—to force full reproducibility. See [https://mng.bz/lrQ2](https://mng.bz/lrQ2)
    for more information.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有强制实现**确定性行为**的可能性。一个简单的例子就是从参数中获取随机种子（如果没有指定，可以选择自己的种子）。顺便说一句，虽然许多机器学习库使用全局状态的随机种子，但在
    Google 新近出现的数值计算库 JAX 中则不行。其设计表明，你必须明确传递随机状态，正是为了这个原因——强制实现完全可重复性。更多信息请见 [https://mng.bz/lrQ2](https://mng.bz/lrQ2)。
- en: Another source of nondeterminism would be input data, including some implicit
    data like the current time (it should be provided via parameters as well).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 非确定性的另一个来源可能是输入数据，包括一些隐含的数据，如当前时间（它也应该通过参数提供）。
- en: Let’s look at two implementations of a predict function that uses time as input
    and returns somewhat stochastic results with different random states. The following
    listing has the only explicit argument, while its output depends on three parameters,
    meaning that the output is not reproducible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个使用时间作为输入并返回具有一定随机性结果的预测函数的实现。以下列表只有一个显式参数，而其输出取决于三个参数，这意味着输出是不可重复的。
- en: Listing 13.1 A mediocre design for a `predict` function
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.1 一个平庸的 `predict` 函数设计
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Unlike the previous example, the function caller shown in the following listing
    controls all the parameters affecting the output.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子不同，以下列表中显示的函数调用者控制着影响输出的所有参数。
- en: Listing 13.2 A better design for a `predict` function
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.2 一个更好的 `predict` 函数设计
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note  While we use Python in these examples, the fundamentals for higher-level
    abstractions remain unchanged. Imagine that this function is part of an HTTP API
    where `time` and `seed` are newly introduced query parameters. In this case, the
    same principles will be applied.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注释：虽然我们在这些例子中使用 Python，但高级抽象的基本原理保持不变。想象一下这个函数是 HTTP API 的一部分，其中 `time` 和 `seed`
    是新引入的查询参数。在这种情况下，将应用相同的原理。
- en: A specific aspect of predictability is *compatibility*. When talking about compatibility,
    engineers usually imply either backward compatibility or forward compatibility.
    Backward compatibility means that the new version of the API is compatible with
    the old one (the old code can be used with the new version of the API without
    any changes). Forward compatibility implies that the old version of the API is
    compatible with the new one (the new code can be used with the old version of
    the API without any changes).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可预测性的一个特定方面是**兼容性**。当谈论兼容性时，工程师通常指的是向后兼容或向前兼容。向后兼容意味着 API 的新版本与旧版本兼容（旧代码可以在不进行任何更改的情况下与新版本的
    API 一起使用）。向前兼容则意味着 API 的旧版本与新版本兼容（新代码可以在不进行任何更改的情况下与旧版本的 API 一起使用）。
- en: In the context of ML systems, compatibility is also related to versioning the
    underlying model. There is a common practice to version the model and provide
    a way to request a specific version of the model during initialization.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习系统的背景下，兼容性也与底层模型的版本有关。通常有一个常见的做法是给模型打版本号，并在初始化时提供一个请求特定版本模型的方法。
- en: Listing 13.3 Adding a model version to the API
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.3 将模型版本添加到 API 中
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example is oversimplified, and you may need a much more advanced solution
    for a complicated system. Read materials about the model registry pattern (e.g.,
    [https://neptune.ai/blog/ml-model-registry](https://neptune.ai/blog/ml-model-registry))
    if you want to learn more.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子过于简化，你可能需要一个更高级的解决方案来处理复杂的系统。如果你想了解更多关于模型注册模式的信息，可以阅读相关材料（例如，[https://neptune.ai/blog/ml-model-registry](https://neptune.ai/blog/ml-model-registry)）。
- en: 'Versioning is tricky. One antipattern can be updating the model without bumping
    the version, which leads to changes in the behavior of the system without any
    notification. There are a lot of scenarios in which updating the model is considered
    a breaking change, and it must be reflected in the version. Even more, this is
    applicable not only for the model but for any aspect of the pipeline—data input/output
    (IO), preprocessing, postprocessing, etc. Some changes are not even intended:
    you can update the dependencies and get a different result, thus breaking the
    compatibility implicitly.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制很棘手。一种反模式可能是更新模型而不提升版本，这会导致系统行为的变化而没有任何通知。有很多场景中，更新模型被视为破坏性变更，必须在版本中反映出来。更重要的是，这不仅适用于模型，还适用于管道的任何方面——数据输入/输出（IO）、预处理、后处理等。一些更改甚至不是有意为之：你可以更新依赖项并得到不同的结果，从而隐式地破坏兼容性。
- en: Campfire story from Arseny
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 阿列克谢的篝火故事
- en: How long might it take to update a Python version? This seems like a simple
    question, but once I had to learn the hard way that, in fact, it is not. And the
    reality slap was so hard that it sent me down a rabbit hole.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 更新Python版本可能需要多长时间？这个问题看起来很简单，但事实上，我不得不艰难地学习到它并非如此。现实的重击如此之重，以至于让我陷入了一个兔子洞。
- en: The system I worked on required full compatibility. And, boy, was I surprised
    when bumping a Python version (while keeping everything else static!) led to a
    mismatch in several outputs. After a few iterations of bisection, I realized the
    problem was related to the image reading library. The same version of the library
    built for Python 3.5 had slightly different behavior from the version for Python
    3.6, and therefore, the files readable with one version of the library were not
    compatible with the other.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我工作的系统需要完全兼容。哎呀，当我提升Python版本（同时保持其他一切静态！）导致几个输出不匹配时，我感到非常惊讶。经过几次二分查找迭代后，我意识到问题与图像读取库有关。为Python
    3.5构建的同一版本库与Python 3.6版本的库行为略有不同，因此，可以用一个版本库读取的文件与另一个版本库不兼容。
- en: But how could that even happen? It appeared that the library used a low-level
    JPEG library implemented in C; at the same time, different builds of a Python
    library—even with the same version—used different versions of the underlying C
    library as they used one installed globally on a build machine. Finding which
    one was used in every given case was not easy and required some hardcore software
    archeology (digging into 6-year-old build logs of the open source library, finding
    the clues from there, and finally reproducing the very same build).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但这怎么可能发生呢？看起来这个库使用了一个用C实现的低级JPEG库；同时，Python库的不同构建版本——即使版本相同——也使用了不同的底层C库版本，因为它们使用了在构建机器上全局安装的版本。在每种情况下找到使用的版本并不容易，需要一些硬核软件考古（挖掘开源库6年前的构建日志，从中找到线索，并最终重现相同的构建）。
- en: Once again, the difference was not significant at all; still, it was enough
    to break compatibility because the models were trained on the images read with
    one version of the library, and their sensitivity to the input was too high. It
    was not likely that the users would notice the difference, but it was still a
    breaking change—a thing that was not supposed to happen due to the user agreement.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，差异并不显著；然而，这足以破坏兼容性，因为模型是在使用库的一个版本读取的图像上训练的，并且它们对输入的敏感性太高。用户不太可能注意到差异，但这仍然是一个破坏性变更——本不应该发生的事情，因为这是由于用户协议。
- en: While Arseny’s experience demonstrates the challenges of maintaining compatibility
    within a single system, the following story from Valerii highlights how versioning
    problems can become an even bigger difficulty when versioning is broken not within
    a system but at the point of our interaction with a third-party solution.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然阿列克谢的经验展示了在单一系统中保持兼容性的挑战，但以下来自瓦列里伊的故事突出了当版本控制问题并非出现在系统内部，而是在我们与第三方解决方案互动的节点上时，可能会变成一个更大的难题。
- en: Campfire story from Valerii
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 瓦列里伊的篝火故事
- en: One time I needed to implement a KYC (know your customer) solution for a financial
    organization. A part of this solution required verifying ID documents uploaded
    by users and ensuring a user’s face wasn’t present among existing users. In other
    words, it was a regulatory required constraint on user uniqueness. As a person
    familiar with a build-or-buy tradeoff (please see chapter 3), I used a face recognition
    solution from a big popular vendor.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有一次，我需要为一个金融机构实施KYC（了解你的客户）解决方案。这个解决方案的一部分需要验证用户上传的ID文件，并确保用户的脸不在现有用户中。换句话说，这是一项关于用户唯一性的监管要求约束。作为一个熟悉构建或购买权衡的人（请参阅第3章），我使用了一个大型流行供应商的面部识别解决方案。
- en: 'The system was simple: take documents as input, find a face, calculate a vector,
    make sure there were no similar vectors in the database, and let the user sign
    up; otherwise, make customer support verify the case manually. The system worked
    fine until one unlucky day when the customer support team got overloaded with
    false positives. After the investigation, it appeared that the vendor’s API version
    had been fixed—unless it was unset by mistake. As a result, a newer version of
    the API returned implicitly incompatible results that led to the incident.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 系统很简单：以文档作为输入，找到一张脸，计算一个向量，确保数据库中没有类似的向量，然后让用户注册；否则，让客户支持团队手动验证情况。系统一直运行良好，直到有一天不幸的是客户支持团队因误报而工作量过大。经过调查，发现供应商的API版本已被修复——除非不小心将其取消设置。结果，API的新版本返回了隐式不兼容的结果，导致了这一事件。
- en: This kind of failure is dangerous because of its implicit nature. An external
    API suddenly changing the field name may lead to an outage, which, luckily, is
    easy to catch and fix. When the model’s version is changed, you may not notice
    it at first—it has returned a vector of floats before it returns a similar vector
    now, and the outage can be detected either by a properly configured testing/monitoring
    setup or after the downstream task (customer verification in this case) degradation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种失败由于其隐含性质而非常危险。外部API突然更改字段名称可能会导致中断，幸运的是，这种中断很容易被发现和修复。当模型版本更改时，你最初可能不会注意到——它之前返回的是浮点向量，现在返回的是类似的向量，中断可以通过正确配置的测试/监控设置或在下游任务（在这种情况下是客户验证）退化后检测到。
- en: Nothing helps to catch things like that better than a proper set of tests running
    on continuous integration (CI).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比在持续集成（CI）上运行的一套适当的测试更能帮助捕捉这类问题。
- en: 13.1.1 API practices
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.1 API实践
- en: 'Over the years, the industry has developed multiple practices for working with
    APIs. We mention a few that we consider efficient. They may not be necessarily
    specific to ML systems, but they are often relevant to them (see figure 13.2):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，行业已经发展出多种与API协同工作的实践。我们提到了一些我们认为效率较高的实践。它们可能并不一定专门针对机器学习系统，但它们通常与它们相关（见图13.2）：
- en: '*Design at least two layers of the API.* Here, we are talking about the external
    and internal layers, where the former is logically a subset of the latter while
    not necessarily following the same protocol. The external API is exposed to users
    or other components, and the internal API is used by the external one. As long
    as the internal API is not exposed to users, it can be changed without breaking
    compatibility. The external API, in its turn, is a subset of the internal API
    and should be designed with compatibility in mind. It helps separate the concerns
    and make the external API simpler and easy to maintain in terms of compatibility
    while leaving the internal API flexible and easy to change.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*至少设计API的两层结构。* 这里，我们谈论的是外部和内部层，其中前者在逻辑上是后者的子集，但并不一定遵循相同的协议。外部API暴露给用户或其他组件，而内部API被外部API使用。只要内部API不对用户暴露，就可以在不破坏兼容性的情况下进行更改。反过来，外部API是内部API的子集，应该考虑到兼容性进行设计。它有助于分离关注点，使外部API在兼容性方面更简单、更容易维护，同时使内部API更灵活、更容易更改。'
- en: '*Try separating the ML and IO components of the API when possible.* An ML service
    is easiest to maintain when it is stateless and thus idempotent. It’s not always
    possible, but it’s a good practice to strive for. This approach is useful not
    only for maintenance but also for scalability: IO and ML components can be scaled
    independently, which is a great property given that they have different requirements
    (e.g., an ML component is usually CPU- or GPU-bound). On top of that, it simplifies
    the evolution of the system: you can deploy a new version of the ML component
    without touching the IO component and use both ML components simultaneously for
    some time during A/B testing or a gradual rollout.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽可能将API的机器学习和IO组件分离。* 当机器学习服务是无状态的并且因此是幂等的时，它最容易维护。这并不总是可能的，但这是一个值得追求的良好实践。这种方法不仅对维护有用，而且对可扩展性也有用：IO和ML组件可以独立扩展，考虑到它们有不同的要求（例如，ML组件通常受CPU或GPU限制），这是一个很好的特性。此外，它简化了系统的演变：您可以在不触及IO组件的情况下部署ML组件的新版本，并在A/B测试或逐步推出期间同时使用两个ML组件一段时间。'
- en: '*Build a client library for your API for simpler usage.* Whether it is for
    external users or your teammates, having a client library lowers the entry barrier,
    so it smooths the debugging process and speeds up experiments. It is also a good
    place to implement practices that are not parts of the API directly, such as recommended
    retries, timeouts, and so on.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为您的API构建一个客户端库以简化使用。* 不论是为外部用户还是您的团队成员，拥有一个客户端库可以降低入门门槛，从而简化调试过程并加快实验速度。它也是一个实现API直接不包含的实践的好地方，例如推荐的重试、超时等。'
- en: '*Consider embedding feature toggles* (also known as feature flags) or any other
    alternative used in your organization. ML systems often operate in risky environments,
    and it will always be beneficial to have a way of disabling a new version of the
    model or switch to a fallback solution in case of arising problems. Feature toggles
    are not part of the API, but they effectively serve as a workaround to control
    the behavior of the system without redeploying it or changing the API/client behavior.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*考虑嵌入功能开关*（也称为功能标志）或您组织使用的任何其他替代方案。机器学习系统通常在风险环境中运行，并且始终有一种方法可以禁用模型的新版本或切换到回退解决方案，以防出现问题。功能开关不是API的一部分，但它们有效地充当了绕过系统行为的手段，而无需重新部署或更改API/客户端行为。'
- en: '![figure](../Images/CH13_F02_Babushkin.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH13_F02_Babushkin.png)'
- en: Figure 13.2 Layered API structure is simpler to maintain, test, and develop.
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.2分层API结构更易于维护、测试和开发。
- en: 13.2 Release cycle
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 发布周期
- en: 'The release cycle of an ML system is usually similar to that of regular software.
    However, there are two main differences:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习系统的发布周期通常与常规软件类似。然而，有两个主要区别：
- en: ML systems are trickier to test.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习系统更难以测试。
- en: Training a new model (even with a fully automated pipeline) usually takes way
    more time than compiling code and building other artifacts.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练一个新的模型（即使是完全自动化的流程）通常比编译代码和构建其他工件需要更多的时间。
- en: Let’s elaborate on these points.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细阐述这些观点。
- en: Due to testing complexity, running tests alone is not always enough, and regressions
    may occur anyway. Let’s talk about software for a moment. Once regular software
    is updated, it is usually enough to run tests to ensure everything works as expected.
    But if we are talking about ML models, the situation is quite different, as many
    improvements come with a price. When the ML model is updated, even if we have
    a representative dataset for tests and a good test coverage of software-related
    parts, we still cannot guarantee that the changes won’t provoke harmful outcomes.
    For example, say there are 100 samples in the final test set, and the new model
    improves performance on 3 samples that have been labeled errors before but introduces
    two new errors on other samples. The overall performance is better, but is the
    change good enough to be released?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试复杂性，仅仅运行测试并不总是足够的，而且仍然可能发生回归。让我们暂时谈谈软件。一旦常规软件更新，通常只需要运行测试来确保一切按预期工作。但是，如果我们谈论机器学习模型，情况就完全不同了，因为许多改进都伴随着代价。当机器学习模型更新时，即使我们有代表性的测试数据集和良好的软件相关部分的测试覆盖率，我们仍然不能保证这些更改不会引发有害的结果。例如，假设最终测试集中有100个样本，新模型在之前被标记为错误的3个样本上提高了性能，但在其他样本上引入了两个新的错误。整体性能有所提高，但这种变化是否足够好以至于可以发布？
- en: Real-life scenarios are full of similar examples, and this means that many releases
    require a human in the loop. It is similar to testing user experience changes,
    where an employee should check if the changes bring sufficient benefits. And evaluating
    the tradeoffs between improvements and regressions is usually more complicated
    than just checking if the UI animation works as expected. The human-in-the-loop
    method may vary depending on the system. In some cases, an ML engineer is responsible;
    in others, it can be a product manager or an external domain expert, or the job
    can even be delegated to crowd-sourcing platforms providing a large pool of users
    with aggregated feedback.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现实生活中的场景充满了类似的例子，这意味着许多发布都需要人工介入。这类似于测试用户体验的改变，其中员工应该检查这些改变是否带来了足够的利益。评估改进和退步之间的权衡通常比仅仅检查UI动画是否按预期工作要复杂得多。人工介入的方法可能因系统而异。在某些情况下，ML工程师负责；在其他情况下，可能是一位产品经理或外部领域专家，或者这项工作甚至可以委托给提供大量用户和聚合反馈的众包平台。
- en: 'There are simpler cases where some kind of AutoML allows for the model (not
    the whole system—just the model) to be released automatically without additional
    reviewing. Imagine you are building an advanced text editor with a powerful feature:
    an autocomplete that mimics the author’s style (oh, we wish we had one while writing
    this book!). This software needs to run a custom model (probably on top of a large
    foundational model) for each user. Gathering new users’ writings and regularly
    updating the model without human involvement seems a good practice here; otherwise,
    it is not scalable. Such scenarios need an even higher paranoid level of testing
    to cover as many pessimistic paths as possible and disable model updates once
    there is a chance of a malfunction.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些更简单的情况，某种AutoML允许模型（不是整个系统——只是模型）自动发布，无需额外审查。想象一下，你正在构建一个具有强大功能的先进文本编辑器：一个模仿作者风格的自动完成功能（哦，我们希望我们在写这本书的时候就有这样一个功能！）。这个软件需要为每个用户运行一个自定义模型（可能是在大型基础模型之上），收集新用户的写作并定期更新模型，而不需要人工参与，这似乎是一个好的做法；否则，它将无法扩展。这样的场景需要更高的偏执测试水平，以覆盖尽可能多的悲观路径，并在出现故障的可能性时禁用模型更新。
- en: Okay, let’s assume testing is not a problem. Say you have found a bug in the
    preprocessing code; you are confident fixing it is a good solution that won’t
    make things worse, and an advanced testing toolset can help you make sure that
    is really the case. For regular software, it would mean that you can just fix
    the bug, run the tests, and deploy a new version; usually, it does not take too
    long. But it will not work this way for ML systems because you need to retrain
    the model. We will not use extra-large-scale examples here, but even based on
    our experience, models that were trained for weeks are not uncommon, so releasing
    the fix the next day is not possible at all.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们假设测试不是问题。假设你在预处理代码中发现了错误；你确信修复它是好的解决方案，不会使事情变得更糟，并且先进的测试工具集可以帮助你确保这真的是这样。对于常规软件来说，这意味着你可以直接修复错误，运行测试，并部署新版本；通常，这不会花费太多时间。但对于ML系统来说，情况并非如此，因为你需要重新训练模型。我们不会使用超大规模的例子，但根据我们的经验，训练了几周的模式并不少见，所以第二天发布修复是不可能的。
- en: In practice, it means the release cycle for ML systems is usually longer than
    for regular software; still, it may vary a lot—from multiple times a day to once
    a year with multiple variations in between. Make sure to take this into account
    when designing your system. A long release cycle implies that the system should
    be more reliable and tested extensively, while a short release cycle allows it
    to be more agile and allows for more experimentation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这意味着ML系统的发布周期通常比常规软件要长；然而，这可能会变化很大——从每天多次到一年一次，中间有多次变化。在设计系统时，请务必考虑这一点。长的发布周期意味着系统应该更加可靠，并且需要进行广泛的测试，而短的发布周期则允许系统更加敏捷，并允许进行更多的实验。
- en: 'Multicomponent systems can have and use different release cycles for different
    components. Imagine a simple search engine that contains four components: an index
    containing the documents to be searched across, the lightweight filter for preliminary
    selection, a heavy model for the final ranking, and an API layer to expose the
    search results. Documents may be added to the index all the time (with no release
    required), the index codebase is rarely touched, and the filterer and API layers
    are pure non-ML software that is easier to test and build, so they can be released
    more frequently. In its turn, the ranking model is trained and released biweekly
    with additional verification. It allows us to be more agile with the non-ML components
    and more stable with the ML component.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 多组件系统可以为不同的组件使用不同的发布周期。想象一个包含四个组件的简单搜索引擎：一个包含要搜索的文档的索引，一个轻量级的过滤器用于初步选择，一个重型模型用于最终排名，以及一个API层来公开搜索结果。文档可以随时添加到索引中（无需发布），索引代码库很少被修改，过滤器层和API层是纯非机器学习软件，更容易测试和构建，因此它们可以更频繁地发布。反过来，排名模型每两周训练和发布一次，并附加额外的验证。这使我们能够对非机器学习组件更加敏捷，对机器学习组件更加稳定。
- en: There is a family of release-related techniques, including blue-green deployment
    (see figure 13.3) and canary deployment (see figure 13.4). They may slightly differ,
    but the core idea behind them is to have two or more systems in production at
    the same time. New users are sent to a new version once it is deployed while the
    old version is still functioning. In the blue-green deployment, changes are discrete
    (all users are switched to either the blue or green version), while in canary
    deployment, the rollout is granular, and the new version is used for a small portion
    of the existing users. It allows us to test the new version in production and
    roll back more easily if something goes wrong. It is not specific to ML systems,
    but it can be applied for them as well. Another technique ML systems can use is
    decomposition (e.g., some components like a model can be released with canary
    deployment; in contrast, other components like API layers can be released in a
    more traditional way).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一系列与发布相关的技术，包括蓝绿部署（见图 13.3）和金丝雀部署（见图 13.4）。它们可能略有不同，但它们背后的核心思想是同时让两个或更多系统在生产环境中运行。一旦部署了新版本，新用户就会被发送到新版本，而旧版本仍然在运行。在蓝绿部署中，更改是离散的（所有用户都切换到蓝色或绿色版本），而在金丝雀部署中，发布是细粒度的，新版本仅用于一小部分现有用户。这使我们能够在生产环境中测试新版本，并在出现问题时更容易回滚。这并不特定于机器学习系统，但也可以应用于它们。机器学习系统还可以使用的一种技术是分解（例如，某些组件如模型可以与金丝雀部署一起发布；相比之下，其他组件如API层可以以更传统的方式发布）。
- en: '![figure](../Images/CH13_F03_Babushkin.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH13_F03_Babushkin.png)'
- en: Figure 13.3 Blue-green deployment
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.3 蓝绿部署
- en: '![figure](../Images/CH13_F04_Babushkin.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/CH13_F04_Babushkin.png)'
- en: Figure 13.4 Canary deployment
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.4 金丝雀部署
- en: Canary deployment should not be confused with the A/B tests we discussed in
    chapter 12\. While technically they may look like similar concepts (multiple instances
    of a system are live, and traffic is sent toward them in a proper split), their
    intent is different. A/B tests are used to evaluate the performance of different
    versions of the system, while canary deployment is used to test the new version
    of the system before switching to it completely. In A/B tests, we want to compare
    the performance of the system across different versions, and the time of the test
    is decided based on statistical significance; it is fine to end up keeping either
    option A or option B. With canary deployment, we want to make sure the new version
    is good enough to be used by all users, and we aim to switch to it completely
    as soon as possible.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀部署不应与我们在第 12 章中讨论的 A/B 测试混淆。虽然在技术上它们可能看起来像类似的概念（系统的多个实例都是活跃的，并且流量以适当的分割发送到它们），但它们的意图是不同的。A/B
    测试用于评估系统不同版本的性能，而金丝雀部署用于在完全切换之前测试系统的最新版本。在 A/B 测试中，我们希望比较不同版本的系统性能，测试时间基于统计显著性；保留选项
    A 或选项 B 都是可行的。在金丝雀部署中，我们希望确保新版本足够好，可以供所有用户使用，并且我们希望尽可能快地完全切换到它。
- en: 'While large enterprises usually tend to have stricter policies and longer release
    cycles, this is not always the case: aiming to reduce the time gap between iterations
    using both technical and organizational approaches is a noble goal. It is also
    an important aspect of the DevOps culture, and ML systems are not an exception
    here. If you’re interested in this topic, we recommend checking out the book *The
    Phoenix Project*. It is not about ML systems, and it’s not even a very technical
    book (more like a “business fable”), but it is a great read about the DevOps culture
    and how it can be applied in the real world.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大型企业通常倾向于有更严格的政策和更长的发布周期，但这并不总是如此：通过技术和组织方法来缩短迭代之间的时间差距是一个崇高的目标。这也是DevOps文化的一个重要方面，机器学习系统也不例外。如果你对这个话题感兴趣，我们建议阅读《凤凰项目》这本书。这本书不是关于机器学习系统的，甚至不是一本非常技术性的书（更像是“商业寓言”），但它是一本关于DevOps文化和如何在现实世界中应用它的优秀读物。
- en: Startups and mature big-tech companies are usually more agile and have shorter
    release cycles, but that can vary as well. Arseny once worked for a startup where
    deploying late on Friday night was a common practice (sometimes it led to outages
    that had to be solved by engineers who were already enjoying a solid pint of beer).
    In the other, more established startup, the release cycle was very flexible; every
    engineer could deploy their component at any time, but a simple guardrail warned
    before deployment if the time was imperfect (e.g., Friday after lunch).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创业公司和成熟的科技巨头通常更加敏捷，发布周期也更短，但这也会有所变化。阿尔谢尼曾为一家初创公司工作，周五晚上晚些时候部署是常见的做法（有时这会导致需要工程师解决故障，而这些工程师当时已经在享受一杯美酒）。在另一家更成熟的初创公司中，发布周期非常灵活；每个工程师都可以随时部署他们的组件，但在部署前会有一个简单的护栏警告，如果时间不合适（例如，午餐后周五）。
- en: 'Those who are blessed to schedule releases should be aware of all the dependencies:
    how the system influences other systems and how others can affect it. The biggest
    outages usually happen either on the infrastructure level or between the systems
    or components that are not owned by the same team. Having proper communication
    with other teams to avoid such problems is a must-have skill for any senior engineer.
    Unfortunately, this skill and the understanding of its importance often come at
    a certain cost (usually after a big outage).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那些有幸安排发布的人应该意识到所有依赖关系：系统如何影响其他系统，以及其他系统如何影响它。最大的故障通常发生在基础设施层面，或者是在不属于同一团队的系统或组件之间。与其他团队进行适当的沟通以避免此类问题是任何高级工程师必备的技能。不幸的是，这种技能及其重要性的理解往往需要付出一定的代价（通常是在大故障之后）。
- en: 'Arseny’s biggest outage was related to a logger configuration (not something
    you expect to care much about while building an ML system). Some ML-related load
    happened in threads, and when aiming to track the behavior, he overengineered
    a complicated logger to keep requests’ IDs between the threads. It worked fine
    in one environment and was later deployed to another, where engineers had way
    less control. It was a dark moment when the defect revealed itself: the problem
    could only happen after 1,000 requests of a certain type that never happened in
    previous environments. It took a while to understand the root cause or roll back
    the new version, so the incident came to be a good lesson to introduce more checks
    in the release process.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 阿尔谢尼遇到的最大故障与一个日志记录器配置有关（在构建机器学习系统时，你通常不会太在意这类配置）。一些与机器学习相关的负载发生在线程中，当试图追踪行为时，他设计了一个复杂的日志记录器来在线程间保持请求的ID。它在某个环境中运行良好，后来被部署到另一个环境中，那里的工程师对系统的控制力要小得多。当缺陷暴露出来时，这是一个黑暗的时刻：问题只能在有1,000次特定类型的请求之后发生，而这种请求在之前的环境中从未发生过。理解根本原因或回滚新版本花了一些时间，因此这次事件成为了一个很好的教训，即在发布过程中引入更多的检查。
- en: 13.3 Operating the system
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 操作系统
- en: It is never enough to build the system and integrate it directly with other
    components that need its output in terms of product logic. Any system requires
    additional connections for healthy operations, both tech and non-tech related.
    Some are required to smooth the maintenance and operations (from both the engineering
    and product perspective); others are caused by implicit nonfunctional requirements
    related to the system (such as legal or privacy concerns). Let’s name a few.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 仅构建系统并将其直接与其他需要其输出的组件集成，从产品逻辑的角度来看，这永远是不够的。任何系统都需要额外的连接来保证健康运行，这些连接既与技术相关，也与非技术相关。有些是为了使维护和运营更加顺畅（从工程和产品两个角度来看）；有些是由于与系统相关的隐含的非功能性需求引起的（例如法律或隐私问题）。让我们列举一些。
- en: 13.3.1 Tech-related connections
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.1 技术相关连接
- en: CI is usually the first element of the whole infrastructure to be set up. It
    helps identify and resolve integration problems while facilitating smoother and
    faster development processes. Typical tasks for CI are running tests (unit or
    integration) and building artifacts that will be used down the stream (e.g., for
    further deployment). However, there may be other needs covered on the CI level,
    such as security testing, performance testing, cost analysis (“Does this release
    require us to spin out more cloud servers?”), deployment to test environments,
    linting the code style, reporting key metrics, and many more.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: CI通常是整个基础设施中首先设置的元素。它有助于识别和解决集成问题，同时促进更顺畅和更快的开发过程。CI的典型任务包括运行测试（单元或集成）和构建将用于下游（例如，用于进一步部署）的工件。然而，CI级别可能还有其他需求，例如安全测试、性能测试、成本分析（“这个发布是否需要我们启动更多的云服务器？”）、部署到测试环境、代码风格检查、报告关键指标等等。
- en: Two main things that are not part of the system’s data but need to be stored
    are logs and metrics. Usually, there is a common approach to how logs and metrics
    are stored, aggregated, and monitored in a company, and you just need to follow
    the common way. We’ll elaborate a bit more on this topic in the next chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 需要存储但不是系统数据一部分的两个主要事物是日志和指标。通常，公司中日志和指标存储、聚合和监控的方法是通用的，你只需要遵循常规方式。我们将在下一章中对此话题进行更详细的阐述。
- en: The system’s performance may be prone to malfunctions, and it should not come
    as a surprise. Thus, the system should be connected to the alerting and incident
    management platform used in the company, so the person on call will be aware of
    a potential incident and react appropriately.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的性能可能会出现故障，这并不令人惊讶。因此，系统应该连接到公司使用的警报和事件管理平台，这样值班人员就会意识到潜在的故障并做出适当的反应。
- en: But how do they react, exactly? Here you may need to prepare specific cookbooks
    describing what expected failure modes are and how to approach them. Also, there
    may be an additional toolset to help with firefighting, like an admin panel for
    configuration, system-specific dashboards, and so on, which we will cover in chapter
    16\. Again, usually there is a company standard shared between ML and non-ML systems,
    so it is very likely that you will only need to adapt the software toolset already
    in use without reinventing the wheel.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但他们具体是如何反应的呢？在这里，你可能需要准备特定的食谱，描述预期的故障模式以及如何处理它们。此外，可能还有一套额外的工具来帮助灭火，例如配置管理面板、系统特定的仪表板等等，这些内容我们将在第16章中进行介绍。再次强调，通常ML和非ML系统之间有一个公司标准，所以你很可能只需要适应现有的软件工具集，而不需要重新发明轮子。
- en: Designing a system requires considering the whole life cycle of the system,
    not just the happy path, and being a little paranoid helps.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个系统需要考虑系统的整个生命周期，而不仅仅是顺利的路径，并且保持一点偏执是有帮助的。
- en: 13.3.2 Non-tech-related connections
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.2 非技术相关连接
- en: Other than purely technical aspects of operations, there are some non-tech aspects
    that should be considered. They are often related to customer success or compliance,
    and they are not always obvious. What should we do if the user wants all their
    personal data to be purged as allowed by the General Data Protection Regulation
    (recall chapter 11 and imagine how deeply their data can propagate)? Is there
    a regulation forcing the model to be explainable, and what is the best way to
    follow it without sacrificing the model’s performance? What if a high-level executive
    or a startup investor faces a bug in the system and gets mad? How do we debug
    the system’s behavior in hard-to-reproduce scenarios (e.g., a defect can be only
    reproduced by an aforementioned executive’s user account)? All these questions
    should be answered before the system is released, and the answers should be at
    least briefly reflected at the design stage. Otherwise, the changes may be too
    expensive to implement later. Often it requires building additional components,
    like some user impersonation mechanism or an admin panel for data management or
    model explainability, and it may take a lot of project time and require help from
    other teams (e.g., Legal or Compliance to understand the regulations or Web Development
    to build the required dashboard).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了操作的技术方面之外，还有一些非技术方面应该考虑。它们通常与客户成功或合规性相关，并且并不总是显而易见。如果用户希望所有个人数据都按照通用数据保护条例（回想第11章，想象他们的数据可以传播得多深）被清除，我们应该怎么办？是否有法规强制模型可解释，以及在不牺牲模型性能的情况下遵循它的最佳方式是什么？如果高级管理人员或初创投资者在系统中遇到错误并感到愤怒怎么办？我们如何在难以重现的场景中调试系统的行为（例如，缺陷只能通过上述高级管理人员的用户账户重现）？在系统发布之前，所有这些问题都应该得到解答，并且这些答案至少应该在设计阶段简要反映出来。否则，后续的更改可能过于昂贵而难以实施。通常需要构建额外的组件，例如一些用户模拟机制或用于数据管理和模型可解释性的管理面板，这可能需要大量的项目时间和需要其他团队（例如法律或合规性团队了解法规或网络开发团队构建所需的仪表板）。
- en: From our experience, all these additional connections and considerations usually
    take more time than the core system itself, and the bigger the company, the more
    effort it takes. Given current trends, it’s not likely to improve in the near
    future as even more regulations related to ML and privacy are being applied globally.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，所有这些额外的连接和考虑通常比核心系统本身花费更多的时间，公司规模越大，所需努力就越多。鉴于当前趋势，在不久的将来不太可能有所改善，因为全球范围内正在应用更多与机器学习和隐私相关的法规。
- en: 13.4 Overrides and fallbacks
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 覆盖和后备方案
- en: 'Your system may have a legit reason to fail. An example of such a reason could
    be an external dependency: you pull out a chunk of data from a third-party API,
    and at some point, it’s just not available. That is one of the situations where
    you may want to have a fallback solution.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您的系统可能有一个合法的失败原因。这样的原因的一个例子可能是外部依赖：您从第三方API中提取了一块数据，而在某个时刻，它就不再可用了。这就是您可能想要有一个后备解决方案的情况之一。
- en: A *fallback* is a backup plan or an alternative solution that can be used when
    the primary plan or solution fails or is not available. We use it to ensure that
    the system can still function and make decisions even if the primary ML model
    has failed for whatever reason.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**后备方案**是指在主计划或解决方案失败或不可用时可以使用的备用计划或替代解决方案。我们使用它来确保即使在主机器学习模型因任何原因失败的情况下，系统仍然可以运行并做出决策。'
- en: This can be particularly important in systems used for critical tasks or in
    industries where even the shortest downtime can lead to significant consequences.
    For example, a fallback can be crucial for a model used to predict equipment failures
    in a manufacturing setting, ensuring that production can continue even if the
    primary model experiences problems.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这在用于关键任务或即使最短的中断也可能导致重大后果的行业中尤为重要。例如，对于用于预测制造环境中设备故障的模型，后备方案可能是至关重要的，确保即使在主模型遇到问题时，生产也能继续进行。
- en: Another reason to use a fallback is to provide an alternative solution when
    the primary system is unable to provide a satisfactory answer or a confident prediction
    or when the primary model’s output is outside the acceptable range.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用后备方案的另一个原因是，当主系统无法提供令人满意的答案或自信的预测，或者当主模型的输出超出可接受范围时，提供一个替代解决方案。
- en: There are quite a few different approaches that can be used for implementing
    a fallback. One common approach is to use a secondary ML model, which can be trained
    on a different set of data or using a different algorithm. It might be a simpler
    baseline solution as we reviewed in chapter 8 or a dual-model setup. In this setup,
    the first model is built using only stable features, while the second model is
    used to correct the output of the main model using a larger feature set. The models
    can be used together, with the output of one model chosen over the other based
    on the input data or a predetermined rule. Alternatively, input feature drift
    monitoring (see chapter 14) can be set up for the “core” model to detect crucial
    shifts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 实现后备方案有相当多的不同方法。一个常见的方法是使用一个辅助的机器学习模型，这个模型可以在不同的数据集或使用不同的算法上训练。它可能是一个更简单的基线解决方案，如我们在第8章中回顾的，或者是一个双模型设置。在这个设置中，第一个模型仅使用稳定特征构建，而第二个模型使用更大的特征集来纠正主模型的输出。这些模型可以一起使用，根据输入数据或预定的规则选择一个模型的输出。或者，可以为“核心”模型设置输入特征漂移监控（见第14章）以检测关键的变化。
- en: Another option is to use a rule-based system as a fallback, which can provide
    a stable and predictable response when the model is unavailable or is performing
    poorly. It is also possible to use a combination of these approaches, such as
    using a rule-based system to handle simple cases and the ML model for more complex
    scenarios (however, this alone introduces additional complexity and breakpoints).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用基于规则的系统作为后备方案，当模型不可用或表现不佳时，它可以提供稳定且可预测的响应。也有可能结合使用这些方法，例如使用基于规则的系统处理简单情况，而使用机器学习模型处理更复杂的情况（然而，这本身也引入了额外的复杂性和断点）。
- en: As with baselines, a simple constant can be our fallback as well. Finally, sometimes
    a fallback solution is to reply with an explicit error message.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与基线一样，一个简单的常数也可以作为我们的后备方案。最后，有时后备解决方案是回复一个明确的错误信息。
- en: A fallback solution should always have a plan in place for activating the fallback
    and switching between the ML model and a fallback system. It can be either automatic
    (triggered by a monitoring event), manual, or hybrid, depending on the use case.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 后备解决方案应该始终有一个计划来激活后备方案，并在机器学习模型和后备系统之间切换。它可以是自动的（由监控事件触发）、手动的或混合的，具体取决于用例。
- en: One custom type of fallback is an override. It is a way to manually override
    the model’s output when it is signaling a bad prediction. One example may be dropping
    the model’s output and using a constant instead when the model’s prediction is
    beyond the acceptable range or when the model’s confidence is too low. Another
    reason to use an override is related to a release cycle. For example, a customer
    complains about the model failing in a very specific scenario. Ideally, we need
    to ensure this scenario is represented in the training data, retrain the model,
    run all the checks, and deploy it. But, as we discussed earlier, it may take a
    while. So we can override the model’s output for this particular scenario using
    a rule-based approach, keep the customer happy, and address it properly in the
    following release.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一种自定义的后备类型是覆盖。这是一种在模型发出不良预测信号时手动覆盖模型输出的方式。一个例子可能是在模型的预测超出可接受范围或模型置信度太低时，放弃模型的输出并使用一个常数代替。使用覆盖的另一个原因与发布周期有关。例如，客户抱怨模型在非常特定的场景中失败。理想情况下，我们需要确保这个场景在训练数据中得到体现，重新训练模型，运行所有检查，然后部署它。但是，正如我们之前讨论的，这可能需要一段时间。因此，我们可以使用基于规则的策略覆盖模型在这个特定场景的输出，让客户满意，并在下一个版本中正确处理它。
- en: 'The downside of overrides is that they are not transparent and can be easily
    forgotten. For this reason, it is important to have a way to track them and to
    have a plan for how to address them properly; otherwise, they may turn into a
    technical debt. The positive side effect of having many overrides is that collections
    of overrides can be used to improve the model via *multisource weak supervision*—a
    technique when unlabeled data is labeled with “labeling functions” (these heuristics
    are not perfect but are cheap to implement). The labeling functions provide a
    noisy dataset that becomes a foundation for model training. More details on this
    technique can be found in papers by Alexander Ratner et al., “Data Programming:
    Creating Large Training Sets, Quickly” ([https://arxiv.org/abs/1605.07723](https://arxiv.org/abs/1605.07723))
    and “Training Complex Models with Multi-Task Weak Supervision” ([https://arxiv.org/abs/1810.02840](https://arxiv.org/abs/1810.02840)).
    The concept of multisource weak supervision has gained recognition in the industry
    thanks to the popular library named Snorkel ([https://www.snorkel.org/](https://www.snorkel.org/)).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖（override）的缺点是它们不透明且容易被遗忘。因此，有一个跟踪它们的方法以及一个如何妥善处理它们的计划是很重要的；否则，它们可能会变成技术债务。拥有许多覆盖的好处是，覆盖集合可以通过*多源弱监督*来改进模型——这是一种在未标记数据上使用“标记函数”进行标记的技术（这些启发式方法并不完美，但易于实现）。标记函数提供了一个噪声数据集，这成为模型训练的基础。关于这项技术的更多细节可以在亚历山大·拉特纳等人撰写的论文中找到，“数据编程：快速创建大型训练集”([https://arxiv.org/abs/1605.07723](https://arxiv.org/abs/1605.07723))和“使用多任务弱监督训练复杂模型”([https://arxiv.org/abs/1810.02840](https://arxiv.org/abs/1810.02840))。多源弱监督的概念因名为Snorkel的流行库而受到行业认可([https://www.snorkel.org/](https://www.snorkel.org/))。
- en: 'Arseny’s colleague once implemented a more elegant solution that helped address
    the limits of a long release cycle. He worked on a named entity recognition problem,
    and sometimes the model was not able to recognize some entities that were important
    to customers. However, training a new model after the problem had been found was
    not an option because of the long training time. So he implemented a solution
    based on the knowledge base: before running the model, the input text was checked
    against the knowledge base, and if the possible entity was found there, it was
    used as a hint for the model. It allowed the team to fix the problem without retraining.
    Adding a sample to the knowledge base could be done in a minute by a nontechnical
    person, so the problem could be addressed promptly. The solution is described
    in more detail in a blog post ([https://mng.bz/BgG1](https://mng.bz/BgG1)). This
    case was somewhat similar to overrides, but it augmented the model’s inputs, not
    outputs.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 阿尔谢尼的同事曾经实施了一个更优雅的解决方案，帮助解决了长期发布周期的限制。他处理了一个命名实体识别问题，有时模型无法识别对客户重要的某些实体。然而，由于训练时间过长，在发现问题后重新训练新模型不是一个选择。因此，他基于知识库实现了一个解决方案：在运行模型之前，将输入文本与知识库进行核对，如果找到了可能的实体，则将其用作模型的提示。这允许团队在不重新训练的情况下解决问题。非技术人员可以在一分钟内将样本添加到知识库中，因此可以迅速解决问题。该解决方案在博客文章中有更详细的描述([https://mng.bz/BgG1](https://mng.bz/BgG1))。这个案例与覆盖有些相似，但它增加了模型的输入，而不是输出。
- en: '13.5 Design document: Integration'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 设计文档：集成
- en: Approaches to integration for both Supermegaretail and PhotoStock Inc. aim at
    creating user-friendly, fast, and efficient mechanisms for either inventory predictions
    or search results.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 超级大零售和PhotoStock Inc.的集成方法旨在创建用户友好、快速和高效的机制，用于库存预测或搜索结果。
- en: 13.5.1 Integration for Supermegaretail
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.1 超级大零售的集成
- en: Supermegaretail’s integration strategy is tailored to offer a seamless, dynamic,
    and highly responsive prediction system that helps manage inventory.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 超级大零售的集成策略旨在提供无缝、动态且高度响应的预测系统，以帮助管理库存。
- en: 'Design document: Supermegaretail'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设计文档：超级大零售
- en: X. Integration
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: X. 集成
- en: i. Fallback strategies
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: i. 回退策略
- en: 'Fallbacks are crucial for maintaining operational efficiency in the face of
    unforeseen circumstances. Supermegaretail has adopted a multitiered fallback system:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在面对不可预见的情况时，回退（fallback）对于保持运营效率至关重要。超级大零售采用了多级回退系统：
- en: '*Primary fallback**—*The primary model is trained on a subset of the most significant
    features. It will be used if no feature drift/problems are detected within this
    subset.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主要回退**——*主要模型在最重要的特征子集上训练。如果没有在这个子集中检测到特征漂移/问题，它将被使用。'
- en: '*Secondary fallback**—*Our next layer of fallback involves time-series models
    like SARIMA or Prophet, which we explored in section 4.4\. These models are less
    dependent on external features, allowing for more robust predictions if drift
    occurs.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二级回退**—*我们的下一层回退涉及SARIMA或Prophet等时间序列模型，我们在第4.4节中探讨了这些模型。这些模型对外部特征的依赖性较低，如果发生漂移，可以提供更稳健的预测。'
- en: '*Tertiary fallback**—*As a last resort, we would predict sales akin to the
    previous week’s data, with modifications for expected events and holidays.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*三级回退**—*作为最后的手段，我们会预测与上周数据类似的销售额，并对预期事件和假日进行修改。'
- en: The system monitors for data drifts and quality problems, triggering alarms
    that automatically switch to the appropriate fallback to ensure the most accurate
    predictions possible.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会监控数据漂移和质量问题，触发警报，自动切换到适当的回退，以确保尽可能准确的预测。
- en: ii. API design
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ii. API设计
- en: '*HTTP API handler**—*This component will manage requests and responses, interfacing
    with users in a structured JSON format.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HTTP API处理器**—*此组件将管理请求和响应，以结构化的JSON格式与用户进行交互。'
- en: '*Model API**—*This will extract predictions directly from the model.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模型API**—*这将直接从模型中提取预测。'
- en: The request format is
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请求格式是
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The response format is
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 响应格式是
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: iii. Release cycle
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: iii. 发布周期
- en: A. Release of the wrapper vs. release of the model
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: A. 包装器发布与模型发布
- en: Within our integration strategy, the release of the wrapper and the release
    of the model represent two distinct processes. The following are the nuances for
    each.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的集成策略中，包装器的发布和模型的发布代表两个不同的过程。以下是对每个过程的细微差别。
- en: 'For the release of the wrapper (infrastructure), we should consider the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包装器（基础设施）的发布，我们应该考虑以下因素：
- en: '*Frequency and timeline.* The release typically happens less frequently than
    that of the model. As demand patterns can shift over the night, it is important
    to be able to incorporate them into the model through training.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*频率和时间表.* 释放通常比模型的频率低。由于需求模式可能会在夜间发生变化，因此能够通过训练将这些模式纳入模型中非常重要。'
- en: '*Dependencies.* Infrastructure releases are mostly dependent on software updates,
    third-party services, or system requirements. Any changes in such areas may necessitate
    a new release.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖项.* 基础设施发布主要依赖于软件更新、第三方服务或系统要求。这些领域的任何变化都可能需要新的发布。'
- en: '*Testing.* Comprehensive integration testing is a must to ensure all components
    work harmoniously. It is also crucial to ensure backward compatibility, so existing
    services are not disrupted.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试.* 综合集成测试是必须的，以确保所有组件协同工作。同时，确保向后兼容性也非常关键，以避免现有服务中断。'
- en: '*Rollout.* This usually employs standard software deployment strategies. Depending
    on the nature of the changes, a blue-green deployment might not always be necessary,
    especially if the changes are not user-facing and do not affect batch jobs.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*推出.* 这通常采用标准的软件部署策略。根据变更的性质，蓝色-绿色部署可能并不总是必要的，特别是如果变更不是面向用户的，并且不影响批量作业。'
- en: '*Monitoring.* The focus will be on system health, uptime, response times, and
    any error rates.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*监控.* 重点将放在系统健康、正常运行时间、响应时间和任何错误率上。'
- en: For the release of the model, we should consider *the following:*
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模型的发布，我们应该考虑以下因素：
- en: '*Frequency and timeline**—*Model releases are more frequent and are tied to
    the availability of new data, changes in data patterns, or significant improvements
    in modeling techniques.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*频率和时间表**—*模型发布更频繁，并与新数据的可用性、数据模式的变化或建模技术的重大改进相关联。'
- en: '*Dependencies**—*These predominantly rely on the quality and quantity of new
    training data. Any drifts in data patterns or introduction of new data sources
    can trigger the model’s update.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖项**—*这些主要依赖于新训练数据的质量和数量。数据模式的变化或新数据源的引入可能会触发模型的更新。'
- en: '*Testing**—*Before rolling out, the model undergoes a rigorous offline validation.
    Once validated, it might be tested in a shadow mode, where its predictions run
    alongside the current model but are not used. This helps in comparing and validating
    the new model’s performance in a real-world scenario without any risks.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试**—*在推出之前，模型会经过严格的离线验证。一旦验证通过，它可能会在影子模式下进行测试，其中其预测与当前模型并行运行，但不会被使用。这有助于在没有任何风险的情况下，比较和验证新模型在真实世界场景中的性能。'
- en: '*Rollout**—*When introducing a new model, it’s not just about deploying the
    model file. There’s also a need to ensure that any preprocessing steps, feature
    engineering, and other pipelines are consistent with what the model expects.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发布**—*在引入新模型时，不仅仅是部署模型文件。还需要确保任何预处理步骤、特征工程和其他管道与模型期望的一致。'
- en: '*Monitoring.* The primary focus remains on model performance metrics. Also,
    keeping an eye on data drift is essential. See chapter 14 for more details.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*监控.* 主要关注模型性能指标。同时，关注数据漂移也是必要的。详见第14章。'
- en: B. Interplay between wrapper and model releases
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: B. 包装器和模型发布之间的相互作用
- en: In cases where the infrastructure has updates that would affect the model (e.g.,
    changes in data pipelines), coordination between the two releases becomes vital.
    Additionally, any significant changes to the model’s architecture might require
    updates to the wrapper to accommodate the changes. By treating them as separate
    processes yet ensuring they’re coordinated, we maintain the system’s stability
    while continuously improving its capabilities.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础设施更新会影响模型（例如，数据管道的变化）的情况下，两个发布之间的协调变得至关重要。此外，模型架构的任何重大变化可能需要更新包装器以适应这些变化。通过将它们视为独立的过程，同时确保它们协调一致，我们保持系统的稳定性，并持续提高其能力。
- en: iv. Operational concerns
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: iv. 运营问题
- en: Feedback is integral for continuous improvement. A feedback mechanism, inclusive
    of an override function, should be available to internal users. Not only does
    this aid in refining the predictions, but it also gives business users a sense
    of control and adaptability based on real-time insights.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 反馈对于持续改进至关重要。应向内部用户提供一个包含覆盖功能的反馈机制。这不仅有助于改进预测，还让业务用户根据实时洞察获得控制和适应性。
- en: v. Nonengineering considerations
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: v. 非工程考虑因素
- en: The integration strategy will also take into account nonengineering factors—for
    instance
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 集成策略还将考虑非工程因素——例如
- en: '*Admin panels*—Crucial for managing the system and obtaining a high-level overview'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理面板*—对于管理和获取系统高级概述至关重要'
- en: '*Integration with company-level dashboards*—For company-wide visibility and
    decision-making'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与公司级仪表板的集成*—为了实现公司范围内的可见性和决策'
- en: '*Additional reports*—Essential for deeper insights and analysis'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*附加报告*—对于深入了解和分析至关重要'
- en: '*Overrides*—A necessary feature to account for manual adjustments based on
    unforeseen or unique circumstances'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*覆盖*—考虑到不可预见或独特情况下的手动调整的必要功能'
- en: Furthermore, standard CI tools used in the company, along with a typical scheduler,
    will be integrated to maintain consistency and optimize workflow.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，公司使用的标准CI工具以及典型的调度器将被集成，以保持一致性和优化工作流程。
- en: vi. Deployment
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: vi. 部署
- en: Given that our audience primarily consists of internal customers and the frequent
    batch jobs, there’s no immediate need for green-blue or canary deployment. The
    absence of end-user traffic eliminates the need for such staggered deployments,
    simplifying our rollout strategy.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的受众主要是内部客户和频繁的批量作业，因此目前没有绿色-蓝色或金丝雀部署的迫切需要。由于没有终端用户流量，这种分阶段部署的需求不存在，简化了我们的发布策略。
- en: 13.5.2 Integration for PhotoStock Inc.
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.2 PhotoStock Inc.的集成
- en: The integration strategy for PhotoStock Inc. is focused on providing the most
    relevant search results regardless of the complexity of search queries while maintaining
    prompt responses.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: PhotoStock Inc.的集成策略专注于提供最相关的搜索结果，无论搜索查询的复杂性如何，同时保持快速响应。
- en: 'Design document: PhotoStock Inc.'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设计文档：PhotoStock Inc.
- en: X. Integration
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: X. 集成
- en: i. API design
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: i. API设计
- en: Our search engine needs to expose one HTTP API handler, which takes a query
    string + optional additional filters (e.g., price, collection, resolution, author,
    etc.) and returns a list of IDs of the photos that match the query sorted by relevance.
    Besides these product-focused parameters, we need to pass more technical ones,
    like `version`, `limit`, and `request_id`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的搜索引擎需要暴露一个HTTP API处理器，它接受一个查询字符串+可选的附加过滤器（例如，价格、收藏、分辨率、作者等）并返回与查询匹配的图片ID列表，按相关性排序。除了这些以产品为中心的参数外，我们还需要传递更多技术参数，如`version`、`limit`和`request_id`。
- en: The handler will be only used internally and will not be exposed to the public,
    so we don’t need to worry about authentication and authorization, given that it’s
    operating within a private network.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器仅用于内部，不会公开暴露，因此由于它在一个私有网络中运行，我们不需要担心身份验证和授权。
- en: We can’t keep the service fully stateless (we need to own index and overrides),
    but all the query-related metadata should be handled by the backend service as
    they already store other users’ metadata.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法使服务完全无状态（我们需要拥有索引和覆盖），但所有与查询相关的元数据都应该由后端服务处理，因为它们已经存储了其他用户的元数据。
- en: Under the hood, we will use a simple cascade to narrow the search results. We
    will first filter by the optional filters, then fetch the nearest neighbors of
    the query string in the embedding space, and finally sort the results by relevance
    with the final model.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，我们将使用简单的级联来缩小搜索结果。我们首先根据可选的过滤器进行过滤，然后从嵌入空间中获取查询字符串的最近邻，最后根据相关性对结果进行排序。
- en: We consider using Qdrant ([https://qdrant.tech/](https://qdrant.tech/)) as a
    rapid vector database capable of filtering + fetching candidates at scale; however,
    it has not been used in the company before, so we may need to test it properly
    before using it in production. Alternatively, we can consider using other vector
    databases if needed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑使用Qdrant ([https://qdrant.tech/](https://qdrant.tech/))作为一个能够大规模过滤和获取候选者的快速向量数据库；然而，公司之前尚未使用过它，因此在使用生产环境之前，我们可能需要对其进行适当的测试。或者，如果需要，我们还可以考虑使用其他向量数据库。
- en: The request format is
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请求格式是
- en: '[PRE5]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: GET /search?query=<query_string>&filters=<filters>&version=<version>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: GET /search?query=<query_string>&filters=<filters>&version=<version>
- en: '&limit=<limit>&request_id=<request_id>'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '&limit=<limit>&request_id=<request_id>'
- en: '[PRE6]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The response format is
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 响应格式是
- en: '[PRE7]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '{'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"results": ['
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"results": ['
- en: '{'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"id": <photo_id>,'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"id": <photo_id>,'
- en: '"score": <score>'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"score": <score>'
- en: '},'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: '...'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: ']'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE8]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Both the request and response are in the JSON format, as that’s the default
    format we use in our internal APIs. Structures of the request and response are
    simple and straightforward for now but can be extended in the future if needed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和响应都使用JSON格式，这是我们内部API中使用的默认格式。请求和响应的结构目前简单直接，但在需要时可以扩展。
- en: 'The underlying API should be layered in the following way:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 底层API应该按照以下方式分层：
- en: The HTTP API handler only serves as a proxy to the underlying API and does not
    contain any business logic; it just parses the request, passes it to the underlying
    API, wraps the response into a JSON format, and handles errors.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP API处理器仅作为底层API的代理，不包含任何业务逻辑；它只是解析请求，将其传递给底层API，将响应封装成JSON格式，并处理错误。
- en: The vector DB API is responsible for filtering and fetching candidates given
    the embedding of the query string.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量数据库API负责根据查询字符串的嵌入进行过滤和获取候选者。
- en: The model API is responsible for extracting the embeddings from a string and
    scoring the candidates.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型API负责从字符串中提取嵌入并评分候选者。
- en: The ranking API is responsible for sorting the candidates by relevance and applying
    possible overrides.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排名API负责根据相关性对候选者进行排序并应用可能的覆盖。
- en: ii. Release cycle
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ii. 发布周期
- en: We assume that model updates will be relatively rare as training takes a lot
    of time, and we don’t expect the data to change significantly over time. We can
    expect releases of a new model and relevant APIs every 1 to 2 months, while most
    hot updates will be related to index and overrides only.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设模型更新将相对较少，因为训练需要花费大量时间，我们也不期望数据随时间发生显著变化。我们可以预期每1到2个月发布一个新的模型和相关API，而大多数热更新将仅与索引和覆盖有关。
- en: The index is the core of the search engine, and it will require regular updates
    (for data, not software). We can add new items on a daily basis (e.g., with a
    batch job running every night) and be ready to update the index on demand if needed
    (e.g., removing banned images or adding a new image by special requests from VIP
    users).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是搜索引擎的核心，它将需要定期更新（针对数据，而不是软件）。我们可以每天添加新项目（例如，通过每晚运行的批处理作业），并在需要时准备更新索引（例如，删除被禁止的图像或根据VIP用户的特殊请求添加新图像）。
- en: iii. Operational concerns
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: iii. 运营关注点
- en: Many internal users can provide a lot of feedback on search results, so we need
    to provide them with appropriate tools. For a start, we can just add a “Report
    bad match” button to the search results page for internal PhotoStock Inc. users.
    It will send a request to the data gateway, so we save an event with the photo
    ID, search engine results page position, and query string to the data lake. We
    can then use this data during the model retraining stage and error analysis and
    for manual overrides. In the future, we can consider providing similar functionality
    to some external authenticated users (e.g., top buyers we trust).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 许多内部用户可以对搜索结果提供大量反馈，因此我们需要为他们提供适当的工具。一开始，我们可以在内部PhotoStock Inc.用户的搜索结果页面上添加一个“报告不良匹配”按钮。这将向数据网关发送请求，因此我们将照片ID、搜索引擎结果页位置和查询字符串保存到数据湖中。然后我们可以在模型重新训练阶段、错误分析和手动覆盖期间使用这些数据。未来，我们可以考虑为一些外部认证用户提供类似的功能（例如，我们信任的顶级买家）。
- en: iv. Overrides and fallbacks
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: iv. 覆盖和回退
- en: As a fallback, we’re going to use the existing search engine, which is based
    on Elasticsearch. While it’s not as good as the new one is set to become in terms
    of relevance, it’s still a decent search engine.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回退，我们将使用现有的基于Elasticsearch的搜索引擎。虽然它在相关性方面可能不如新设定的那么好，但它仍然是一个不错的搜索引擎。
- en: As for overrides, we may have manual overrides for certain queries, which we
    can store in a separate database. It may happen in case of poor relevancy for
    popular/critical queries, which we cannot fix with the model promptly enough.
    For now, it can be a simple key-value store where the key is a regex of the query
    string, and the value is the list of photo IDs, which we will use in the search
    engine results page. This solution is not very scalable, but it’s solid enough
    for the first version. We may want to make a simple UI for managing these overrides
    in the future.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 关于覆盖，我们可能对某些查询有手动覆盖，这些可以存储在一个单独的数据库中。这种情况可能发生在对流行/关键查询的相关性较差时，我们无法及时用模型修复。目前，它可能是一个简单的键值存储，其中键是查询字符串的正则表达式，值是照片ID的列表，我们将使用这些ID在搜索引擎结果页面上。这种解决方案的可扩展性不高，但对于第一个版本来说足够稳固。我们可能希望在将来为管理这些覆盖提供一个简单的用户界面。
- en: There is another possible type of override related to “bad photos” that we want
    to hide from the search results (e.g., photos with nudity/violence that passed
    moderation). However, if we suddenly realize a given image is no longer welcome
    in our search results, we can simply remove it from the index.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与“不良照片”相关的另一种可能的覆盖类型，我们希望从搜索结果中隐藏（例如，通过审查的裸露/暴力照片）。然而，如果我们突然意识到某个图像不再适合我们的搜索结果，我们可以简单地从索引中删除它。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Remember that integration is not a one-time event or a phase of the project
    but rather a continuous process that starts from the beginning of the project
    and ends only when the system is decommissioned.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，集成不是一个一次性的事件或项目的某个阶段，而是一个从项目开始到系统退役的持续过程。
- en: When selecting an API for your system, the two main qualities you should look
    for are simplicity and predictability.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在为您的系统选择API时，您应该寻找的两个主要品质是简洁性和可预测性。
- en: The API practices we consider effective with regard to ML systems are designing
    at least two layers of an API, separating the ML and IO components of an API when
    possible, building a client library for an API, and embedding feature toggle or
    its alternatives.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们认为对于机器学习系统而言，有效的API实践包括至少设计两层API，在可能的情况下将API的机器学习和IO组件分离，为API构建客户端库，以及嵌入功能开关或其替代方案。
- en: Having a fallback provides you with a backup plan or alternative solution that
    can be used when the primary plan or solution fails or is not available.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个回退方案或替代方案，可以在主要计划或解决方案失败或不可用时使用。
