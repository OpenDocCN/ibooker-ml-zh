- en: Chapter 3\. Data Wrangling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 数据整理
- en: 3.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.0 引言
- en: '*Data wrangling* is a broad term used, often informally, to describe the process
    of transforming raw data into a clean, organized format ready for use. For us,
    data wrangling is only one step in preprocessing our data, but it is an important
    step.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据整理*是一个广义术语，通常非正式地用来描述将原始数据转换为干净、有组织的格式，以便于使用的过程。对于我们来说，数据整理只是数据预处理的一个步骤，但是这是一个重要的步骤。'
- en: 'The most common data structure used to “wrangle” data is the dataframe, which
    can be both intuitive and incredibly versatile. Dataframes are tabular, meaning
    that they are based on rows and columns like you would see in a spreadsheet. Here
    is a dataframe created from data about passengers on the *Titanic*:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “整理”数据最常用的数据结构是数据框，它既直观又非常灵活。数据框是表格型的，意味着它们基于行和列，就像您在电子表格中看到的那样。这是一个根据*泰坦尼克号*乘客数据创建的数据框示例：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|  | 名称 | PClass | 年龄 | 性别 | 幸存 | 性别代码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29.00 | female | 1 | 1 |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 艾伦，伊丽莎白·沃尔顿小姐 | 1st | 29.00 | 女性 | 1 | 1 |'
- en: '| 1 | Allison, Miss Helen Loraine | 1st | 2.00 | female | 0 | 1 |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾莉森，海伦·洛林小姐 | 1st | 2.00 | 女性 | 0 | 1 |'
- en: '| 2 | Allison, Mr Hudson Joshua Creighton | 1st | 30.00 | male | 0 | 0 |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 艾莉森，哈德森·约书亚·克莱顿先生 | 1st | 30.00 | 男性 | 0 | 0 |'
- en: '| 3 | Allison, Mrs Hudson JC (Bessie Waldo Daniels) | 1st | 25.00 | female
    | 0 | 1 |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 艾莉森，哈德森JC夫人（贝西·沃尔多·丹尼尔斯） | 1st | 25.00 | 女性 | 0 | 1 |'
- en: '| 4 | Allison, Master Hudson Trevor | 1st | 0.92 | male | 1 | 0 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 艾莉森，哈德森·特雷弗小主人 | 1st | 0.92 | 男性 | 1 | 0 |'
- en: There are three important things to notice in this dataframe.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数据框中，有三个重要的事情需要注意。
- en: First, in a dataframe each row corresponds to one observation (e.g., a passenger)
    and each column corresponds to one feature (gender, age, etc.). For example, by
    looking at the first observation we can see that Miss Elisabeth Walton Allen stayed
    in first class, was 29 years old, was female, and survived the disaster.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在数据框中，每一行对应一个观察结果（例如一个乘客），每一列对应一个特征（性别、年龄等）。例如，通过查看第一个观察结果，我们可以看到伊丽莎白·沃尔顿·艾伦小姐住在头等舱，年龄为29岁，是女性，并且幸存于这场灾难。
- en: Second, each column contains a name (e.g., `Name`, `PClass`, `Age`) and each
    row contains an index number (e.g., `0` for the lucky Miss Elisabeth Walton Allen).
    We will use these to select and manipulate observations and features.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在数据框中，每一行对应一个观察结果（例如一个乘客），每一列对应一个特征（性别、年龄等）。例如，通过查看第一个观察结果，我们可以看到伊丽莎白·沃尔顿·艾伦小姐住在头等舱，年龄为29岁，是女性，并且幸存于这场灾难。
- en: Third, two columns, `Sex` and `SexCode`, contain the same information in different
    formats. In `Sex`, a woman is indicated by the string `female`, while in `SexCode`,
    a woman is indicated by using the integer `1`. We will want all our features to
    be unique, and therefore we will need to remove one of these columns.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，两列`Sex`和`SexCode`以不同格式包含相同的信息。在`Sex`中，女性用字符串`female`表示，而在`SexCode`中，女性用整数`1`表示。我们希望所有的特征都是唯一的，因此我们需要删除其中一列。
- en: In this chapter, we will cover a wide variety of techniques to manipulate dataframes
    using the pandas library with the goal of creating a clean, well-structured set
    of observations for further preprocessing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖使用pandas库操作数据框的各种技术，旨在创建一个干净、结构良好的观察结果集以便进行进一步的预处理。
- en: 3.1 Creating a Dataframe
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 创建数据框
- en: Problem
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a new dataframe.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要创建一个新的数据框。
- en: Solution
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'pandas has many methods for creating a new DataFrame object. One easy method
    is to instantiate a `DataFrame` using a Python dictionary. In the dictionary,
    each key is a column name and the value is a list, where each item corresponds
    to a row:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: pandas有许多用于创建新数据框对象的方法。一个简单的方法是使用Python字典实例化一个`DataFrame`。在字典中，每个键是列名，每个值是一个列表，其中每个项目对应一行：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|  | Name | Age | Driver |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  | 名称 | 年龄 | 驾驶员 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | Jacky Jackson | 38 | True |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 杰基·杰克逊 | 38 | True |'
- en: '| 1 | Steven Stevenson | 25 | False |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 史蒂文·史蒂文森 | 25 | False |'
- en: 'It’s easy to add new columns to any dataframe using a list of values:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用值列表很容易向任何数据框添加新列：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  | Name | Age | Driver | Eyes |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|  | 名称 | 年龄 | 驾驶员 | 眼睛 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | Jacky Jackson | 38 | True | Brown |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 杰基·杰克逊 | 38 | True | Brown |'
- en: '| 1 | Steven Stevenson | 25 | False | Blue |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 史蒂文·史蒂文森 | 25 | False | 蓝色 |'
- en: Discussion
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: pandas offers what can feel like an infinite number of ways to create a DataFrame.
    In the real world, creating an empty DataFrame and then populating it will almost
    never happen. Instead, our DataFrames will be created from real data we have loaded
    from other sources (e.g., a CSV file or database).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Getting Information about the Data
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to view some characteristics of a DataFrame.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the easiest things we can do after loading the data is view the first
    few rows using `head`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29.0 | female | 1 | 1 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| 1 | Allison, Miss Helen Loraine | 1st | 2.0 | female | 0 | 1 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: 'We can also take a look at the number of rows and columns:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can get descriptive statistics for any numeric columns using `describe`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|  | Age | Survived | SexCode |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| count | 756.000000 | 1313.000000 | 1313.000000 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| mean | 30.397989 | 0.342727 | 0.351866 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| std | 14.259049 | 0.474802 | 0.477734 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| min | 0.170000 | 0.000000 | 0.000000 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| 25% | 21.000000 | 0.000000 | 0.000000 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| 50% | 28.000000 | 0.000000 | 0.000000 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| 75% | 39.000000 | 1.000000 | 1.000000 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| max | 71.000000 | 1.000000 | 1.000000 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: 'Additionally, the `info` method can show some helpful information:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Discussion
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After we load some data, it’s a good idea to understand how it’s structured
    and what kind of information it contains. Ideally, we would view the full data
    directly. But with most real-world cases, the data could have thousands to hundreds
    of thousands to millions of rows and columns. Instead, we have to rely on pulling
    samples to view small slices and calculating summary statistics of the data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In our solution, we are using a toy dataset of the passengers of the *Titanic*.
    Using `head`, we can look at the first few rows (five by default) of the data.
    Alternatively, we can use `tail` to view the last few rows. With `shape` we can
    see how many rows and columns our DataFrame contains. With `describe` we can see
    some basic descriptive statistics for any numerical column. And, finally, `info`
    displays a number of helpful data points about the DataFrame, including index
    and column data types, non-null values, and memory usage.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that summary statistics do not always tell the full story.
    For example, pandas treats the columns `Survived` and `SexCode` as numeric columns
    because they contain 1s and 0s. However, in this case the numerical values represent
    categories. For example, if `Survived` equals 1, it indicates that the passenger
    survived the disaster. For this reason, some of the summary statistics provided
    don’t make sense, such as the standard deviation of the `SexCode` column (an indicator
    of the passenger’s gender).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Slicing DataFrames
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to select a specific subset data or slices of a DataFrame.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `loc` or `iloc` to select one or more rows or values:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can use `:` to define the slice of rows we want, such as selecting the second,
    third, and fourth rows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`:`来定义我们想要的行切片，比如选择第二、第三和第四行：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|  | 名称 | PClass | 年龄 | 性别 | 幸存 | 性别代码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 1 | Allison, Miss Helen Loraine | 1st | 2.0 | female | 0 | 1 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾莉森小姐海伦·洛林 | 1st | 2.0 | 女性 | 0 | 1 |'
- en: '| 2 | Allison, Mr Hudson Joshua Creighton | 1st | 30.0 | male | 0 | 0 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 艾莉森先生哈德森·乔舒亚·克莱顿 | 1st | 30.0 | 男性 | 0 | 0 |'
- en: '| 3 | Allison, Mrs Hudson JC (Bessie Waldo Daniels) | 1st | 25.0 | female |
    0 | 1 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 艾莉森夫人哈德森JC（贝西·沃尔多·丹尼尔斯） | 1st | 25.0 | 女性 | 0 | 1 |'
- en: 'We can even use it to get all rows up to a point, such as all rows up to and
    including the fourth row:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用它来获取某个点之前的所有行，比如包括第四行在内的所有行：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  | 名称 | PClass | 年龄 | 性别 | 幸存 | 性别代码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29.0 | female | 1 | 1 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 艾伦小姐伊丽莎白·沃尔顿 | 1st | 29.0 | 女性 | 1 | 1 |'
- en: '| 1 | Allison, Miss Helen Loraine | 1st | 2.0 | female | 0 | 1 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾莉森小姐海伦·洛林 | 1st | 2.0 | 女性 | 0 | 1 |'
- en: '| 2 | Allison, Mr Hudson Joshua Creighton | 1st | 30.0 | male | 0 | 0 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 艾莉森先生哈德森·乔舒亚·克莱顿 | 1st | 30.0 | 男性 | 0 | 0 |'
- en: '| 3 | Allison, Mrs Hudson JC (Bessie Waldo Daniels) | 1st | 25.0 | female |
    0 | 1 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 艾莉森夫人哈德森JC（贝西·沃尔多·丹尼尔斯） | 1st | 25.0 | 女性 | 0 | 1 |'
- en: 'DataFrames do not need to be numerically indexed. We can set the index of a
    DataFrame to any value where the value is unique to each row. For example, we
    can set the index to be passenger names and then select rows using a name:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框不需要数值索引。我们可以将数据框的索引设置为任何唯一的值，比如乘客的姓名，然后通过姓名选择行：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Discussion
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'All rows in a pandas DataFrame have a unique index value. By default, this
    index is an integer indicating the row position in the DataFrame; however, it
    does not have to be. DataFrame indexes can be set to be unique alphanumeric strings
    or customer numbers. To select individual rows and slices of rows, pandas provides
    two methods:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: pandas数据框中的所有行都有唯一的索引值。默认情况下，这个索引是一个整数，表示数据框中的行位置；然而，并不一定要这样。数据框索引可以设置为唯一的字母数字字符串或客户号码。为了选择单独的行和行的切片，pandas提供了两种方法：
- en: '`loc` is useful when the index of the DataFrame is a label (e.g., a string).'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loc`在数据框的索引是标签时非常有用（例如，字符串）。'
- en: '`iloc` works by looking for the position in the DataFrame. For example, `iloc[0]`
    will return the first row regardless of whether the index is an integer or a label.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iloc`的工作原理是查找数据框中的位置。例如，`iloc[0]`将返回数据框中的第一行，无论索引是整数还是标签。'
- en: It is useful to be comfortable with both `loc` and `iloc` since they will come
    up a lot during data cleaning.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉`loc`和`iloc`在数据清洗过程中非常有用。
- en: 3.4 Selecting Rows Based on Conditionals
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.4 根据条件选择行
- en: Problem
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to select DataFrame rows based on some condition.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望根据某些条件选择数据框的行。
- en: Solution
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This can be done easily in pandas. For example, if we wanted to select all
    the women on the *Titanic*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这在pandas中很容易实现。例如，如果我们想要选择所有*泰坦尼克号*上的女性：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|  | 名称 | PClass | 年龄 | 性别 | 幸存 | 性别代码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29.0 | female | 1 | 1 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 艾伦小姐伊丽莎白·沃尔顿 | 1st | 29.0 | 女性 | 1 | 1 |'
- en: '| 1 | Allison, Miss Helen Loraine | 1st | 2.0 | female | 0 | 1 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾莉森小姐海伦·洛林 | 1st | 2.0 | 女性 | 0 | 1 |'
- en: Take a moment to look at the format of this solution. Our conditional statement
    is `dataframe['Sex'] == 'female'`; by wrapping that in `dataframe[]` we are telling
    pandas to “select all the rows in the DataFrame where the value of `dataframe['Sex']`
    is `'female'`.” These conditions result in a pandas series of booleans.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间看一下这个解决方案的格式。我们的条件语句是`dataframe['Sex'] == 'female'`；通过将其包装在`dataframe[]`中，我们告诉pandas“选择数据框中`dataframe['Sex']`值为'female'的所有行”。这些条件导致了一个布尔值的pandas系列。
- en: 'Multiple conditions are easy as well. For example, here we select all the rows
    where the passenger is a female 65 or older:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 多条件也很容易。例如，这里我们选择所有女性且年龄在65岁或以上的乘客：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  | 名称 | PClass | 年龄 | 性别 | 幸存 | 性别代码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 73 | Crosby, Mrs Edward Gifford (Catherine Elizabet... | 1st | 69.0 | female
    | 1 | 1 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 73 | 克罗斯比夫人爱德华·吉福德（凯瑟琳·伊丽莎白... | 1st | 69.0 | 女性 | 1 | 1 |'
- en: Discussion
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Conditionally selecting and filtering data is one of the most common tasks in
    data wrangling. You rarely want all the raw data from the source; instead, you
    are interested in only some subset of it. For example, you might only be interested
    in stores in certain states or the records of patients over a certain age.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据整理中，有条件地选择和过滤数据是最常见的任务之一。您很少需要源数据的所有原始数据；相反，您只对某些子集感兴趣。例如，您可能只对特定州的商店或特定年龄段的患者记录感兴趣。
- en: 3.5 Sorting Values
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.5 排序数值
- en: Problem
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to sort a dataframe by the values in a column.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要按列中的值对数据框进行排序。
- en: Solution
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the pandas `sort_values` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pandas 的 `sort_values` 函数：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | PClass | 年龄 | 性别 | 幸存 | 性别代码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 763 | Dean, Miss Elizabeth Gladys (Millvena) | 3rd | 0.17 | female | 1 |
    1 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 763 | 迪恩，伊丽莎白·格莱迪斯（米尔文娜）小姐 | 3rd | 0.17 | 女性 | 1 | 1 |'
- en: '| 751 | Danbom, Master Gilbert Sigvard Emanuel | 3rd | 0.33 | male | 0 | 0
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 751 | 丹博姆，吉尔伯特·西格瓦德·埃马纽尔大师 | 3rd | 0.33 | 男性 | 0 | 0 |'
- en: Discussion
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: During data analysis and exploration, it’s often useful to sort a DataFrame
    by a particular column or set of columns. The `by` argument to `sort_values` takes
    a list of columns by which to sort the DataFrame and will sort based on the order
    of column names in the list.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据分析和探索过程中，按照特定列或一组列对 DataFrame 进行排序通常非常有用。`sort_values` 的 `by` 参数接受一个列名列表，按列表中列名的顺序对
    DataFrame 进行排序。
- en: By default, the `ascending` argument is set to `True`, so it will sort the values
    lowest to highest. If we wanted the oldest passengers instead of the youngest,
    we could set it to `False`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ascending` 参数设置为 `True`，因此它会将值从最低到最高排序。如果我们想要最年长的乘客而不是最年轻的，我们可以将其设置为
    `False`。
- en: 3.6 Replacing Values
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.6 替换值
- en: Problem
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to replace values in a DataFrame.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在 DataFrame 中替换值。
- en: Solution
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The pandas `replace` method is an easy way to find and replace values. For
    example, we can replace any instance of `"female"` in the `Sex` column with `"Woman"`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 的 `replace` 方法是查找和替换值的简便方法。例如，我们可以将 `Sex` 列中的任何 `"female"` 实例替换为 `"Woman"`：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can also replace multiple values at the same time:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以同时替换多个值：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can also find and replace across the entire `DataFrame` object by specifying
    the whole dataframe instead of a single column:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过指定整个 DataFrame 而不是单个列来查找并替换 `DataFrame` 对象中的所有值：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | PClass | 年龄 | 性别 | 幸存 | 性别代码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29 | female | One | One |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 艾伦，伊丽莎白·沃尔顿小姐 | 1st | 29 | 女性 | One | One |'
- en: '| 1 | Allison, Miss Helen Loraine | 1st | 2 | female | 0 | One |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾莉森，洛林小姐海伦 | 1st | 2 | 女性 | 0 | One |'
- en: '`replace` also accepts regular expressions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace` 也接受正则表达式：'
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | PClass | 年龄 | 性别 | 幸存 | 性别代码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | Allen, Miss Elisabeth Walton | First | 29.0 | female | 1 | 1 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 艾伦，伊丽莎白·沃尔顿小姐 | First | 29.0 | 女性 | 1 | 1 |'
- en: '| 1 | Allison, Miss Helen Loraine | First | 2.0 | female | 0 | 1 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾莉森，洛林小姐海伦 | First | 2.0 | 女性 | 0 | 1 |'
- en: Discussion
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`replace` is a tool we use to replace values. It is simple and yet has the
    powerful ability to accept regular expressions.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace` 是我们用来替换值的工具。它简单易用，同时能够接受正则表达式。'
- en: 3.7 Renaming Columns
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.7 重命名列
- en: Problem
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to rename a column in a pandas DataFrame.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要在 pandas DataFrame 中重命名列。
- en: Solution
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Rename columns using the `rename` method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `rename` 方法重命名列：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|  | Name | Passenger Class | Age | Sex | Survived | SexCode |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | 乘客等级 | 年龄 | 性别 | 幸存 | 性别代码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29.0 | female | 1 | 1 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 艾伦，伊丽莎白·沃尔顿小姐 | 1st | 29.0 | 女性 | 1 | 1 |'
- en: '| 1 | Allison, Miss Helen Loraine | 1st | 2.0 | female | 0 | 1 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾莉森，洛林小姐海伦 | 1st | 2.0 | 女性 | 0 | 1 |'
- en: 'Notice that the `rename` method can accept a dictionary as a parameter. We
    can use the dictionary to change multiple column names at once:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`rename` 方法可以接受一个字典作为参数。我们可以使用字典一次性更改多个列名：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|  | Name | Passenger Class | Age | Gender | Survived | SexCode |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | 乘客等级 | 年龄 | 性别 | 幸存 | 性别代码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29.0 | female | 1 | 1 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 艾伦，伊丽莎白·沃尔顿小姐 | 1st | 29.0 | 女性 | 1 | 1 |'
- en: '| 1 | Allison, Miss Helen Loraine | 1st | 2.0 | female | 0 | 1 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾莉森，洛林小姐海伦 | 1st | 2.0 | 女性 | 0 | 1 |'
- en: Discussion
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Using `rename` with a dictionary as an argument to the `columns` parameter
    is my preferred way to rename columns because it works with any number of columns.
    If we want to rename all columns at once, this helpful snippet of code creates
    a dictionary with the old column names as keys and empty strings as values:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用将字典作为参数传递给 `columns` 参数的 `rename` 是我首选的重命名列的方法，因为它适用于任意数量的列。 如果我们想一次重命名所有列，这段有用的代码片段会创建一个以旧列名作为键、空字符串作为值的字典：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 3.8 Finding the Minimum, Maximum, Sum, Average, and Count
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.8 寻找最小值、最大值、总和、平均值和计数
- en: Problem
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to find the min, max, sum, average, or count of a numeric column.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要找到数值列的最小值、最大值、总和、平均值或计数。
- en: Solution
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'pandas comes with some built-in methods for commonly used descriptive statistics
    such as `min`, `max`, `mean`, `sum`, and `count`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 提供了一些内置方法，用于常用的描述统计，如 `min`、`max`、`mean`、`sum` 和 `count`：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Discussion
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In addition to the statistics used in the solution, pandas offers variance (`var`),
    standard deviation (`std`), kurtosis (`kurt`), skewness (`skew`), standard error
    of the mean (`sem`), mode (`mode`), median (`median`), value counts, and a number
    of others.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了解决方案中使用的统计数据外，pandas 还提供了方差(`var`)、标准差(`std`)、峰度(`kurt`)、偏度(`skew`)、均值标准误(`sem`)、众数(`mode`)、中位数(`median`)、值计数以及其他几种统计数据。
- en: 'Furthermore, we can also apply these methods to the whole DataFrame:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以将这些方法应用于整个 DataFrame：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 3.9 Finding Unique Values
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.9 寻找唯一值
- en: Problem
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to select all unique values in a column.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您想选择某一列中的所有唯一值。
- en: Solution
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use `unique` to view an array of all unique values in a column:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `unique` 查看列中所有唯一值的数组：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, `value_counts` will display all unique values with the number
    of times each value appears:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，`value_counts` 将显示所有唯一值及其出现次数：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Discussion
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Both `unique` and `value_counts` are useful for manipulating and exploring
    categorical columns. Very often in categorical columns there will be classes that
    need to be handled in the data wrangling phase. For example, in the *Titanic*
    dataset, `PClass` is a column indicating the class of a passenger’s ticket. There
    were three classes on the *Titanic*; however, if we use `value_counts` we can
    see a problem:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique` 和 `value_counts` 对于操作和探索分类列非常有用。 在分类列中，通常需要在数据整理阶段处理类别。 例如，在 *Titanic*
    数据集中，`PClass` 是指乘客票的类别。 在 *Titanic* 上有三个等级; 但是，如果我们使用 `value_counts`，我们会发现一个问题：'
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: While almost all passengers belong to one of three classes as expected, a single
    passenger has the class `*`. There are a number of strategies for handling this
    type of issue, which we will address in [Chapter 5](ch05.xhtml#handling-categorical-data),
    but for now just realize that “extra” classes are common in categorical data and
    should not be ignored.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管几乎所有乘客都属于预期的三个类别之一，但是有一个乘客的类别是 `*`。 在处理这类问题时有多种策略，我们将在[第五章](ch05.xhtml#handling-categorical-data)中进行讨论，但现在只需意识到，在分类数据中，“额外”类别是常见的，不应忽略。
- en: 'Finally, if we simply want to count the number of unique values, we can use
    `nunique`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们只想计算唯一值的数量，我们可以使用 `nunique`：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 3.10 Handling Missing Values
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.10 处理缺失值
- en: Problem
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to select missing values in a DataFrame.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要选择 DataFrame 中的缺失值。
- en: Solution
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '`isnull` and `notnull` return booleans indicating whether a value is missing:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`isnull` 和 `notnull` 返回布尔值，指示值是否缺失：'
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|  | 名称 | 舱位 | 年龄 | 性别 | 幸存 | 性别代码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 12 | Aubert, Mrs Leontine Pauline | 1st | NaN | female | 1 | 1 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 12 | Aubert, Mrs Leontine Pauline | 1st | NaN | female | 1 | 1 |'
- en: '| 13 | Barkworth, Mr Algernon H | 1st | NaN | male | 1 | 0 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 13 | Barkworth, Mr Algernon H | 1st | NaN | male | 1 | 0 |'
- en: Discussion
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Missing values are a ubiquitous problem in data wrangling, yet many underestimate
    the difficulty of working with missing data. pandas uses NumPy’s `NaN` (Not a
    Number) value to denote missing values, but it is important to note that `NaN`
    is not fully implemented natively in pandas. For example, if we wanted to replace
    all strings containing `male` with missing values, we get an error:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失值是数据整理中普遍存在的问题，然而许多人低估了处理缺失数据的难度。 pandas 使用 NumPy 的 `NaN`（非数值）值表示缺失值，但重要的是要注意，pandas
    中没有完全本地实现 `NaN`。 例如，如果我们想用包含 `male` 的所有字符串替换缺失值，我们会得到一个错误：
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To have full functionality with `NaN` we need to import the NumPy library first:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全使用 `NaN` 的功能，我们首先需要导入 NumPy 库：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Oftentimes a dataset uses a specific value to denote a missing observation,
    such as `NONE`, `-999`, or `..`. The pandas `read_csv` function includes a parameter
    allowing us to specify the values used to indicate missing values:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，数据集使用特定的值来表示缺失的观察值，例如 `NONE`、`-999` 或 `..`。pandas 的 `read_csv` 函数包括一个参数，允许我们指定用于指示缺失值的值：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can also use the pandas `fillna` function to impute the missing values of
    a column. Here, we show the places where `Age` is null using the `isna` function
    and then fill those values with the mean age of passengers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 pandas 的 `fillna` 函数来填充列的缺失值。在这里，我们使用 `isna` 函数显示 `Age` 为空的位置，然后用乘客的平均年龄填充这些值。
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | 舱位 | 年龄 | 性别 | 幸存 | 性别编码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 12 | Aubert, Mrs Leontine Pauline | 1st | NaN | female | 1 | 1 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 奥贝特，利昂汀·波琳娜夫人 | 1st | NaN | 女性 | 1 | 1 |'
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | 舱位 | 年龄 | 性别 | 幸存 | 性别编码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 12 | Aubert, Mrs Leontine Pauline | 1st | 30.397989 | female | 1 | 1 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 奥贝特，利昂汀·波琳娜夫人 | 1st | 30.397989 | 女性 | 1 | 1 |'
- en: 3.11 Deleting a Column
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.11 删除列
- en: Problem
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to delete a column from your DataFrame.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要从您的 DataFrame 中删除一列。
- en: Solution
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The best way to delete a column is to use `drop` with the parameter `axis=1`
    (i.e., the column axis):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 删除列的最佳方法是使用带有参数 `axis=1`（即列轴）的 `drop`：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|  | Name | PClass | Sex | Survived | SexCode |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | 舱位 | 性别 | 幸存 | 性别编码 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | Allen, Miss Elisabeth Walton | 1st | female | 1 | 1 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 艾伦，伊丽莎白·沃尔顿小姐 | 1st | 女性 | 1 | 1 |'
- en: '| 1 | Allison, Miss Helen Loraine | 1st | female | 0 | 1 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾莉森，露萍小姐 | 1st | 女性 | 0 | 1 |'
- en: 'You can also use a list of column names as the main argument to drop multiple
    columns at once:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用列名的列表作为删除多列的主要参数：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|  | Name | PClass | Survived | SexCode |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | 舱位 | 幸存 | 性别编码 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | Allen, Miss Elisabeth Walton | 1st | 1 | 1 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 艾伦，伊丽莎白·沃尔顿小姐 | 1st | 1 | 1 |'
- en: '| 1 | Allison, Miss Helen Loraine | 1st | 0 | 1 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾莉森，露萍小姐 | 1st | 0 | 1 |'
- en: 'If a column does not have a name (which can sometimes happen), you can drop
    it by its column index using `dataframe.columns`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列没有名称（有时可能会发生），您可以使用 `dataframe.columns` 按其列索引删除它：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|  | Name | Age | Sex | Survived | SexCode |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | 年龄 | 性别 | 幸存 | 性别编码 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | Allen, Miss Elisabeth Walton | 29.0 | female | 1 | 1 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 艾伦，伊丽莎白·沃尔顿小姐 | 29.0 | 女性 | 1 | 1 |'
- en: '| 1 | Allison, Miss Helen Loraine | 2.0 | female | 0 | 1 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾莉森，露萍小姐 | 2.0 | 女性 | 0 | 1 |'
- en: Discussion
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`drop` is the idiomatic method of deleting a column. An alternative method
    is `del dataframe[''Age'']`, which works most of the time but is not recommended
    because of how it is called within pandas (the details of which are outside the
    scope of this book).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`drop` 是删除列的成语方法。另一种方法是 `del dataframe[''Age'']`，大多数情况下可以工作，但不建议使用，因为它在 pandas
    中的调用方式（其细节超出本书的范围）。'
- en: 'I recommend that you avoid using the pandas `inplace=True` argument. Many pandas
    methods include an `inplace` parameter that, when set to `True`, edits the DataFrame
    directly. This can lead to problems in more complex data processing pipelines
    because we are treating the DataFrames as mutable objects (which they technically
    are). I recommend treating DataFrames as immutable objects. For example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您避免使用 pandas 的 `inplace=True` 参数。许多 pandas 方法包括一个 `inplace` 参数，当设置为 `True`
    时，直接编辑 DataFrame。这可能会导致在更复杂的数据处理管道中出现问题，因为我们将 DataFrame 视为可变对象（从技术上讲确实如此）。我建议将
    DataFrame 视为不可变对象。例如：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this example, we are not mutating the DataFrame `dataframe` but instead are
    making a new DataFrame that is an altered version of `dataframe` called `dataframe_name_dropped`.
    If you treat your DataFrames as immutable objects, you will save yourself a lot
    of headaches down the road.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们没有改变 DataFrame `dataframe`，而是创建了一个新的 DataFrame，称为 `dataframe_name_dropped`，它是
    `dataframe` 的修改版本。如果您将 DataFrame 视为不可变对象，那么您将会在将来避免很多麻烦。
- en: 3.12 Deleting a Row
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.12 删除行
- en: Problem
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to delete one or more rows from a DataFrame.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要从 DataFrame 中删除一行或多行。
- en: Solution
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use a boolean condition to create a new DataFrame excluding the rows you want
    to delete:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔条件创建一个新的 DataFrame，排除你想要删除的行：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | 舱位 | 年龄 | 性别 | 幸存 | 性别编码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29.0 | female | 1 | 1 |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29.0 | 女性 | 1 | 1 |'
- en: '| 1 | Allison, Miss Helen Loraine | 1st | 2.0 | female | 0 | 1 |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Allison, Miss Helen Loraine | 1st | 2.0 | 女性 | 0 | 1 |'
- en: '| 3 | Allison, Mrs Hudson JC (Bessie Waldo Daniels) | 1st | 25.00 | female
    | 0 | 1 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Allison, Mrs Hudson JC (Bessie Waldo Daniels) | 1st | 25.00 | 女性 | 0
    | 1 |'
- en: Discussion
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: While technically you can use the `drop` method (for example, `dataframe.drop([0,
    1], axis=0)` to drop the first two rows), a more practical method is simply to
    wrap a boolean condition inside `dataframe[]`. This enables us to use the power
    of conditionals to delete either a single row or (far more likely) many rows at
    once.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上你可以使用`drop`方法（例如，`dataframe.drop([0, 1], axis=0)`来删除前两行），但更实用的方法是简单地将布尔条件包装在`dataframe[]`中。这使我们能够利用条件语句的威力来删除单行或（更有可能）多行。
- en: 'We can use boolean conditions to easily delete single rows by matching a unique
    value:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用布尔条件轻松删除单行，通过匹配唯一值：
- en: '[PRE52]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | 票类 | 年龄 | 性别 | 生存 | 性别编码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29.0 | female | 1 | 1 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29.0 | 女性 | 1 | 1 |'
- en: '| 2 | Allison, Mr Hudson Joshua Creighton | 1st | 30.0 | male | 0 | 0 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Allison, Mr Hudson Joshua Creighton | 1st | 30.0 | 男性 | 0 | 0 |'
- en: 'We can even use it to delete a single row by specifying the row index:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过指定行索引来使用它删除单行：
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | 票类 | 年龄 | 性别 | 生存 | 性别编码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 1 | Allison, Miss Helen Loraine | 1st | 2.0 | female | 0 | 1 |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Allison, Miss Helen Loraine | 1st | 2.0 | 女性 | 0 | 1 |'
- en: '| 2 | Allison, Mr Hudson Joshua Creighton | 1st | 30.0 | male | 0 | 0 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Allison, Mr Hudson Joshua Creighton | 1st | 30.0 | 男性 | 0 | 0 |'
- en: 3.13 Dropping Duplicate Rows
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.13 删除重复行
- en: Problem
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to drop duplicate rows from your DataFrame.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您想从DataFrame中删除重复的行。
- en: Solution
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use `drop_duplicates`, but be mindful of the parameters:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`drop_duplicates`，但要注意参数：
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | 票类 | 年龄 | 性别 | 生存 | 性别编码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29.0 | female | 1 | 1 |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29.0 | 女性 | 1 | 1 |'
- en: '| 1 | Allison, Miss Helen Loraine | 1st | 2.0 | female | 0 | 1 |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Allison, Miss Helen Loraine | 1st | 2.0 | 女性 | 0 | 1 |'
- en: Discussion
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A keen reader will notice that the solution didn’t actually drop any rows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一个敏锐的读者会注意到，解决方案实际上并没有删除任何行：
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is because `drop_duplicates` defaults to dropping only rows that match
    perfectly across all columns. Because every row in our DataFrame is unique, none
    will be dropped. However, often we want to consider only a subset of columns to
    check for duplicate rows. We can accomplish this using the `subset` parameter:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`drop_duplicates`默认仅删除所有列完全匹配的行。因为我们DataFrame中的每一行都是唯一的，所以不会被删除。然而，通常我们只想考虑部分列来检查重复行。我们可以使用`subset`参数来实现这一点：
- en: '[PRE57]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | 票类 | 年龄 | 性别 | 生存 | 性别编码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29.0 | female | 1 | 1 |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 0 | Allen, Miss Elisabeth Walton | 1st | 29.0 | 女性 | 1 | 1 |'
- en: '| 2 | Allison, Mr Hudson Joshua Creighton | 1st | 30.0 | male | 0 | 0 |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Allison, Mr Hudson Joshua Creighton | 1st | 30.0 | 男性 | 0 | 0 |'
- en: 'Take a close look at the preceding output: we told `drop_duplicates` to only
    consider any two rows with the same value for `Sex` to be duplicates and to drop
    them. Now we are left with a DataFrame of only two rows: one woman and one man.
    You might be asking why `drop_duplicates` decided to keep these two rows instead
    of two different rows. The answer is that `drop_duplicates` defaults to keeping
    the first occurrence of a duplicated row and dropping the rest. We can control
    this behavior using the `keep` parameter:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察上述输出：我们告诉`drop_duplicates`仅考虑具有相同`Sex`值的任意两行为重复行，并将其删除。现在我们只剩下两行的DataFrame：一个女性和一个男性。你可能会问为什么`drop_duplicates`决定保留这两行而不是两行不同的行。答案是`drop_duplicates`默认保留重复行的第一次出现并丢弃其余的。我们可以使用`keep`参数来控制这种行为：
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '|  | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '|  | 姓名 | 票类 | 年龄 | 性别 | 生存 | 性别编码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 1307 | Zabour, Miss Tamini | 3rd | NaN | female | 0 | 1 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 1307 | Zabour, Miss Tamini | 3rd | NaN | 女性 | 0 | 1 |'
- en: '| 1312 | Zimmerman, Leo | 3rd | 29.0 | male | 0 | 0 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 1312 | Zimmerman, Leo | 3rd | 29.0 | 男性 | 0 | 0 |'
- en: 'A related method is `duplicated`, which returns a boolean series denoting whether
    a row is a duplicate or not. This is a good option if you don’t want to simply
    drop duplicates:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 3.14 Grouping Rows by Values
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to group individual rows according to some shared value.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`groupby` is one of the most powerful features in pandas:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '| Sex | Age | Survived | SexCode |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '| female | 29.396424 | 0.666667 | 1.0 |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| male | 31.014338 | 0.166863 | 0.0 |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: Discussion
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`groupby` is where data wrangling really starts to take shape. It is very common
    to have a DataFrame where each row is a person or an event and we want to group
    them according to some criterion and then calculate a statistic. For example,
    you can imagine a DataFrame where each row is an individual sale at a national
    restaurant chain and we want the total sales per restaurant. We can accomplish
    this by grouping rows by individual restaurants and then calculating the sum of
    each group.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Users new to `groupby` often write a line like this and are confused by what
    is returned:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Why didn’t it return something more useful? The reason is that `groupby` needs
    to be paired with some operation that we want to apply to each group, such as
    calculating an aggregate statistic (e.g., mean, median, sum). When talking about
    grouping we often use shorthand and say “group by gender,” but that is incomplete.
    For grouping to be useful, we need to group by something and then apply a function
    to each of those groups:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice `Name` added after the `groupby`? That is because particular summary
    statistics are meaningful only to certain types of data. For example, while calculating
    the average age by gender makes sense, calculating the total age by gender does
    not. In this case, we group the data into survived or not, and then count the
    number of names (i.e., passengers) in each group.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also group by a first column, then group that grouping by a second column:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 3.15 Grouping Rows by Time
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to group individual rows by time periods.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `resample` to group rows by chunks of time:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '|  | Sale_Amount |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| 2017-06-11 | 86423 |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| 2017-06-18 | 101045 |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| 2017-06-25 | 100867 |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| 2017-07-02 | 100894 |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| 2017-07-09 | 100438 |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '| 2017-07-16 | 10297 |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: Discussion
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our standard *Titanic* dataset does not contain a datetime column, so for this
    recipe we have generated a simple DataFrame where each row is an individual sale.
    For each sale we know its date and time and its dollar amount (this data isn’t
    realistic because the sales take place precisely 30 seconds apart and are exact
    dollar amounts, but for the sake of simplicity let’s pretend).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'The raw data looks like this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '|  | Sale_Amount |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '| 2017-06-06 00:00:00 | 7 |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '| 2017-06-06 00:00:30 | 2 |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| 2017-06-06 00:01:00 | 7 |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: Notice that the date and time of each sale is the index of the DataFrame; this
    is because `resample` requires the index to be a datetime-like value.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `resample` we can group the rows by a wide array of time periods (offsets)
    and then we can calculate statistics on each time group:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`resample`，我们可以按照各种时间段（偏移）对行进行分组，然后可以在每个时间组上计算统计信息：
- en: '[PRE70]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '|  | Sale_Amount |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '|  | Sale_Amount |'
- en: '| --- | --- |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2017-06-11 | 5.001331 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 2017-06-11 | 5.001331 |'
- en: '| 2017-06-25 | 5.007738 |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| 2017-06-25 | 5.007738 |'
- en: '| 2017-07-09 | 4.993353 |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 2017-07-09 | 4.993353 |'
- en: '| 2017-07-23 | 4.950481 |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| 2017-07-23 | 4.950481 |'
- en: '[PRE71]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '|  | Sale_Amount |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|  | Sale_Amount |'
- en: '| --- | --- |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 2017-06-30 | 72000 |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 2017-06-30 | 72000 |'
- en: '| 2017-07-31 | 28000 |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| 2017-07-31 | 28000 |'
- en: 'You might notice that in the two outputs the datetime index is a date even
    though we are grouping by weeks and months, respectively. The reason is that by
    default `resample` returns the label of the right “edge” (the last label) of the
    time group. We can control this behavior using the `label` parameter:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到，在这两个输出中，日期时间索引是日期，即使我们按周和月进行分组。原因是默认情况下，`resample`返回时间组的右“边缘”标签（最后一个标签）。我们可以使用`label`参数控制此行为：
- en: '[PRE72]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '|  | Sale_Amount |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '|  | Sale_Amount |'
- en: '| --- | --- |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2017-05-31 | 72000 |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 2017-05-31 | 72000 |'
- en: '| 2017-06-30 | 28000 |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 2017-06-30 | 28000 |'
- en: See Also
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[List of pandas time offset aliases](https://oreil.ly/BURbR)'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pandas 时间偏移别名列表](https://oreil.ly/BURbR)'
- en: 3.16 Aggregating Operations and Statistics
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.16 聚合操作和统计
- en: Problem
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to aggregate an operation over each column (or a set of columns) in
    a dataframe.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要对数据框中的每列（或一组列）进行聚合操作。
- en: Solution
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the pandas `agg` method. Here, we can easily get the minimum value of every
    column:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pandas的`agg`方法。在这里，我们可以轻松地获得每列的最小值：
- en: '[PRE73]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Sometimes, we want to apply specific functions to specific sets of columns:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望将特定函数应用于特定列集：
- en: '[PRE75]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '|  | Age | SexCode |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '|  | Age | SexCode |'
- en: '| --- | --- | --- |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| mean | 30.397989 | NaN |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| mean | 30.397989 | NaN |'
- en: '| min | NaN | 0.0 |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| min | NaN | 0.0 |'
- en: '| max | NaN | 1.0 |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| max | NaN | 1.0 |'
- en: 'We can also apply aggregate functions to groups to get more specific, descriptive
    statistics:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将聚合函数应用于组，以获取更具体的描述性统计信息：
- en: '[PRE76]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '| PClass | Survived | Count |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| PClass | Survived | Count |'
- en: '| --- | --- | --- |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | * | 0 | 1 |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 0 | * | 0 | 1 |'
- en: '| 1 | 1st | 0 | 129 |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1st | 0 | 129 |'
- en: '| 2 | 1st | 1 | 193 |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1st | 1 | 193 |'
- en: '| 3 | 2nd | 0 | 160 |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2nd | 0 | 160 |'
- en: '| 4 | 2nd | 1 | 119 |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2nd | 1 | 119 |'
- en: '| 5 | 3rd | 0 | 573 |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 3rd | 0 | 573 |'
- en: '| 6 | 3rd | 1 | 138 |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 3rd | 1 | 138 |'
- en: Discussion
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Aggregate functions are especially useful during exploratory data analysis to
    learn information about different subpopulations of data and the relationship
    between variables. By grouping the data and applying aggregate statistics, you
    can view patterns in the data that may prove useful during the machine learning
    or feature engineering process. While visual charts are also helpful, it’s often
    useful to have such specific, descriptive statistics as a reference to better
    understand the data.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索性数据分析中，聚合函数特别有用，可用于了解数据的不同子群体和变量之间的关系。通过对数据进行分组并应用聚合统计，您可以查看数据中的模式，这些模式在机器学习或特征工程过程中可能会很有用。虽然视觉图表也很有帮助，但有这样具体的描述性统计数据作为参考，有助于更好地理解数据。
- en: See Also
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[pandas agg documentation](https://oreil.ly/5xing)'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pandas agg 文档](https://oreil.ly/5xing)'
- en: 3.17 Looping over a Column
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.17 遍历列
- en: Problem
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to iterate over every element in a column and apply some action.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望遍历列中的每个元素并应用某些操作。
- en: Solution
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'You can treat a pandas column like any other sequence in Python and loop over
    it using the standard Python syntax:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像对待Python中的任何其他序列一样处理pandas列，并使用标准Python语法对其进行循环：
- en: '[PRE77]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Discussion
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'In addition to loops (often called `for` loops), we can also use list comprehensions:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 除了循环（通常称为`for`循环）之外，我们还可以使用列表推导：
- en: '[PRE79]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Despite the temptation to fall back on `for` loops, a more Pythonic solution
    would use the pandas `apply` method, described in [Recipe 3.18](#applying-a-function-over-all-elements-in-a-column).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有诱惑使用`for`循环，更符合Python风格的解决方案应该使用pandas的`apply`方法，详见[配方 3.18](#applying-a-function-over-all-elements-in-a-column)。
- en: 3.18 Applying a Function over All Elements in a Column
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.18 在列中的所有元素上应用函数
- en: Problem
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to apply some function over all elements in a column.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在一列的所有元素上应用某些函数。
- en: Solution
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use `apply` to apply a built-in or custom function on every element in a column:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`apply`在列的每个元素上应用内置或自定义函数：
- en: '[PRE81]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Discussion
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`apply` is a great way to do data cleaning and wrangling. It is common to write
    a function to perform some useful operation (separate first and last names, convert
    strings to floats, etc.) and then map that function to every element in a column.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`是进行数据清理和整理的好方法。通常会编写一个函数来执行一些有用的操作（将名字分开，将字符串转换为浮点数等），然后将该函数映射到列中的每个元素。'
- en: 3.19 Applying a Function to Groups
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.19 对组应用函数
- en: Problem
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have grouped rows using `groupby` and want to apply a function to each group.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用`groupby`对行进行分组，并希望对每个组应用函数。
- en: Solution
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Combine `groupby` and `apply`:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 结合`groupby`和`apply`：
- en: '[PRE83]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '| Sex | Name | PClass | Age | Sex | Survived | SexCode |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| 性别 | 姓名 | 舱位 | 年龄 | 性别 | 幸存 | 性别编码 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| female | 462 | 462 | 288 | 462 | 462 | 462 |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| 女性 | 462 | 462 | 288 | 462 | 462 | 462 |'
- en: '| male | 851 | 851 | 468 | 851 | 851 | 851 |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| 男性 | 851 | 851 | 468 | 851 | 851 | 851 |'
- en: Discussion
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In [Recipe 3.18](#applying-a-function-over-all-elements-in-a-column) I mentioned
    `apply`. `apply` is particularly useful when you want to apply a function to groups.
    By combining `groupby` and `apply` we can calculate custom statistics or apply
    any function to each group separately.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Recipe 3.18](#applying-a-function-over-all-elements-in-a-column)中提到了`apply`。当你想对分组应用函数时，`apply`特别有用。通过结合`groupby`和`apply`，我们可以计算自定义统计信息或将任何函数分别应用于每个组。
- en: 3.20 Concatenating DataFrames
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.20 合并数据框
- en: Problem
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to concatenate two DataFrames.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要将两个数据框连接在一起。
- en: Solution
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use `concat` with `axis=0` to concatenate along the row axis:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`concat`和`axis=0`沿行轴进行连接：
- en: '[PRE84]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '|  | id | first | last |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '|  | id | first | last |'
- en: '| --- | --- | --- | --- |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 1 | Alex | Anderson |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | Alex | Anderson |'
- en: '| 1 | 2 | Amy | Ackerman |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | Amy | Ackerman |'
- en: '| 2 | 3 | Allen | Ali |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 | Allen | Ali |'
- en: '| 0 | 4 | Billy | Bonder |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 4 | Billy | Bonder |'
- en: '| 1 | 5 | Brian | Black |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 5 | Brian | Black |'
- en: '| 2 | 6 | Bran | Balwner |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 6 | Bran | Balwner |'
- en: 'You can use `axis=1` to concatenate along the column axis:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`axis=1`沿列轴进行连接：
- en: '[PRE85]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '|  | id | first | last | id | first | last |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '|  | id | first | last | id | first | last |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | 1 | Alex | Anderson | 4 | Billy | Bonder |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | Alex | Anderson | 4 | Billy | Bonder |'
- en: '| 1 | 2 | Amy | Ackerman | 5 | Brian | Black |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | Amy | Ackerman | 5 | Brian | Black |'
- en: '| 2 | 3 | Allen | Ali | 6 | Bran | Balwner |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 | Allen | Ali | 6 | Bran | Balwner |'
- en: Discussion
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Concatenating is not a word you hear much outside of computer science and programming,
    so if you have not heard it before, do not worry. The informal definition of *concatenate*
    is to glue two objects together. In the solution we glued together two small DataFrames
    using the `axis` parameter to indicate whether we wanted to stack the two DataFrames
    on top of each other or place them side by side.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 合并通常是一个你在计算机科学和编程领域听得较多的词汇，所以如果你以前没听说过，别担心。*concatenate*的非正式定义是将两个对象粘合在一起。在解决方案中，我们使用`axis`参数将两个小数据框粘合在一起，以指示我们是否想要将两个数据框叠加在一起还是并排放置它们。
- en: 3.21 Merging DataFrames
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.21 合并数据框
- en: Problem
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to merge two DataFrames.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要合并两个数据框。
- en: Solution
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'To inner join, use `merge` with the `on` parameter to specify the column to
    merge on:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行内连接，使用`merge`并使用`on`参数指定要合并的列：
- en: '[PRE86]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '|  | employee_id | name | total_sales |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '|  | 员工编号 | 姓名 | 总销售额 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 3 | Alice Bees | 23456 |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 3 | Alice Bees | 23456 |'
- en: '| 1 | 4 | Tim Horton | 2512 |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 4 | Tim Horton | 2512 |'
- en: '`merge` defaults to inner joins. If we want to do an outer join, we can specify
    that with the `how` parameter:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge`默认为内连接。如果我们想进行外连接，可以使用`how`参数来指定：'
- en: '[PRE87]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '|  | employee_id | name | total_sales |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '|  | 员工编号 | 姓名 | 总销售额 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 1 | Amy Jones | NaN |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | Amy Jones | NaN |'
- en: '| 1 | 2 | Allen Keys | NaN |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | Allen Keys | NaN |'
- en: '| 2 | 3 | Alice Bees | 23456.0 |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 | Alice Bees | 23456.0 |'
- en: '| 3 | 4 | Tim Horton | 2512.0 |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 4 | Tim Horton | 2512.0 |'
- en: '| 4 | 5 | NaN | 2345.0 |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 5 | NaN | 2345.0 |'
- en: '| 5 | 6 | NaN | 1455.0 |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 6 | NaN | 1455.0 |'
- en: 'The same parameter can be used to specify left and right joins:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个参数可以用来指定左连接和右连接：
- en: '[PRE88]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '|  | employee_id | name | total_sales |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '|  | 员工编号 | 姓名 | 总销售额 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 1 | Amy Jones | NaN |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | Amy Jones | NaN |'
- en: '| 1 | 2 | Allen Keys | NaN |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | Allen Keys | NaN |'
- en: '| 2 | 3 | Alice Bees | 23456.0 |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 | Alice Bees | 23456.0 |'
- en: '| 3 | 4 | Tim Horton | 2512.0 |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 4 | Tim Horton | 2512.0 |'
- en: 'We can also specify the column name in each DataFrame to merge on:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在每个数据框中指定要合并的列名：
- en: '[PRE89]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '|  | employee_id | name | total_sales |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '|  | 员工编号 | 姓名 | 总销售额 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 3 | Alice Bees | 23456 |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
- en: '| 1 | 4 | Tim Horton | 2512 |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
- en: If, instead of merging on two columns, we want to merge on the indexes of each
    DataFrame, we can replace the `left_on` and `right_on` parameters with `left_index=True`
    and `right_index=True`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data we need to use is often complex; it doesn’t always come in one piece.
    Instead, in the real world, we’re usually faced with disparate datasets from multiple
    database queries or files. To get all that data into one place, we can load each
    data query or data file into pandas as individual DataFrames and then merge them
    into a single DataFrame.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: This process might be familiar to anyone who has used SQL, a popular language
    for doing merging operations (called *joins*). While the exact parameters used
    by pandas will be different, they follow the same general patterns used by other
    software languages and tools.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: There are three aspects to specify with any `merge` operation. First, we have
    to specify the two DataFrames we want to merge. In the solution, we named them
    `dataframe_employees` and `dataframe_sales`. Second, we have to specify the name(s)
    of the columns to merge on—​that is, the columns whose values are shared between
    the two DataFrames. For example, in our solution both DataFrames have a column
    named `employee_id`. To merge the two DataFrames we will match the values in each
    DataFrame’s `employee_id` column. If these two columns use the same name, we can
    use the `on` parameter. However, if they have different names, we can use `left_on`
    and `right_on`.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: What is the left and right DataFrame? The left DataFrame is the first one we
    specified in `merge`, and the right DataFrame is the second one. This language
    comes up again in the next sets of parameters we will need.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: 'The last aspect, and most difficult for some people to grasp, is the type of
    merge operation we want to conduct. This is specified by the `how` parameter.
    `merge` supports the four main types of joins:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: Inner
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Return only the rows that match in both DataFrames (e.g., return any row with
    an `employee_id` value appearing in both `dataframe_employees` and `dataframe_sales`).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Outer
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Return all rows in both DataFrames. If a row exists in one DataFrame but not
    in the other DataFrame, fill NaN values for the missing values (e.g., return all
    rows in both `dataframe_employee` and `dataframe_sales`).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Left
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: Return all rows from the left DataFrame but only rows from the right DataFrame
    that match with the left DataFrame. Fill `NaN` values for the missing values (e.g.,
    return all rows from `dataframe_employees` but only rows from `dataframe_sales`
    that have a value for `employee_id` that appears in `dataframe_employees`).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Right
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Return all rows from the right DataFrame but only rows from the left DataFrame
    that match with the right DataFrame. Fill `NaN` values for the missing values
    (e.g., return all rows from `dataframe_sales` but only rows from `dataframe_employees`
    that have a value for `employee_id` that appears in `dataframe_sales`).
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 返回右侧数据框的所有行，但仅返回左侧数据框中与右侧数据框匹配的行。对于缺失的值填充`NaN`（例如，返回`dataframe_sales`的所有行，但仅返回`dataframe_employees`中具有出现在`dataframe_sales`中的`employee_id`值的行）。
- en: If you did not understand all of that, I encourage you to play around with the
    `how` parameter in your code and see how it affects what `merge` returns.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有完全理解，我鼓励你在你的代码中尝试调整`how`参数，看看它如何影响`merge`返回的结果。
- en: See Also
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[A Visual Explanation of SQL Joins](https://oreil.ly/J1A4u)'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQL 连接操作的可视化解释](https://oreil.ly/J1A4u)'
- en: '[pandas documentation: Merge, join, concatenate and compare](https://oreil.ly/eNalU)'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pandas 文档：合并、连接、串联和比较](https://oreil.ly/eNalU)'
