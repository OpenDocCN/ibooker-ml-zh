<html><head></head><body><section data-pdf-bookmark="Chapter 1. Introduction" data-type="chapter" epub:type="chapter"><div class="chapter" id="CH0">&#13;
<h1><span class="label">Chapter 1. </span>Introduction</h1>&#13;
&#13;
&#13;
<p>Recommendation systems<a data-primary="recommendation systems" data-secondary="technologies enabled by" data-type="indexterm" id="id336"/> are integral to the development of the internet that we know today and are a central function of emerging technology companies. Beyond the search ranking that opened the web’s breadth to everyone, the new and exciting movies all your friends are watching, or the most relevant ads that companies pay top dollar to show you lie more applications of recommendation systems every year. The addictive For You page from TikTok, the Discover Weekly playlist by Spotify, board suggestions on Pinterest, and Apple’s App Store are all hot technologies enabled by the recommendation systems. These days, sequential transformer models, multimodal representations, and graph neural nets are among the brightest areas of R&amp;D in machine learning (ML)—all being put to use in recommendation systems.</p>&#13;
&#13;
<p>Ubiquity of any technology often prompts questions of how the technology works, why it has become so common, and if we can get in on the action. For recommendation systems, the <em>how</em> is quite complicated. We’ll need to understand the geometry of taste, and how only a little bit of interaction from a user can provide us a <em>GPS signal</em> in that abstract space. You’ll see how to quickly gather a great set of candidates and how to refine them to a cohesive set of recommendations. Finally, you’ll learn how to evaluate your recommender, build the endpoint that serves inference, and log about its behavior.</p>&#13;
&#13;
<p>We will formulate variants of the core problem to be solved by recommendation systems but, ultimately, the<a data-primary="motivating problem framing" data-type="indexterm" id="id337"/> motivating problem framing is as follows:</p>&#13;
<blockquote>&#13;
<p>Given a collection of things that may be recommended, choose an ordered few for the current context and user that best match according to a certain objective.</p></blockquote>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Key Components of a Recommendation System" data-type="sect1"><div class="sect1" id="id4">&#13;
<h1>Key Components of a Recommendation System</h1>&#13;
&#13;
<p id="components">As<a data-primary="recommendation systems" data-secondary="key components of" data-type="indexterm" id="id338"/> we increase complexity and sophistication, let’s keep in mind the components of our system. We will use<a data-primary="string diagrams" data-type="indexterm" id="id339"/> <em>string diagrams</em> to keep track of our components, but in the literature these diagrams are presented in a variety of ways.</p>&#13;
&#13;
<p>We will identify and build on three core components of recommendation systems: the collector, ranker, and server.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Collector" data-type="sect2"><div class="sect2" id="id194">&#13;
<h2>Collector</h2>&#13;
&#13;
<p>The<a data-primary="collector" data-secondary="role in recommendation systems" data-type="indexterm" id="id340"/> collector’s role is to know what is in the collection of things that may be recommended, and the necessary features or attributes of those things. Note that this collection is often a subset based on context or state.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Ranker" data-type="sect2"><div class="sect2" id="id195">&#13;
<h2>Ranker</h2>&#13;
&#13;
<p>The<a data-primary="ranker" data-secondary="role in recommendation systems" data-type="indexterm" id="id341"/> ranker’s role is to take the collection provided by the collector and order some or all of its elements, according to a model for the context and user.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Server" data-type="sect2"><div class="sect2" id="id196">&#13;
<h2>Server</h2>&#13;
&#13;
<p>The<a data-primary="server" data-secondary="role in recommendation systems" data-type="indexterm" id="id342"/> server’s role is to take the ordered subset provided by the ranker, ensure that the necessary data schema is satisfied—including essential business logic—and return the requested number of recommendations.</p>&#13;
&#13;
<p>Take, for example, a hospitality scenario with a waiter:</p>&#13;
<blockquote>&#13;
<p>When you sit down at your table, you look at the menu, unsure of what you should order. You ask the waiter, “What do you think I should order for dessert?”</p>&#13;
&#13;
<p>The waiter checks their notes and says, “We’re out of the key lime pie, but people really like our banana cream pie. If you like pomegranate, we make pom ice cream from scratch; and it’s hard to go wrong with the donut a la mode—it’s our most popular dessert.”</p></blockquote>&#13;
&#13;
<p>In this short exchange, the waiter first serves as a collector: identifying the desserts on the menu, accommodating current inventory conditions, and preparing to talk about the characteristics of the desserts by checking their notes.</p>&#13;
&#13;
<p>Next, the waiter serves as a ranker; they mention items high scoring in popularity (banana cream pie and donut a la mode) as well as a contextually high match item based on the patron’s features (if they like pomegranate).</p>&#13;
&#13;
<p>Finally, the waiter serves the recommendations verbally, including both explanatory features of their algorithm and multiple choices.</p>&#13;
&#13;
<p>While this seems a bit cartoonish, remember to ground discussions of recommendation systems in real-world applications. One of the advantages of working in RecSys is that inspiration is always nearby.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Simplest Possible Recommenders" data-type="sect1"><div class="sect1" id="id299">&#13;
<h1>Simplest Possible Recommenders</h1>&#13;
&#13;
<p>We’ve established the components of a recommender, but to really make this practical, we need to see this in action. While much of the book is dedicated to practical recommendation systems, first we’ll start with a toy and scaffold from there.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Trivial Recommender" data-type="sect2"><div class="sect2" id="id5">&#13;
<h2>The Trivial Recommender</h2>&#13;
&#13;
<p>The<a data-primary="trivial recommender (TR)" data-type="indexterm" id="id343"/><a data-primary="TR (trivial recommender)" data-type="indexterm" id="id344"/><a data-primary="recommendation systems" data-secondary="trivial recommender (TR)" data-type="indexterm" id="id345"/> absolute simplest recommender is not very interesting but can still be demonstrated in the framework. It’s called <em>the trivial recommender</em> (<em>TR</em>) because it contains virtually no logic:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="k">def</code> <code class="nf">get_trivial_recs</code><code class="p">()</code> <code class="o">-&gt;</code> <code class="n">Optional</code><code class="p">[</code><code class="n">List</code><code class="p">[</code><code class="nb">str</code><code class="p">]]:</code>&#13;
   <code class="n">item_id</code> <code class="o">=</code> <code class="n">random</code><code class="o">.</code><code class="n">randint</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="n">MAX_ITEM_INDEX</code><code class="p">)</code>&#13;
&#13;
   <code class="k">if</code> <code class="n">get_availability</code><code class="p">(</code><code class="n">item_id</code><code class="p">):</code>&#13;
       <code class="k">return</code> <code class="p">[</code><code class="n">item_id</code><code class="p">]</code>&#13;
   <code class="k">return</code> <code class="kc">None</code></pre>&#13;
&#13;
<p>Notice that this recommender may return either a specific <code>item_id</code> or <code>None</code>. Also observe that this recommender takes no arguments, and <code>MAX_ITEM_INDEX</code> is referencing a variable out of scope. Software principles ignored, let’s think about the three components:</p>&#13;
<dl>&#13;
<dt>Collector</dt>&#13;
<dd>&#13;
<p>A random <code>item_id</code> is generated. The TR collects by checking the availability of <code>item_id</code>. We could argue that having access to <code>item_id</code> is also part of the collector’s responsibility. Conditional upon the availability, the collection of recommendable things is either <code>[item_id]</code> or <code>None</code> (<em>recall that <code>None</code> is a collection in the set-theoretic sense</em>).</p>&#13;
</dd>&#13;
<dt>Ranker</dt>&#13;
<dd>&#13;
<p>The TR ranks with a no-op; i.e., the ranking of 1 or 0 objects in a collection is the identity function on that collection, so we merely do nothing and move on to the next step.</p>&#13;
</dd>&#13;
<dt>Server</dt>&#13;
<dd>&#13;
<p>The TR serves recommendations by its <code>return</code> statements. The only schema that’s been specified in this example is that the return <span>type is ⁠<code>Optional​[List[str]]</code></span>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>This recommender, which is not interesting or useful, provides a skeleton that we will add to as we develop further.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Most-Popular-Item Recommender" data-type="sect2"><div class="sect2" id="id6">&#13;
<h2>Most-Popular-Item Recommender</h2>&#13;
&#13;
<p>The<a data-primary="recommendation systems" data-secondary="most-popular-item recommender (MPIR)" data-type="indexterm" id="id346"/><a data-primary="most-popular-item recommender (MPIR)" data-type="indexterm" id="id347"/> <em>most-popular-item recommender</em> (MPIR) is the simplest recommender that contains any utility. You probably won’t want to build applications around it, but it’s useful in tandem with other components in addition to providing a basis for further development.</p>&#13;
&#13;
<p>An MPIR works just as it says; it returns the most popular items:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="k">def</code> <code class="nf">get_item_popularities</code><code class="p">()</code> <code class="o">-&gt;</code> <code class="n">Optional</code><code class="p">[</code><code class="n">Dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="nb">int</code><code class="p">]]:</code>&#13;
    <code class="o">...</code>&#13;
        <code class="c1"># Dict of pairs: (item-identifier, count times item chosen)</code>&#13;
        <code class="k">return</code> <code class="n">item_choice_counts</code>&#13;
    <code class="k">return</code> <code class="kc">None</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">get_most_popular_recs</code><code class="p">(</code><code class="n">max_num_recs</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Optional</code><code class="p">[</code><code class="n">List</code><code class="p">[</code><code class="nb">str</code><code class="p">]]:</code>&#13;
    <code class="n">items_popularity_dict</code> <code class="o">=</code> <code class="n">get_item_popularities</code><code class="p">()</code>&#13;
    <code class="k">if</code> <code class="n">items_popularity_dict</code><code class="p">:</code>&#13;
        <code class="n">sorted_items</code> <code class="o">=</code> <code class="nb">sorted</code><code class="p">(</code>&#13;
            <code class="n">items_popularity_dict</code><code class="o">.</code><code class="n">items</code><code class="p">(),</code>&#13;
            <code class="n">key</code><code class="o">=</code><code class="k">lambda</code> <code class="n">item</code><code class="p">:</code> <code class="n">item</code><code class="p">[</code><code class="mi">1</code><code class="p">]),</code>&#13;
            <code class="n">reverse</code><code class="o">=</code><code class="kc">True</code><code class="p">,</code>&#13;
        <code class="p">)</code>&#13;
        <code class="k">return</code> <code class="p">[</code><code class="n">i</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="n">sorted_items</code><code class="p">][:</code><code class="n">max_num_recs</code><code class="p">]</code>&#13;
    <code class="k">return</code> <code class="kc">None</code></pre>&#13;
&#13;
<p>Here we assume that <code>get_item_popularities</code> has knowledge of all available items and the number of times they’ve been chosen.</p>&#13;
&#13;
<p>This recommender attempts to return the <em>k</em> most popular items available. While simple, this is a useful recommender that serves as a great place to start when building a recommendation system. Additionally, we will see this example return over and over, because other recommenders use this core and iteratively improve the internal components.</p>&#13;
&#13;
<p>Let’s look at the three components of our system again:</p>&#13;
<dl>&#13;
<dt>Collector</dt>&#13;
<dd>&#13;
<p>The MPIR first makes a call to <code>get_item_popularities</code> that—via database or memory access—knows which items are available and how many times they’ve been selected. For convenience, we assume that the items are returned as a dictionary, with keys given by the string that identifies the item, and values indicating the number of times that item has been chosen. We implicitly assume here that items not appearing in this list are not available.</p>&#13;
</dd>&#13;
<dt>Ranker</dt>&#13;
<dd>&#13;
<p>Here we see our first simple ranker: ranking by sorting on values. Because the collector has organized our data such that the values of the dictionary are the counts, we use the Python built-in sorting function <code>sorted</code>. Note that we use <code>key</code> to indicate that we wish to sort by the second element of the tuples—in this case, equivalent to sorting by values—and we send the <code>reverse</code> flag to make our sort descending.</p>&#13;
</dd>&#13;
<dt>Server</dt>&#13;
<dd>&#13;
<p>Finally, we need to satisfy our API schema, which is again provided via the return type hint: <code>Optional[List[str]]</code>. This wants the return type to be the nullable list of item-identifier strings that we’re recommending, so we use a list comprehension to grab the first element of the tuples. But wait! Our function has this <code>max_num_recs</code> field—what might that be doing there? Of course, this is suggesting that our API schema is looking for no greater than <code>max_num_recs</code> in the response. We handle this via the slice operator, but note that our return is between 0 and <code>max_num_recs</code> results.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Consider the possibilities at your fingertips equipped with the MPIR; recommending customers’ favorite item in each top-level category could make for a simple but useful first stab at recommendations for ecommerce. The most popular video of the day may make for a good home-page experience on your video site.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Gentle Introduction to JAX" data-type="sect1"><div class="sect1" id="id7">&#13;
<h1>A Gentle Introduction to JAX</h1>&#13;
&#13;
<p>Since this book has <em>JAX</em> in the title, we will provide a gentle introduction to JAX here. Its<a data-primary="JAX framework" data-secondary="documentation" data-type="indexterm" id="id348"/> official documentation can be found <a href="https://jax.readthedocs.io/en/latest/">on the JAX website</a>.</p>&#13;
&#13;
<p>JAX<a data-primary="JAX framework" data-secondary="brief description of" data-type="indexterm" id="id349"/> is a framework for writing mathematical code in Python that is just-in-time (JIT) compiled. JIT compilation allows the same code to run on CPUs, GPUs, and TPUs. This makes it easy to write performant code that takes advantage of the parallel-processing power of vector processors.</p>&#13;
&#13;
<p>Additionally, one of the <a data-primary="JAX framework" data-secondary="design philosophy of" data-type="indexterm" id="id350"/>design philosophies of JAX is to support tensors and gradients as core concepts, making it an ideal tool for ML systems that utilize gradient-based learning on tensor-shaped data. The<a data-primary="Google Colab" data-type="indexterm" id="id351"/> easiest way to play with JAX is probably via <a href="https://colab.research.google.com/">Google Colab</a>, which is a hosted Python notebook on the web.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Basic Types, Initialization, and Immutability" data-type="sect2"><div class="sect2" id="id8">&#13;
<h2>Basic Types, Initialization, and Immutability</h2>&#13;
&#13;
<p>Let’s start by learning about<a data-primary="JAX framework" data-secondary="JAX types" data-type="indexterm" id="id352"/> JAX types. We’ll construct a small, three-dimensional vector in JAX and point out some differences between JAX and<a data-primary="NumPy" data-type="indexterm" id="id353"/> NumPy:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code> <code class="nn">jax.numpy</code> <code class="k">as</code> <code class="nn">jnp</code>&#13;
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>&#13;
&#13;
<code class="n">x</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mf">1.0</code><code class="p">,</code> <code class="mf">2.0</code><code class="p">,</code> <code class="mf">3.0</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="n">jnp</code><code class="o">.</code><code class="n">float32</code><code class="p">)</code>&#13;
&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>&#13;
<code class="p">[</code><code class="mf">1.</code> <code class="mf">2.</code> <code class="mf">3.</code><code class="p">]</code>&#13;
&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="o">.</code><code class="n">shape</code><code class="p">)</code>&#13;
<code class="p">(</code><code class="mi">3</code><code class="p">,)</code>&#13;
&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code>&#13;
<code class="mf">1.0</code>&#13;
&#13;
<code class="n">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="mf">4.0</code>&#13;
<code class="ne">TypeError</code><code class="p">:</code> <code class="s1">'&lt;class '</code><code class="n">jaxlib</code><code class="o">.</code><code class="n">xla_extension</code><code class="o">.</code><code class="n">ArrayImpl</code><code class="s1">'&gt;'</code>&#13;
<code class="nb">object</code> <code class="n">does</code> <code class="ow">not</code> <code class="n">support</code> <code class="n">item</code> <code class="n">assignment</code><code class="o">.</code> <code class="n">JAX</code> <code class="n">arrays</code> <code class="n">are</code> <code class="n">immutable</code><code class="o">.</code></pre>&#13;
&#13;
<p>JAX’s interface is mostly similar to that of NumPy. We import JAX’s version of NumPy as <code>jnp</code> to distinguish it from NumPy (<code>np</code>) by convention so that we know which version of a mathematical function we want to use. This is because sometimes we might want to run code on a vector processor like a GPU or TPU that we can use JAX for, or we might prefer to run some code on a CPU in NumPy.</p>&#13;
&#13;
<p>The first point to notice is that JAX arrays have types. The typical float type is <code>float32</code>, which uses 32 bits to represent a floating-point number. Other types exist, such as <code>float64</code>, which has greater precision, and <code>float16</code>, which is a half-precision type that usually only runs on some GPUs.</p>&#13;
&#13;
<p>The other point to note is that JAX tensors have shape. This is usually a tuple, so <code>(3,)</code> means a three-dimensional vector along the first axis. A matrix has two axes, and a tensor has three or more axes.</p>&#13;
&#13;
<p>Now we come to places where JAX differs from NumPy. It is really important to pay attention to <a href="https://oreil.ly/qqcFM">“JAX—The Sharp Bits”</a> to understand these differences. JAX’s philosophy is about speed and purity. By making functions pure (without side effects) and by making<a data-primary="JAX framework" data-secondary="data immutability in" data-type="indexterm" id="id354"/> data immutable, JAX is able to make some guarantees to the underlying accelerated linear algebra (XLA) library that it uses to talk to GPUs. JAX guarantees that these functions applied to data can be run in parallel and have deterministic results without side effects, and thus XLA is able to compile these functions and make them run much faster than if they were run just on NumPy.</p>&#13;
&#13;
<p>You can see that modifying one element in <code>x</code> results in an error. JAX would prefer that the array x is replaced rather than modified. One way to modify elements in an array is to do it in NumPy rather than JAX and convert NumPy arrays to JAX—for example, using <code>jnp.array(np_array)</code>—when the subsequent code needs to run fast on immutable data.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Indexing and Slicing" data-type="sect2"><div class="sect2" id="id9">&#13;
<h2>Indexing and Slicing</h2>&#13;
&#13;
<p>Another<a data-primary="JAX framework" data-secondary="indexing and slicing" data-type="indexterm" id="id355"/><a data-primary="indexing (in JAX)" data-type="indexterm" id="id356"/><a data-primary="slicing (in JAX)" data-type="indexterm" id="id357"/> important skill to learn is that of indexing and slicing arrays:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="n">x</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">array</code><code class="p">([[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code> <code class="p">[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">],</code> <code class="p">[</code><code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">]],</code> <code class="n">dtype</code><code class="o">=</code><code class="n">jnp</code><code class="o">.</code><code class="n">int32</code><code class="p">)</code>&#13;
&#13;
<code class="c1"># Print the whole matrix.</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>&#13;
<code class="p">[[</code><code class="mi">1</code> <code class="mi">2</code> <code class="mi">3</code><code class="p">]</code>&#13;
 <code class="p">[</code><code class="mi">4</code> <code class="mi">5</code> <code class="mi">6</code><code class="p">]</code>&#13;
 <code class="p">[</code><code class="mi">7</code> <code class="mi">8</code> <code class="mi">9</code><code class="p">]]</code>&#13;
&#13;
<code class="c1"># Print the first row.</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code>&#13;
<code class="p">[</code><code class="mi">1</code> <code class="mi">2</code> <code class="mi">3</code><code class="p">]</code>&#13;
&#13;
&#13;
<code class="c1"># Print the last row.</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">])</code>&#13;
<code class="p">[</code><code class="mi">7</code> <code class="mi">8</code> <code class="mi">9</code><code class="p">]</code>&#13;
&#13;
<code class="c1"># Print the second column.</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">])</code>&#13;
<code class="p">[</code><code class="mi">2</code> <code class="mi">5</code> <code class="mi">8</code><code class="p">]</code>&#13;
&#13;
<code class="c1"># Print every other element</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">[::</code><code class="mi">2</code><code class="p">,</code> <code class="p">::</code><code class="mi">2</code><code class="p">])</code>&#13;
<code class="p">[[</code><code class="mi">1</code> <code class="mi">3</code><code class="p">]</code>&#13;
 <code class="p">[</code><code class="mi">7</code> <code class="mi">9</code><code class="p">]]</code></pre>&#13;
&#13;
<p>NumPy introduced indexing and slicing operations that allow us to access different parts of an array. In general, the notation follows a <code>start:end:stride</code> convention. The first element indicates where to start, the second indicates where to end (but not inclusive), and the stride indicates the number of elements to skip over. The syntax is similar to that of the Python <code>range</code> function.</p>&#13;
&#13;
<p>Slicing allows us to access views of a tensor elegantly. Slicing and indexing are important skills to master, especially when we start to manipulate tensors in batches, which we typically do to make the most use of acceleration hardware.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Broadcasting" data-type="sect2"><div class="sect2" id="id10">&#13;
<h2>Broadcasting</h2>&#13;
&#13;
<p>Broadcasting<a data-primary="JAX framework" data-secondary="broadcasting feature" data-type="indexterm" id="id358"/><a data-primary="broadcasting (in JAX)" data-type="indexterm" id="id359"/> is another feature of NumPy and JAX to be aware of. When a binary operation such as addition or multiplication is applied to two tensors of different sizes, the tensor with axes of size 1 is lifted up in rank to match that of the larger-sized tensor. For example, if a tensor of shape <code>(3,3)</code> is multiplied by a tensor of shape <code>(3,1)</code>, the rows of the second tensor are duplicated before the operation so that it looks like a tensor of shape <code>(3,3)</code>:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="n">x</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">array</code><code class="p">([[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code> <code class="p">[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">],</code> <code class="p">[</code><code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">]],</code> <code class="n">dtype</code><code class="o">=</code><code class="n">jnp</code><code class="o">.</code><code class="n">int32</code><code class="p">)</code>&#13;
&#13;
<code class="c1"># Scalar broadcasting.</code>&#13;
<code class="n">y</code> <code class="o">=</code> <code class="mi">2</code> <code class="o">*</code> <code class="n">x</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">y</code><code class="p">)</code>&#13;
<code class="p">[[</code> <code class="mi">2</code>  <code class="mi">4</code>  <code class="mi">6</code><code class="p">]</code>&#13;
 <code class="p">[</code> <code class="mi">8</code> <code class="mi">10</code> <code class="mi">12</code><code class="p">]</code>&#13;
 <code class="p">[</code><code class="mi">14</code> <code class="mi">16</code> <code class="mi">18</code><code class="p">]]</code>&#13;
&#13;
<code class="c1"># Vector broadcasting. Axes with shape 1 are duplicated.</code>&#13;
<code class="n">vec</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">reshape</code><code class="p">(</code><code class="n">jnp</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mf">0.5</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code> <code class="mf">2.0</code><code class="p">]),</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">1</code><code class="p">])</code>&#13;
<code class="n">y</code> <code class="o">=</code> <code class="n">vec</code> <code class="o">*</code> <code class="n">x</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">y</code><code class="p">)</code>&#13;
<code class="p">[[</code> <code class="mf">0.5</code>  <code class="mf">1.</code>   <code class="mf">1.5</code><code class="p">]</code>&#13;
 <code class="p">[</code> <code class="mf">4.</code>   <code class="mf">5.</code>   <code class="mf">6.</code> <code class="p">]</code>&#13;
 <code class="p">[</code><code class="mf">14.</code>  <code class="mf">16.</code>  <code class="mf">18.</code> <code class="p">]]</code>&#13;
&#13;
<code class="n">vec</code> <code class="o">=</code> <code class="n">jnp</code><code class="o">.</code><code class="n">reshape</code><code class="p">(</code><code class="n">vec</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>&#13;
<code class="n">y</code> <code class="o">=</code> <code class="n">vec</code> <code class="o">*</code> <code class="n">x</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">y</code><code class="p">)</code>&#13;
<code class="p">[[</code> <code class="mf">0.5</code>  <code class="mf">2.</code>   <code class="mf">6.</code> <code class="p">]</code>&#13;
 <code class="p">[</code> <code class="mf">2.</code>   <code class="mf">5.</code>  <code class="mf">12.</code> <code class="p">]</code>&#13;
 <code class="p">[</code> <code class="mf">3.5</code>  <code class="mf">8.</code>  <code class="mf">18.</code> <code class="p">]]</code></pre>&#13;
&#13;
<p>The first case is the simplest, that of scalar multiplication. The scalar is multiplied throughout the matrix. In the second case, we have a vector of shape <code>(3,1)</code> multiplying the matrix. The first row is multiplied by 0.5, the second row is multiplied by 1.0, and the third row is multiplied by 2.0. However, if the vector has been reshaped to <code>(1,3)</code>, the columns are multiplied by the successive entries of the vector instead.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Random Numbers" data-type="sect2"><div class="sect2" id="id11">&#13;
<h2>Random Numbers</h2>&#13;
&#13;
<p>Along<a data-primary="JAX framework" data-secondary="random numbers" data-type="indexterm" id="id360"/><a data-primary="random numbers (in JAX)" data-type="indexterm" id="id361"/> with JAX’s philosophy of pure functions comes its particular way of handling random numbers. Because pure functions do not cause side effects, a random-number generator cannot modify the random number seed, unlike other random-number generators. Instead, JAX deals with random-number keys whose state is updated explicitly:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code> <code class="nn">jax.random</code> <code class="k">as</code> <code class="nn">random</code>&#13;
&#13;
<code class="n">key</code> <code class="o">=</code> <code class="n">random</code><code class="o">.</code><code class="n">PRNGKey</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>&#13;
<code class="n">x</code> <code class="o">=</code> <code class="n">random</code><code class="o">.</code><code class="n">uniform</code><code class="p">(</code><code class="n">key</code><code class="p">,</code> <code class="n">shape</code><code class="o">=</code><code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>&#13;
<code class="p">[[</code><code class="mf">0.35490513</code> <code class="mf">0.60419905</code> <code class="mf">0.4275843</code> <code class="p">]</code>&#13;
 <code class="p">[</code><code class="mf">0.23061597</code> <code class="mf">0.6735498</code>  <code class="mf">0.43953657</code><code class="p">]</code>&#13;
 <code class="p">[</code><code class="mf">0.25099766</code> <code class="mf">0.27730572</code> <code class="mf">0.7678207</code> <code class="p">]]</code>&#13;
&#13;
<code class="n">key</code><code class="p">,</code> <code class="n">subkey</code> <code class="o">=</code> <code class="n">random</code><code class="o">.</code><code class="n">split</code><code class="p">(</code><code class="n">key</code><code class="p">)</code>&#13;
<code class="n">x</code> <code class="o">=</code> <code class="n">random</code><code class="o">.</code><code class="n">uniform</code><code class="p">(</code><code class="n">key</code><code class="p">,</code> <code class="n">shape</code><code class="o">=</code><code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>&#13;
<code class="p">[[</code><code class="mf">0.0045197</code>  <code class="mf">0.5135027</code>  <code class="mf">0.8613342</code> <code class="p">]</code>&#13;
 <code class="p">[</code><code class="mf">0.06939673</code> <code class="mf">0.93825936</code> <code class="mf">0.85599923</code><code class="p">]</code>&#13;
 <code class="p">[</code><code class="mf">0.706004</code>   <code class="mf">0.50679076</code> <code class="mf">0.6072922</code> <code class="p">]]</code>&#13;
&#13;
<code class="n">y</code> <code class="o">=</code> <code class="n">random</code><code class="o">.</code><code class="n">uniform</code><code class="p">(</code><code class="n">subkey</code><code class="p">,</code> <code class="n">shape</code><code class="o">=</code><code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">y</code><code class="p">)</code>&#13;
<code class="p">[[</code><code class="mf">0.34896135</code> <code class="mf">0.48210478</code> <code class="mf">0.02053976</code><code class="p">]</code>&#13;
 <code class="p">[</code><code class="mf">0.53161216</code> <code class="mf">0.48158717</code> <code class="mf">0.78698325</code><code class="p">]</code>&#13;
 <code class="p">[</code><code class="mf">0.07476437</code> <code class="mf">0.04522789</code> <code class="mf">0.3543167</code> <code class="p">]]</code></pre>&#13;
&#13;
<p>JAX first requires you to create a random-number <code>key</code> from a seed. This key is then passed into random-number generation functions like <code>uniform</code> to create random numbers in the 0 to 1 range.</p>&#13;
&#13;
<p>To create more random numbers, however, JAX requires that you split the key into two parts: a new key to generate other keys, and a subkey to generate new random numbers. This allows JAX to deterministically and reliably reproduce random numbers even when many parallel operations are  calling the random-number generator. We just split a key into as many parallel operations as needed, and the random numbers resulting are now randomly distributed but also reproducible. This is a nice property when you want to reproduce experiments reliably.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Just-in-Time Compilation" data-type="sect2"><div class="sect2" id="id12">&#13;
<h2>Just-in-Time Compilation</h2>&#13;
&#13;
<p>JAX<a data-primary="JAX framework" data-secondary="just-in-time compilation" data-type="indexterm" id="id362"/><a data-primary="just-in-time (JIT) compilation" data-type="indexterm" id="id363"/> starts to diverge from NumPy in terms of execution speed when we start using JIT compilation. JITing code—transforming the code to be compiled just in time—allows the same code to run on CPUs, GPUs, or TPUs:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code> <code class="nn">jax</code>&#13;
&#13;
<code class="n">x</code> <code class="o">=</code> <code class="n">random</code><code class="o">.</code><code class="n">uniform</code><code class="p">(</code><code class="n">key</code><code class="p">,</code> <code class="n">shape</code><code class="o">=</code><code class="p">[</code><code class="mi">2048</code><code class="p">,</code> <code class="mi">2048</code><code class="p">])</code> <code class="o">-</code> <code class="mf">0.5</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">my_function</code><code class="p">(</code><code class="n">x</code><code class="p">):</code>&#13;
  <code class="n">x</code> <code class="o">=</code> <code class="n">x</code> <code class="o">@</code> <code class="n">x</code>&#13;
  <code class="k">return</code> <code class="n">jnp</code><code class="o">.</code><code class="n">maximum</code><code class="p">(</code><code class="mf">0.0</code><code class="p">,</code> <code class="n">x</code><code class="p">)</code>&#13;
&#13;
<code class="o">%</code><code class="n">timeit</code> <code class="n">my_function</code><code class="p">(</code><code class="n">x</code><code class="p">)</code><code class="o">.</code><code class="n">block_until_ready</code><code class="p">()</code>&#13;
<code class="mi">302</code> <code class="n">ms</code> <code class="err">±</code> <code class="mi">9</code> <code class="n">ms</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">1</code> <code class="n">loop</code> <code class="n">each</code><code class="p">)</code>&#13;
&#13;
<code class="n">my_function_jitted</code> <code class="o">=</code> <code class="n">jax</code><code class="o">.</code><code class="n">jit</code><code class="p">(</code><code class="n">my_function</code><code class="p">)</code>&#13;
&#13;
<code class="o">%</code><code class="n">timeit</code> <code class="n">my_function_jitted</code><code class="p">(</code><code class="n">x</code><code class="p">)</code><code class="o">.</code><code class="n">block_until_ready</code><code class="p">()</code>&#13;
<code class="mi">294</code> <code class="n">ms</code> <code class="err">±</code> <code class="mf">5.45</code> <code class="n">ms</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">1</code> <code class="n">loop</code> <code class="n">each</code><code class="p">)</code></pre>&#13;
&#13;
<p class="less_space pagebreak-before">The JITed code is not that much faster on a CPU but will be dramatically faster on a GPU or TPU backend. Compilation also carries some overhead  when the function is called the first time, which can skew the timing of the first call. Functions that can be JITed have restrictions, such as mostly calling JAX operations inside and having restrictions on loop operations. Variable-length loops trigger frequent recompilations. The  <a href="https://oreil.ly/c8ywT">“Just-in-Time Compilation with JAX” documentation</a> covers a lot of the nuances of getting functions to JIT compile.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id300">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>While we haven’t done much math yet, we have gotten to the point where we can begin providing recommendations and implementing deeper logic into these components. We’ll start doing things that look like ML soon enough.</p>&#13;
&#13;
<p>So far, we have defined what a recommendation problem is, set up the core architecture of our recommendation system—the collector, the ranker, and the server—and shown a couple of trivial recommenders to illustrate how the pieces come together.</p>&#13;
&#13;
<p>Next we’ll explain the core relationship that recommendation systems seek to exploit: the user-item matrix. This matrix lets us build a model of personalization that will lead to ranking.</p>&#13;
</div></section>&#13;
</div></section></body></html>