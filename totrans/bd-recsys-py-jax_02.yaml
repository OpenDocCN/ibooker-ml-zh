- en: Chapter 1\. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommendation systems are integral to the development of the internet that
    we know today and are a central function of emerging technology companies. Beyond
    the search ranking that opened the web’s breadth to everyone, the new and exciting
    movies all your friends are watching, or the most relevant ads that companies
    pay top dollar to show you lie more applications of recommendation systems every
    year. The addictive For You page from TikTok, the Discover Weekly playlist by
    Spotify, board suggestions on Pinterest, and Apple’s App Store are all hot technologies
    enabled by the recommendation systems. These days, sequential transformer models,
    multimodal representations, and graph neural nets are among the brightest areas
    of R&D in machine learning (ML)—all being put to use in recommendation systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Ubiquity of any technology often prompts questions of how the technology works,
    why it has become so common, and if we can get in on the action. For recommendation
    systems, the *how* is quite complicated. We’ll need to understand the geometry
    of taste, and how only a little bit of interaction from a user can provide us
    a *GPS signal* in that abstract space. You’ll see how to quickly gather a great
    set of candidates and how to refine them to a cohesive set of recommendations.
    Finally, you’ll learn how to evaluate your recommender, build the endpoint that
    serves inference, and log about its behavior.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We will formulate variants of the core problem to be solved by recommendation
    systems but, ultimately, the motivating problem framing is as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Given a collection of things that may be recommended, choose an ordered few
    for the current context and user that best match according to a certain objective.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Key Components of a Recommendation System
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we increase complexity and sophistication, let’s keep in mind the components
    of our system. We will use *string diagrams* to keep track of our components,
    but in the literature these diagrams are presented in a variety of ways.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'We will identify and build on three core components of recommendation systems:
    the collector, ranker, and server.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Collector
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The collector’s role is to know what is in the collection of things that may
    be recommended, and the necessary features or attributes of those things. Note
    that this collection is often a subset based on context or state.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Ranker
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ranker’s role is to take the collection provided by the collector and order
    some or all of its elements, according to a model for the context and user.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Server
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server’s role is to take the ordered subset provided by the ranker, ensure
    that the necessary data schema is satisfied—including essential business logic—and
    return the requested number of recommendations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, a hospitality scenario with a waiter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: When you sit down at your table, you look at the menu, unsure of what you should
    order. You ask the waiter, “What do you think I should order for dessert?”
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The waiter checks their notes and says, “We’re out of the key lime pie, but
    people really like our banana cream pie. If you like pomegranate, we make pom
    ice cream from scratch; and it’s hard to go wrong with the donut a la mode—it’s
    our most popular dessert.”
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this short exchange, the waiter first serves as a collector: identifying
    the desserts on the menu, accommodating current inventory conditions, and preparing
    to talk about the characteristics of the desserts by checking their notes.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Next, the waiter serves as a ranker; they mention items high scoring in popularity
    (banana cream pie and donut a la mode) as well as a contextually high match item
    based on the patron’s features (if they like pomegranate).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the waiter serves the recommendations verbally, including both explanatory
    features of their algorithm and multiple choices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: While this seems a bit cartoonish, remember to ground discussions of recommendation
    systems in real-world applications. One of the advantages of working in RecSys
    is that inspiration is always nearby.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Simplest Possible Recommenders
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve established the components of a recommender, but to really make this practical,
    we need to see this in action. While much of the book is dedicated to practical
    recommendation systems, first we’ll start with a toy and scaffold from there.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The Trivial Recommender
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The absolute simplest recommender is not very interesting but can still be
    demonstrated in the framework. It’s called *the trivial recommender* (*TR*) because
    it contains virtually no logic:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice that this recommender may return either a specific `item_id` or `None`.
    Also observe that this recommender takes no arguments, and `MAX_ITEM_INDEX` is
    referencing a variable out of scope. Software principles ignored, let’s think
    about the three components:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Collector
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: A random `item_id` is generated. The TR collects by checking the availability
    of `item_id`. We could argue that having access to `item_id` is also part of the
    collector’s responsibility. Conditional upon the availability, the collection
    of recommendable things is either `[item_id]` or `None` (*recall that `None` is
    a collection in the set-theoretic sense*).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Ranker
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The TR ranks with a no-op; i.e., the ranking of 1 or 0 objects in a collection
    is the identity function on that collection, so we merely do nothing and move
    on to the next step.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Server
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The TR serves recommendations by its `return` statements. The only schema that’s
    been specified in this example is that the return type is ⁠`Optional​[List[str]]`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: This recommender, which is not interesting or useful, provides a skeleton that
    we will add to as we develop further.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Most-Popular-Item Recommender
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *most-popular-item recommender* (MPIR) is the simplest recommender that
    contains any utility. You probably won’t want to build applications around it,
    but it’s useful in tandem with other components in addition to providing a basis
    for further development.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'An MPIR works just as it says; it returns the most popular items:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we assume that `get_item_popularities` has knowledge of all available items
    and the number of times they’ve been chosen.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: This recommender attempts to return the *k* most popular items available. While
    simple, this is a useful recommender that serves as a great place to start when
    building a recommendation system. Additionally, we will see this example return
    over and over, because other recommenders use this core and iteratively improve
    the internal components.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the three components of our system again:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Collector
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The MPIR first makes a call to `get_item_popularities` that—via database or
    memory access—knows which items are available and how many times they’ve been
    selected. For convenience, we assume that the items are returned as a dictionary,
    with keys given by the string that identifies the item, and values indicating
    the number of times that item has been chosen. We implicitly assume here that
    items not appearing in this list are not available.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Ranker
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we see our first simple ranker: ranking by sorting on values. Because
    the collector has organized our data such that the values of the dictionary are
    the counts, we use the Python built-in sorting function `sorted`. Note that we
    use `key` to indicate that we wish to sort by the second element of the tuples—in
    this case, equivalent to sorting by values—and we send the `reverse` flag to make
    our sort descending.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Server
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to satisfy our API schema, which is again provided via the
    return type hint: `Optional[List[str]]`. This wants the return type to be the
    nullable list of item-identifier strings that we’re recommending, so we use a
    list comprehension to grab the first element of the tuples. But wait! Our function
    has this `max_num_recs` field—what might that be doing there? Of course, this
    is suggesting that our API schema is looking for no greater than `max_num_recs`
    in the response. We handle this via the slice operator, but note that our return
    is between 0 and `max_num_recs` results.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Consider the possibilities at your fingertips equipped with the MPIR; recommending
    customers’ favorite item in each top-level category could make for a simple but
    useful first stab at recommendations for ecommerce. The most popular video of
    the day may make for a good home-page experience on your video site.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: A Gentle Introduction to JAX
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since this book has *JAX* in the title, we will provide a gentle introduction
    to JAX here. Its official documentation can be found [on the JAX website](https://jax.readthedocs.io/en/latest/).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: JAX is a framework for writing mathematical code in Python that is just-in-time
    (JIT) compiled. JIT compilation allows the same code to run on CPUs, GPUs, and
    TPUs. This makes it easy to write performant code that takes advantage of the
    parallel-processing power of vector processors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, one of the design philosophies of JAX is to support tensors and
    gradients as core concepts, making it an ideal tool for ML systems that utilize
    gradient-based learning on tensor-shaped data. The easiest way to play with JAX
    is probably via [Google Colab](https://colab.research.google.com/), which is a
    hosted Python notebook on the web.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Basic Types, Initialization, and Immutability
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by learning about JAX types. We’ll construct a small, three-dimensional
    vector in JAX and point out some differences between JAX and NumPy:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: JAX’s interface is mostly similar to that of NumPy. We import JAX’s version
    of NumPy as `jnp` to distinguish it from NumPy (`np`) by convention so that we
    know which version of a mathematical function we want to use. This is because
    sometimes we might want to run code on a vector processor like a GPU or TPU that
    we can use JAX for, or we might prefer to run some code on a CPU in NumPy.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The first point to notice is that JAX arrays have types. The typical float type
    is `float32`, which uses 32 bits to represent a floating-point number. Other types
    exist, such as `float64`, which has greater precision, and `float16`, which is
    a half-precision type that usually only runs on some GPUs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The other point to note is that JAX tensors have shape. This is usually a tuple,
    so `(3,)` means a three-dimensional vector along the first axis. A matrix has
    two axes, and a tensor has three or more axes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Now we come to places where JAX differs from NumPy. It is really important to
    pay attention to [“JAX—The Sharp Bits”](https://oreil.ly/qqcFM) to understand
    these differences. JAX’s philosophy is about speed and purity. By making functions
    pure (without side effects) and by making data immutable, JAX is able to make
    some guarantees to the underlying accelerated linear algebra (XLA) library that
    it uses to talk to GPUs. JAX guarantees that these functions applied to data can
    be run in parallel and have deterministic results without side effects, and thus
    XLA is able to compile these functions and make them run much faster than if they
    were run just on NumPy.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: You can see that modifying one element in `x` results in an error. JAX would
    prefer that the array x is replaced rather than modified. One way to modify elements
    in an array is to do it in NumPy rather than JAX and convert NumPy arrays to JAX—for
    example, using `jnp.array(np_array)`—when the subsequent code needs to run fast
    on immutable data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and Slicing
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another important skill to learn is that of indexing and slicing arrays:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: NumPy introduced indexing and slicing operations that allow us to access different
    parts of an array. In general, the notation follows a `start:end:stride` convention.
    The first element indicates where to start, the second indicates where to end
    (but not inclusive), and the stride indicates the number of elements to skip over.
    The syntax is similar to that of the Python `range` function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Slicing allows us to access views of a tensor elegantly. Slicing and indexing
    are important skills to master, especially when we start to manipulate tensors
    in batches, which we typically do to make the most use of acceleration hardware.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Broadcasting is another feature of NumPy and JAX to be aware of. When a binary
    operation such as addition or multiplication is applied to two tensors of different
    sizes, the tensor with axes of size 1 is lifted up in rank to match that of the
    larger-sized tensor. For example, if a tensor of shape `(3,3)` is multiplied by
    a tensor of shape `(3,1)`, the rows of the second tensor are duplicated before
    the operation so that it looks like a tensor of shape `(3,3)`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first case is the simplest, that of scalar multiplication. The scalar is
    multiplied throughout the matrix. In the second case, we have a vector of shape
    `(3,1)` multiplying the matrix. The first row is multiplied by 0.5, the second
    row is multiplied by 1.0, and the third row is multiplied by 2.0\. However, if
    the vector has been reshaped to `(1,3)`, the columns are multiplied by the successive
    entries of the vector instead.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Random Numbers
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Along with JAX’s philosophy of pure functions comes its particular way of handling
    random numbers. Because pure functions do not cause side effects, a random-number
    generator cannot modify the random number seed, unlike other random-number generators.
    Instead, JAX deals with random-number keys whose state is updated explicitly:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: JAX first requires you to create a random-number `key` from a seed. This key
    is then passed into random-number generation functions like `uniform` to create
    random numbers in the 0 to 1 range.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'To create more random numbers, however, JAX requires that you split the key
    into two parts: a new key to generate other keys, and a subkey to generate new
    random numbers. This allows JAX to deterministically and reliably reproduce random
    numbers even when many parallel operations are calling the random-number generator.
    We just split a key into as many parallel operations as needed, and the random
    numbers resulting are now randomly distributed but also reproducible. This is
    a nice property when you want to reproduce experiments reliably.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Just-in-Time Compilation
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JAX starts to diverge from NumPy in terms of execution speed when we start
    using JIT compilation. JITing code—transforming the code to be compiled just in
    time—allows the same code to run on CPUs, GPUs, or TPUs:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The JITed code is not that much faster on a CPU but will be dramatically faster
    on a GPU or TPU backend. Compilation also carries some overhead when the function
    is called the first time, which can skew the timing of the first call. Functions
    that can be JITed have restrictions, such as mostly calling JAX operations inside
    and having restrictions on loop operations. Variable-length loops trigger frequent
    recompilations. The [“Just-in-Time Compilation with JAX” documentation](https://oreil.ly/c8ywT)
    covers a lot of the nuances of getting functions to JIT compile.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: JIT 编译的代码在 CPU 上速度提升不多，但在 GPU 或 TPU 后端上速度会显著提升。当函数第一次调用时，编译也会带来一些开销，这可能会使第一次调用的时间偏离。能够
    JIT 编译的函数有一些限制，比如主要在内部调用 JAX 操作，并对循环操作有限制。长度可变的循环会触发频繁的重新编译。[“Just-in-Time Compilation
    with JAX” 文档](https://oreil.ly/c8ywT)详细介绍了许多 JIT 编译函数的细微差别。
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While we haven’t done much math yet, we have gotten to the point where we can
    begin providing recommendations and implementing deeper logic into these components.
    We’ll start doing things that look like ML soon enough.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们还没有进行太多的数学工作，但我们已经到了可以开始提供推荐和实现这些组件更深层逻辑的阶段。我们很快将开始做一些看起来像是机器学习的事情。
- en: So far, we have defined what a recommendation problem is, set up the core architecture
    of our recommendation system—the collector, the ranker, and the server—and shown
    a couple of trivial recommenders to illustrate how the pieces come together.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了推荐问题的概念，并设置了我们推荐系统的核心架构——收集器、排名器和服务器，并展示了几个简单的推荐器来说明这些部件如何组合在一起。
- en: 'Next we’ll explain the core relationship that recommendation systems seek to
    exploit: the user-item matrix. This matrix lets us build a model of personalization
    that will lead to ranking.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将解释推荐系统试图利用的核心关系：用户-物品矩阵。这个矩阵使我们能够构建个性化模型，从而进行排名。
