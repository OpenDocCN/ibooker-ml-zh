# 第十六章：16 所有者和维护

### 本章涵盖了

+   正确系统维护的重要性

+   责任感是构建和维护健康机器学习系统的一个关键因素

+   “巴士因素”以及团队效率与冗余之间的权衡

+   正确安排文档的基本重要性

+   复杂性的欺骗性吸引力

> 有能力的程序员完全清楚自己头脑的局限性。因此，他以完全谦卑的态度来处理任务，并像躲避瘟疫一样避免使用巧妙的技巧。——埃德加·迪杰斯特拉

在过去的 15 章中，我们一直试图将这本书组织成一个扩展的、深入的清单，你可以在设计你的机器学习（ML）系统过程中的任何阶段随时参考。但这些看似明显的建议比你想象的更难遵循。

从零开始构建 ML 系统，尤其是运营现有解决方案，是一个如此复杂和苛刻的过程，我们肯定会犯错、跌倒、遇到一些障碍，并在为业务创造价值的过程中妥协一些原则。作为不完美的人类，我们也意识到有时我们可能允许自己忽略一些自己的建议。

事实上，有时你可能看到或最终得到一个不遵循我们在书中倡导的原则的系统，其原因可能以无数种方式变化：一些细节可能被遗漏，公司可能已经改变了优先级和约束条件，系统可能确实需要更新，因为其原始假设不再有效，等等。

通常，这甚至更加平凡，因为最初设计和构建系统的人往往会更换工作。更甚者，他们可能在完成系统建设之前离开公司；这是事物的本质。考虑到这一点，所有者和维护不是我们以后需要考虑的事情，而是整个系统的基石，需要从一开始就深入人心。然而，在这个过程中，有可能和风险是过于沉迷于自己的创造，这是应该避免的。系统不应被视为作者的一部分，你应该从你的设计和自我中解脱出来，以提供最佳可能的解决方案。

用三个要点来概括，在任何时刻都至关重要：

+   每个参与项目的人背后的责任区域是什么？我们在责任/所有权方面是否有任何缺口？

+   有多少人具有特定的知识？我们是否有足够的冗余？

+   可用文档在哪里，系统的哪些组件被记录在案？负责团队之外的人能否运行该系统？

在一定程度上，设计文档有助于回答（尽管只是部分且不总是直接）这些问题。这意味着只有一个结论：我们必须关注这些方面，以避免未来出现任何令人遗憾的后果。毕竟，最重要的是构建和维护一个能满足你的需求并带来价值的产品。

在本章中，我们涵盖了使系统持久和稳健应对人为变化的必要基础知识。

## 16.1 责任制

在本书的前几章中，我们提到了在信息收集过程中涉及各种利益相关者的必要性，他们将为机器学习系统开发的准备阶段提供关键输入。

随着项目的增长，不断吸收新的输入，并从简单的常量基线演变为一系列紧密相连的复杂模型，它将逐渐被新的参与者加入。其中一些人可能只会在短时间内加入你，一旦他们的参与不再必要（例如，数据标注者在数据集处理阶段至关重要，但在部署时就会减少），一些人将变成永久贡献者直到系统发布，而少数人最终将成为所谓的“核心团队”（即项目中最亲近的人）。这些同事（或如果是外部供应商的代表，则指他们）将成为对最终结果和系统稳定性负责的人。而你应当定期与他们保持联系，或者至少要认识他们。

了解责任区域和分配给这些角色的个人对于任何项目或系统的成功启动和未来发展至关重要。这可能听起来很荒谬，但对于实际上负责特定组件的团队成员来说，了解这一点甚至更重要。你会惊讶地发现，有多少次 A 认为 B 对项目的某个部分负责，而 B 反过来又确信情况相反。这种情况的经典例子可以在图 16.1 中看到。

![figure](img/CH16_F01_Babushkin.png)

##### 图 16.1 明确与隐含方法在项目中对人的参与

明确地重复说明比隐含地希望每个人都处于同一页面上更有价值，根据我们的经验，这种方法一旦项目中有三个人参与，就更适用，更不用说更多的团队成员了。关于这个主题，我们最喜欢的一句话来自诺贝尔物理学奖获得者理查德·费曼。在他的书《当然你在开玩笑，费曼先生！》中，他写道

> 在普林斯顿这个项目中，我第一次遇到的有趣经历之一是遇见了许多杰出人物。我以前从未遇见过这么多杰出人物。但有一个评估委员会必须试图帮助我们，并最终决定我们将如何分离铀。这个委员会上有康普顿、托尔曼、斯密思、尤里、拉比和奥本海默这样的人。我会坐下来，因为我理解我们分离同位素的过程的理论，所以他们就会问我问题并讨论它。在这些讨论中，一个人会提出一个观点。然后，比如康普顿会解释一个不同的观点。他会说应该是这样，而且他完全正确。另一个人会说，嗯，也许，但是还有其他可能性我们必须考虑。
> 
> 所以每个人都不同意，围坐在桌旁。我很惊讶和不安，康普顿没有重复并强调他的观点。最后，在结束时，作为主席的托尔曼会说：“好吧，听了所有这些论点，我想康普顿的论点是所有中最出色的，现在我们必须继续前进。”
> 
> 看到一群人能够提出很多想法，每个人都想到了一个新的方面，同时记住其他人说过的话，最终决定哪个想法最好——总结所有这些——而不必说三遍，这对我来说是个很大的冲击。这些人确实非常伟大。

如果你没有一帮天才在处理一个国家优先级项目，你最好不要依赖他们的内部理解，说（或写！）三遍，与每个人分享，并确保他们不容易错过。像会议记录、跟进、更新和同步这类事情本质上都是为了这个目的而做的。

然而，我们看到了很多人滥用这些原则，在无意义的同步上花费太多，将会议的概念变成了整个行业的噩梦。那些仪式、遗物或无论你叫它们什么，都不需要花费太多时间，也不必仅仅因为它们写在了教科书中就去做，而是为了实现保持专注的具体目标。不使用它们，以及过度使用它们，都可能严重影响长期的表现和可持续性。我们坚信文档被严重低估了，其重要性被严重低估。

应对责任区域应该被记录下来，以确保团队对它们有明确和不含糊的理解。可能有各种正式程度——从创业友好的“爱丽丝完全负责让系统 X 工作”到复杂的跨页层次结构。一种相当平衡的方法是使用简单而强大的 RACI 矩阵，将涉及的人员分为四个组：

+   **负责**——*实际执行任务的个人（们）。常见人选：机器学习工程师*。

+   *责任人*——*最终对任务完成负责的人，通常是经理或团队领导。建议每个组件的责任人应也有权批准或拒绝工作。常见角色：项目经理或高级工程师。

+   *咨询者*——*寻求其意见的人，通常是领域专家或对任务有特定兴趣的利益相关者。常见角色：领域专家或法律代表。

+   *知情者*——*需要了解进度或决策但并不直接贡献整体输入的人。常见角色：前端工程师。

无论好坏，总会有责任上的空缺；因此，描述一种明确的升级方式是有意义的——如果情况不符合矩阵或其他与责任相关的工具，可以采取什么措施？

关于责任的一个最终且可能不太受欢迎的部分是应急班次。处于应急状态意味着在班次期间，有特定的人负责响应任何关键事件。他们必须准备好在紧急情况下迅速反应，通常在 30 到 60 分钟内。轮换部分意味着这项职责通常由团队成员共享，并定期变更。例如，某个人可能一周处于应急状态，然后在下周将职责转交给下一个人（见图 16.2）。

![图](img/CH16_F02_Babushkin.png)

##### 图 16.2 应急班次是防止团队过劳的必要措施。

应急班次通常在公司成长过程中出现。那些在职业生涯早期或在较小的公司有经验的人可能还记得，在那个环境中不需要轮换，因为每个人都是应急状态，事件由当时可用的任何人处理。然而，在某个时候，这种方法变得难以管理，当团队成员之间的责任模糊时，会导致事件由每个人同时管理，又没有人管理。一旦你开始注意到这种行为，就是时候正式化应急班次了。后来，可能需要有一个专门的应急班次团队，将轮换结构化为 L1/L2/L3 等级等。

即使你的值班时间表正在运行，也可能有其他原因导致整个团队超负荷工作。Arseny 曾在一家处于早期发展阶段的公司工作，他面临了一些系统事件，由于他根本不知道哪些系统受到影响，这些问题根本无法解决。这是一次令人沮丧的经历，直到那些构建和维护这些系统的工程师最终编写了包含典型问题建议的稳固的食谱。一些技术债务得到了清理，值班班次从无尽的噩梦转变为常规任务——虽然不是最舒适的，但至少是可以忍受的。当 L1 事件由一个专门的团队负责时，机器学习团队值班的时间进一步减少。

显然，周六凌晨 3 点被叫醒并不是理想的情况，这可能会产生额外的动力去构建一个健壮且监控良好的系统，这有助于最小化问题，并以人们事先知道的方式制定值班“名单”和班次时间。任何看不到适当日志和可观察性价值的工程师都应该被安排足够长时间的值班，以改变他们的想法。

我们相信，负责系统设计和实施的人也应对系统的维护和支持负责。他们比任何人都更了解细节，并能预测边缘情况并提出解决问题的捷径。这并不意味着他们必须是唯一被召唤的人，但他们应该为值班轮换做好准备，并为值班团队提供必要的工具和文档。

常用的工具包括

+   日志、指标、警报和仪表板

+   系统和相关基础设施配置

+   系统源代码和文档

访问生产数据有些复杂。修复问题并不总是需要访问生产数据；我们见证过隐私政策限制访问的情况。然而，通常来说，访问生产数据以调查问题和找到根本原因是有益的。否则，日志和指标应该足够详细，以便帮助解决这个问题。

总应该有一个运行手册，其中包含如何修复最常见问题的注释以及如果需要升级问题的人员名单（例如，供应商方面可能发生故障，值班工程师需要联系可以与供应商沟通的 CTO）。许多问题都有一定的节奏；它们是技术债务或使用模式的反映。例如，想象有一个大客户具有尖峰使用模式，这导致系统在负载下挣扎。对于这种情况，值班工程师可能需要一份关于如何启动系统额外实例以及如何在负载恢复正常时缩小规模的食谱。

出现的生产问题会引发两个衍生品：解决和学习。为了避免反复面对同样的错误，请确保建立一个从失败中学习的流程。这可以通过回顾和事后分析来安排。我们建议遵循**比例响应**原则——一套针对事件后采取的行动，其规模应与失败影响相似，并考虑到未来可能发生类似失败的机会。有些事件只需 10 分钟的讨论，并在操作手册中添加一段内容。Arseny 曾经触发了一次大规模的故障，以至于 CTO 不得不启动一个名为“可靠发布竞赛”的倡议，涉及公司中的每个工程团队，并提高了所有系统的可靠性，而不仅仅是 Arseny 成功破坏的机器学习系统。

## 16.2 **公交车因素**

**公交车因素**是一个衡量项目因单个团队成员的丢失而中断风险的指标。术语**公交车因素**来源于一个假设场景，即团队成员被公交车撞到，这会突然且意外地使他们从项目中消失。

**CAP 定理**指出，任何分布式数据存储只能提供以下三个特性中的两个：

+   **一致性**——每个读取请求都收到最新的响应或错误。

+   **可用性**——每个请求都收到有效的响应，但没有任何保证它包含最新的数据。

+   **分区容错**——即使节点间的通信被中断或丢失，系统仍然继续运行。

当发生网络分区故障时，必须在取消操作以增强一致性但牺牲可用性或继续操作以保持可用性但可能损害一致性之间做出决定。

我们认为团队结构非常接近，但有不同的标准：效率和冗余。正如计算机科学所描述的，冗余意味着有额外的或重复的资源可用以支持主系统。这是一个备份或备用系统，如果主系统失败，它可以介入。备用资源是冗余的，因为如果一切正常，它们就不会被使用。

**注意**工程师往往倾向于用技术解决方案来解决组织问题（换句话说，把人当作软件来对待），仅仅因为他们在这方面很擅长。有时这已经足够好了，因为构建软件可能确实比与人相处和对齐以实现具有挑战性的目标要简单。然而，高级工程师不应该像看到到处都是钉子的锤子一样——他们应该为问题选择合适的工具，有时甚至不是技术工具。

这种冗余/效率问题如何影响团队结构？从我们所见到的来看，公司/团队/项目方案通常是从高效发展到冗余。然而，过于高效或过于冗余都不利。

### 16.2.1 为什么过于高效并不好？

如果你过于高效，并且只有少数人覆盖多个因素，你就有风险。团队中的每个人都是不可替代的，这不仅是因为他们的经验，而且不幸的是，也因为他们以全负荷工作。如果至少有一个团队成员发生任何问题，公司（或项目）就会陷入困境。唯一能够处理不降低整体效率出现的任何问题的方法是通过英雄行为，这些行为在任何方式上都是不可扩展的，因此被视为反模式（[`mng.bz/YVyA;`](https://mng.bz/YVyA;)参见图 16.3）。

![figure](img/CH16_F03_Babushkin.png)

##### 图 16.3 极端效率的缺点是对外部因素极端脆弱。

### 16.2.2 为什么过度冗余并不有益？

与效率相比，冗余的主要优势是额外的容量，这提供了可靠性、安全性、改进的空间以及度过危机的余地。然而，过多的冗余会导致粗心大意，减少团队成员之间的信任，并排斥顶尖人才，因为它损害了整体的工作氛围和完成有意义且影响深远工作的感觉。

这里的两个例子是明显的边缘情况，应该避免。一旦你觉得团队接近其容量极限，考虑扩展是值得的，尽管目前成本会增加，但这将是长期正确的解决方案。

同样的规则也可以反过来应用：一方面，有足够的容量避免过度劳累，另一方面，在高峰负载时间准备好应对潜在的危机。

### 16.2.3 何时以及如何使用公交车因素

我们需要在效率和冗余之间保持适当的平衡，控制某物的第一步是能够衡量；一个非常简单且广为人知的指标就是公交车因素。

公交车因素是通过计算在项目无法继续之前需要失去多少团队成员来计算的。例如，如果一个项目的公交车因素为 1，即使失去一个（特定的）团队成员，项目也会陷入严重困境。

显然，1 的公交车因素（bus factor）低于理想水平，而 10000 的公交车因素可能过多（尽管这可能发生在你需要许多具有相对相似范围的人的情况下，例如客户支持）；最终数字取决于许多变量：项目重要性、预算限制、截止日期、预期周转率和项目所有者的焦虑/信心。但一旦你有一份负责系统/项目不同部分的负责人的名单，你就拥有了计算公交车因素所需的一切，这包括负责区域和负责人员。接下来你需要做的是找出有多少其他人足够了解这个领域。一般来说，负责该领域的人知道所有可以（在一定程度上）替代他们的人。考虑到这一点，你可以计算公交车因素，评估潜在风险，并做出必要的招聘、调动或协作活动决策，以传播知识并解决项目可能存在的脆弱性。

当然，我们不能将人们以离散的方式标记为“他们知道系统或其组件是如何工作的”与“他们不知道”。通常，系统内部存在知识的不同层次，即使不可能让许多工程师了解所有事情，也有可能部分地传播这种知识。这通常通过设计/代码/文档审查、结对编程会议和开放时间来实现，关键成员在此分享他们的专业知识。

这种推理描述了两个标准之间的平衡。然而，真正的决策可能需要考虑更多的标准（例如，不仅仅是团队规模，还包括其高级平衡和特定技术的接触）。

对于那些对如何看到成本、系统性能和人力容量之间的权衡感兴趣的人来说，我们建议熟悉 Rasmussen 模型，该模型在本文中得到了很好的解释：[`mng.bz/GNqO`](https://mng.bz/GNqO)。与之前专注于团队结构的文本不同，这篇文章反映了 SRE 对系统权衡的看法：尽管人和硬件非常不同，但在寻找最佳权衡方面存在相似的模式。

## 16.3 文档

我们已经提到了文档的重要性。不幸的是，文档通常被高度低估，并且并不总是得到应有的关注和照顾。讽刺的是，“文档”这个词经常与“稍后”、“现在不”、“不紧急”等词语并列。而且当需要文档时，通常为时已晚，或者过于陈旧。

文档的重要性不容小觑。它作为知识转移和入职新团队成员的手段，有助于为新员工平滑学习曲线，并确保系统的长期运行。全面的文档允许负责团队之外的人有效地理解和运行系统。

##### 瓦列里营火故事

我在不同的公司工作过：线下和线上食品零售、电子商务平台、社交网络公司以及金融科技公司。我非常自豪的一点是——无论公司规模、市场和发展成熟度如何——我所建立的系统和组织都能够经受住我的离职并继续成功运营。这其中的基石包括为新员工提供平滑的学习曲线、广泛的文档以及与其他部门的彻底整合，以及让每个人都知道谁负责特定的部分。

有一回，我收到了一位来自大型科技公司的前同事的消息，询问如何重现一个特定的系统组件（一个能够为销售商品生成合成评论的语言模型）。我的回答简短——那个项目的文档可以在特定的标签下找到，而且确实找到了！（坦白说，他甚至不需要我帮忙找到。）而且不仅找到了，你还可以使用它通过单个命令重现整个部署过程，或者如果需要的话，检查代码库和数据集。

这里有一个非常不同的例子。有一回我在一家公司工作，我们必须重新创建比特币区块链的链上分析，这最初是在 2 年前完成的，但一些来源已经改变，需要替换/更新。不幸的是，几乎没有文档，原本最多只需要两周就能完成的工作几乎消耗了 3 个月的时间（链上分析并不简单；例如，你可能会发送 0.1BTC，但它看起来像你发送了 1BTC 并收到了 0.9BTC，这与实际情况非常不同）。在这个项目完成后不久，那里的大部分团队成员都被裁员，公司员工总数的 30%也被裁掉。这是 6 个月内的第二次裁员。合计，他们几乎将公司的员工人数减少了 60%。很难说主要原因是否是缺乏文档，但我确信反复重新发明轮子（在这个案例中，重新走同样的步骤）并不是最有效率的资源利用方式。这就是为什么缓存在计算机科学中如此普遍。不幸的是，裁员发生在项目完成后，但文档还没有完成。

文档还有助于在团队成员离职（人员冗余）或新成员加入时实现更平滑的过渡。此外，文档促进了不同部门和利益相关者之间的协作，促进了系统（责任）的共享理解，并使每个工程师更加独立，从而更加主动和高效。

虽然一开始可能需要额外的时间和精力，但文档最终在长期中节省了资源。它减少了部落知识的依赖，防止了工作的重复，并最小化了由于信息不足而导致的高成本错误和延迟的风险。记录流程、程序、配置和最佳实践使团队能够更有效地工作，并为持续改进提供了基础。它应该从一开始就优先考虑，而不是被视为事后之想。通过承认文档的重要性并投入必要的资源，团队能够构建能够适应变化并随着时间的推移持续提供价值的弹性系统。

在一定程度上，我们整本书都是致力于探讨为什么以及如何编写特定类型的文档，这些文档能够捕捉到关于系统设计、架构、实现细节和操作流程的重要信息。但设计文档是非常具体的一份文档，其目标不是成为涵盖系统所有方面的全面文本，而是一个概述，有助于同步系统构建者和利益相关者的团队。话虽如此，总还有空间为其他文档留出位置，包括

+   *用户手册和指南* 解释如何使用系统，并提供常见任务（如数据准备、模型训练和预测）的逐步说明

+   *操作手册* 提供使用系统达成目标的方法，并提供代码片段、数据示例和达到目标结果的特定步骤

+   *低级技术规范* 和 *API 文档*，为开发者描述机器学习系统的底层技术细节，并指导如何使用函数和 API 在编程层面上与系统交互

+   *安装和配置指南*，提供如何设置和微调机器学习环境、解释依赖关系、安装步骤以及配置软件的选项

+   *常见问题解答和故障排除指南*，针对使用机器学习工具时遇到的一些常见问题，提出解决方案或替代方案，以解决您在训练、测试或部署过程中可能遇到的问题

+   *版本发布说明* 详细说明新软件版本中应用的变化；解释新功能、错误修复、性能改进或已知问题；并通知用户关于新版本及其对整体工作流程的影响

+   *以往事件调查报告* 分析并记录过去问题或失败的根本原因，分享经验教训和避免类似事件采取的措施，以提高系统可靠性和用户信心

从一开始就投入时间和精力来创建和维护文档，有助于团队减轻与知识差距和依赖特定个人相关的风险。在本书的编写过程中，您已经看到了两份设计文档，我们希望这些文档能为您提供关于所描述系统的良好概述。

## 16.4 复杂度

> 尽可能使一切尽可能简单，但不能更简单。——据说是爱因斯坦所说

根据热力学第二定律，一个孤立系统在自发演化过程中，其熵随时间不能减少。虽然最初“熵”是一个用于物理学的术语，但它后来被信息理论所采用，几乎具有相同的意义：熵量化了不确定性或随机性的数量。

比喻来说，软件和机器学习系统遵循相同的法则：随着时间的推移，熵只能增加。在某个时刻，它变得难以处理，这就是为什么旧系统通常被分解成一系列较小的系统（记住第 13.1 节中的软件工程基本定理），以便由一群相当聪明的人维护，而不是一代代的天才。添加一个新的抽象层次“隐藏”了熵，但并没有真正在整个堆栈中降低其水平。

有许多集体意识碎片表达类似的想法：极限编程文化中的 YAGNI（“你不需要它”）方法，20 世纪中叶起源于美国海军的 KISS（“保持简单，傻瓜”）原则，甚至还有从中世纪时代开始的奥卡姆剃刀。所有这些想法都追求同一个目标：限制复杂性。

同时，软件工程文化倾向于光谱的另一端，正如 DRY（“不要重复自己”）这样的缩写谚语所表达的那样。乍一看，这些是具有争议性的：遵循 DRY 意味着引入更多的抽象层，而这正是复杂性的一个（或者更确切地说，是唯一的一个）来源。

想象编写一个简单的代码片段，计算多个数据集上的一个众所周知的指标。一个典型的代码集可能包含大约三个函数：一个读取数据，下一个计算指标，最后一个协调执行，在循环中运行这两个函数并保存结果。

现在，让我们想象光谱的两端：一方面是过于简单的代码，另一方面是过于复杂的代码，它们执行相同的事情。前者可能是由一个对循环和函数知之甚少的人编写的；他们只是按照指示编写：读取文件 A，计算 A 的指标，保存 A 的指标，读取文件 B，等等。过于复杂的代码将包含一些元编程和其他复杂模式。虽然它们在本质上完全不同，但两者都会使代码的可读性变差。

这是一个在几乎每本教授如何编写干净代码的软件工程教科书中都能找到的简单示例。但同样的原则也适用于更大的规模。想象一下解决以下问题：你的公司想要帮助客户支持团队优先处理最紧急的案件，以便首先帮助最不满意的客户。

目前解决这个问题的典型方案是使用一个定制的提示来对消息进行分类，将其归入几个紧急程度不同的类别。在大语言模型革命之前，比例基线是创建一个简单的模型（例如在词袋模型上进行的逻辑回归）来进行分类，以便覆盖大多数紧急消息。这还需要一些工程努力（例如，构建数据管道以获取训练集，并使用客户支持团队进行标记，将模型与客户服务软件连接起来以传播这些标签并在 UI 中可视化它们等）。

一种不合理简单化的偏差是构建一个包含多个条件和正则表达式的基线。这个解决方案肯定会在一段时间内有效，但相对很快，你的同事会像支付了两次产品的客户一样不高兴，因为一个错误请求公司回滚交易，并且由于某些不清楚的原因，你的模型将票据分类为“低优先级”。

一种过度复杂的解决方案可以包括许多由同一个词“不相关”连接的组件。你可以引入多个从头开始训练的复杂自然语言理解模型，用一些研究使它们在少量样本的情况下工作，并用校准层进行润色。复杂性可能不仅仅是机器学习特有的，也可能偏向于工程：而不是拥有几个简单的 API，工程师可以使用他们知道的全部流行词汇来使系统具有与太空船固件一样容错性和与谷歌搜索引擎一样可扩展性，而忽略了它每天只需处理几十条消息的事实。

所有类型的系统——包括非软件系统——都受到复杂性的困扰。软件复杂性的额外层次在于其不断的演变。当你建造房子时，你不会在屋顶完工后一个月就在上面添加额外的房间。然而，向软件系统中添加新功能却是一种更为常见的做法。数据导向系统的复杂性增加是因为与数据漂移相关的持续问题。机器学习系统甚至更加复杂——一些模型设计上就是非线性黑盒，这并没有使事情变得更容易。

在书的最后，我们再次提到第二章和第三章，涵盖问题理解和初步研究。一些复杂性是不可避免的，但大量不必要的复杂性是由这些阶段的失误造成的：对问题理解不足、表面化研究、设定不相关的目标，以及从一开始就没有涵盖明显的风险。这些都可能导致一系列糟糕的决定和复杂性的增加。

当你需要横渡河流时，一艘可靠的划船可能就足够了。你甚至可以给它装上马达来加速你的渡河之旅，但无法将这艘船进化成能够运送数千人横渡大洋的船只（见图 16.4）。同时，那些在旅行距离不超过几英里时就着手组装邮轮的人永远无法达到目标。许多机器学习系统因为与这个比喻相关的原因而注定失败：他们的设计者要么试图将一个原始系统通过添加各种功能来满足相当具有挑战性的目标，要么在没有良好推理的情况下开始建造宇宙飞船，甚至在建设的第一阶段准备就绪之前就被解雇了。

![图片](img/CH16_F04_Babushkin.png)

##### 图 16.4 正如一个基本模型最终会表现不佳并无法满足项目目标一样，过度设计的解决方案会消耗企业宝贵的资源。

##### 来自阿列克谢的篝火故事

我未能按时完成这一章的定稿，因为我忙于我的主要工作，并且因为我过去自己做出的聪明决定。三年前，我需要测试一个应该在两个环境中运行模型的部分系统：本地和基于云的环境。测试很简单：在两个空间中运行相同的内容，并断言结果相等。但我追求节省一些毫秒，因此让两个调用在单独的线程中并发运行。这很聪明，也很有效！几年过去了，代码库发生了演变，推出了新功能，基础设施发生了很大变化，其中这些基础设施变化之一改变了云中事物应有的工作方式。所以你可以预期这个测试开始失败。然而，Python 线程中的异常不是隐式的，所以在这种情况下测试失败只会导致一个几乎无关紧要的消息。更糟糕的是，这些测试也是并发执行的，这进一步隐藏了真正的问题。一个不必要的复杂性让我花费整整一天的时间来揭露这个问题。

这个故事省略了一些工程细节，比如非典型性的持续集成配置，但即使简化后，它也表明这种浪费时间的根本原因不是单一的——它更像是千刀万剐的死亡。正如流行的列表“复杂系统如何失败”([`how.complexsystems.fail/`](https://how.complexsystems.fail/))所说：“事故后归因于‘根本原因’是根本错误的。”并不是一个糟糕的决定，而是一系列次优选择的结果。组合数学对你不利：即使与系统相关的决策大多数是最佳的，一个复杂系统中的巨大组合数量会导致越来越多的意外事件。你能做的只是减少这些数量，以及每个小故障的影响。

## 16.5 维护与所有权：超级大零售和 PhotoStock Inc.

在整本书中，我们每章都以一个案例研究结束，展示了 Supermegaretail 和 PhotoStock Inc.的相关设计文档部分。在这个案例中，这样做意义不大，因为这需要虚构几十个假的前后名字。我们只限于对如何在两个例子中进行维护的一般性考虑。

由于 Supermegaretail 是一家拥有数千名员工的大型企业，官僚化程度高，工作流程复杂，而其关键业务部门主要是非技术性的，因此，在项目成功中扮演着重要角色的是与每个层级利益相关者的所有阶段的成功协调。因此，系统有效发布后的基础将是一个详细的 RACI 矩阵，包括参与项目的公司员工，以及交付团队、执行团队和业务团队的签字清单。

另一方面，PhotoStock Inc.是一家相当小、完全基于技术的公司，与数百万图像一起工作的定制搜索引擎的特定性意味着系统上持续有负载，并且有定期的峰值负载。搜索引擎是一个既依赖机器学习又依赖基础设施的项目。正如之前所强调的，它需要广泛的跨团队合作。鉴于有四个核心组件（API 处理器、索引、排名模型、内部工具），我们希望确保

+   每个组件都有一个直接负责的高级工程师。

+   这些工程师对其他组件有相当的了解。

考虑到这一点，两级值班轮换将是最佳解决方案：

+   主要的值班工程师是第一个响应任何事件的。

+   主要的值班工程师可以将特定问题升级到组件值班工程师。

正如我们在第四章所说的，设计文档是一个活生生的东西，维护部分是最后添加和填写的，这不仅是因为在这个阶段，你对你的机器学习系统有一个完整的愿景，而且还因为到这个时候，你已经设法与其他团队和单位的代表建立了联系，并了解哪些个性将包括在你的项目工作组中。

## 摘要

+   负责系统设计和实施的人也负责系统的维护和支持。

+   一定要了解责任区域和分配给这些角色的人员。更重要的是，明确提醒这些人他们的角色，因为这比隐含地希望每个人都处于同一页面上更有价值。

+   为了跟随你系统的不断扩展，记得提供值班轮换以应对任何关键事件。

+   总是寻找团队效率和冗余之间的权衡，以避免过度劳累，同时保持足够的容量来应对高峰时段。

+   保持你系统中的每一份文档都更新并可供任何相关人员获取。虽然这可能需要前期额外的时力和精力，但文档最终会在长期中节省资源。

+   从小处着手，改进一两件事，建立信任，然后继续进行更有效果的改变。在这样做的时候，你很可能从同事那里获得更多支持，并收集更多关于系统的隐性知识，这将帮助你做出更好的决策。

+   尽量避免使你的解决方案过于复杂。过度的复杂性可能是个人雄心壮志的结果，也可能表明对问题理解不足、表面化研究、设定不相关目标，以及从一开始就没有覆盖明显的风险。
